<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-并发理论-对象锁（monitor）</title>
    <url>/2020/11/03/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88monitor%EF%BC%89/</url>
    <content><![CDATA[<h2><span id="一-简介">一、简介</span></h2><p>Java提供了一种内置的锁机制来支持原子性和可见性，就是使用Synchronized的同步块或同步方法。在使用synchronized同步的时候，包含两部分：</p>
<ul>
<li>a. 一个锁对象引用</li>
<li>b. 一块锁保护的代码块<a id="more"></a>     
例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//1.同步代码块</span></span><br><span class="line">	<span class="keyword">synchronized</span>（锁对象引用）&#123;</span><br><span class="line"><span class="comment">//锁保护的代码块</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//2.同步方法</span></span><br><span class="line">	<span class="comment">//2.1锁对象引用就是被修饰方法所在的实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br><span class="line">	<span class="comment">//2.2如果是静态方法</span></span><br><span class="line">	<span class="comment">//锁对象引用就是被修饰方法所在的Class对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>每个Java对象都可以用作一个实现同步的锁，因为每个Java对象都内置了一把锁，这种锁称之为内置锁或者监视器锁（monitor），俗称对象锁。</p>
<h2><span id="二-对象的内置锁特征">二、对象的内置锁特征</span></h2><ol>
<li>互斥性<br> 同一时间最多只能有一个线程持有这种锁。<br> 线程尝试获取一个被其他线程持有的内置锁，该线程必须等待（自旋）或者阻塞（自旋策略失效），并且请求内置锁被阻塞的线程不能被中断。</li>
<li>可重入性<br>如果某个线程试图获取一个已经由它持有的内置锁，那么这个请求就会成功。<br>实现原理为：为每个锁关联一个获取计数值和锁持有者线程，当计数值为0，表示这个锁没有被任何线程持有，当一个线程请求一个未被持有的锁时，JVM会将锁持有者线程（该线程）设置为请求线程，并且将计数值置为1，如果同一个线程再次请求这个锁，则计数值自增1，退出同步方法会同步块计数值将自减1，如果计数值减为0则这个锁会被释放。</li>
</ol>
<h2><span id="三-对象锁的原理实现">三、对象锁的原理实现</span></h2><p>Synchronized关键字其实就是实现对象内置锁的方式。<br>在线程进入同步代码块之前会获取对象的monitor，也就是获取到对象的锁；在退出同步代码块的时候（正常返回或者异常退出）都会自动释放对象的锁。<br>它是怎么识别这些同步代码块的呢？<br>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（例如 synchronized 关键字括号里的锁对象引用），作为所要加锁和解锁的锁对象。<br>它是怎么知道对象锁的位置（在哪加锁和解锁的呢）？<br>无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为：<br><img src="https://img-blog.csdnimg.cn/20200411202956609.png" alt="在这里插入图片描述"><br>如图在Mark Word会默认存放hasdcode，年龄值以及锁标志位等信息。<br>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：<br><img src="https://img-blog.csdnimg.cn/20200411203022822.png" alt="在这里插入图片描述"><br>如果互斥性造成被互斥的线程怎么处理<br>一般先通过自旋处理，如果自旋处理失败了就会阻塞线程。<br>自旋的实现原理就是，如果线程请求获取监视器锁失败，并不立刻阻塞线程，而是让线程执行一个忙循环（自旋）。自旋之后再次尝试获取锁。如果获取锁失败，这个过程会循环一定次数，超过某个阀值，如果还是获取不到锁，才阻塞线程。自旋可以通过-XX:+UserSpinning参数来开启，自旋的次数通过-XX:PreBlockSpin来更改（默认是10）。<br>自旋虽然避免了线程切换的损耗，但是需要占用处理器时间。自旋的效果取决于锁被占用的时间，如果锁被占用的时间很短，自旋等待的效果就会很好，反之，自旋只会白白消耗处理器资源，带来性能上的损耗。<br>JDK1.6引入了自适应的自旋锁。<br>对象头标记字段的锁状态的转化<br><img src="https://img-blog.csdnimg.cn/20200411203036721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="四-对象锁的分类">四、对象锁的分类</span></h2><h3><span id="偏向锁">偏向锁</span></h3><p>偏向锁的目的也是消除无竞争条件下的同步原语。偏向锁会偏向于第一个获取到它的线程，如果在获取到锁之后的过程中，没有发生锁竞争，那么持有偏向锁的线程将永远不需要再进行同步。相比轻量级锁，偏向锁能够消除轻量级锁多次加锁的CAS操作。<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li>a. 偏向锁的获取</li>
</ul>
<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 JVM会通过 CAS 操作，将当前线程的ID记录在锁对象的标记字段之中，并且将标记字段的锁标志位置为“01”，即偏向模式。<br>如果操作成功，在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101，是否包含当前线程的ID，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。<br>当有另外的线程尝试获取这个锁时，偏向模式宣告结束。如果当前对存于未锁定状态，撤销偏向恢复至未锁定（标记字段的锁标志位为“01”）。如果处于锁定状态，则升级为轻量级锁（标记字段的锁标志位为“00”），后续的同步操作便按照轻量级锁的规则来进行。</p>
<ul>
<li>b. 偏向锁的撤销</li>
</ul>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br><img src="https://img-blog.csdnimg.cn/2020041120320646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。<br><img src="https://img-blog.csdnimg.cn/20200411203219732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>c. 偏向锁的失效</li>
</ul>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。<br>如果某一类锁对象的总撤销数超过了一个阈值（对应JVM参数-XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 JVM会宣布这个类的偏向锁失效。<br>如果总撤销数超过另一个阈值（对应 JVM参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
<h3><span id="轻量级锁">轻量级锁</span></h3><p>轻量级锁的目标是在没有多线程的竞争下，减少重量级锁使用的操作系统互斥量产生的性能消耗。</p>
<ul>
<li>a. 加锁</li>
</ul>
<p>当进行加锁操作时，JVM会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录（Lock Record），并且将锁对象的标记字段复制到该锁记录中。<br>然后，JVM会尝试用 CAS（compare-and-swap）操作将锁对象的标记字段替换为锁记录的指针。如果操作成功，那么这个线程就获取了这个对象的锁，并且标记字段的锁标志位转变为“00”，表示该锁处于轻量级锁定状态。如果标记字段替换操作失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。JVM会先检查对象的标记字段是否指向当前线程的栈帧，如果是表明当前线程已经持有了该对象的锁。否则说明这个对象的锁已经被其它线程所持有了，这时，轻量级锁膨胀为重量级锁，锁的标记字段的锁标志位变为“10”，标记字段存储的就是指向重量级锁（互斥量）的指针，后面的线程要进入阻塞状态。</p>
<ul>
<li>b. 解锁</li>
</ul>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://img-blog.csdnimg.cn/20200411203341249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3><span id="重量级锁">重量级锁</span></h3><p>重量级锁是 JVM中传统的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>
<h2><span id="五-各种锁的比较">五、各种锁的比较</span></h2><p><img src="https://img-blog.csdnimg.cn/20200411203352349.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title> Java-并发concurrent包-locks包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-locks%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-atomic包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-atomic%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-简介</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-源码分析-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Thread%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-Thread%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-三大特性</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-final</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-final/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-volatile</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-volatile/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-synchronized</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-synchronized/</url>
    <content><![CDATA[<h2><span id="一-什么是synchronized">一、什么是Synchronized</span></h2><p>这个可以参考一下介绍：Java-并发理论-JMM内存模型：volatile和锁（synchronized，ReentrantLock）。<br>Synchronized关键字主要是用来解决多线程的线程安全问题的。是一种同步机制。那么这些安全性问题主要是来源JMM内存模型中主内存和线程的工作内存带来共享变量的可见性问题，以及重排序带来的问题；Java中的关键字synchronized同步机制就具备解决这些共享数据的线程安全问题，但是这种同步机制的效率很低，但是synchronized是其他并发容器实现的基础，理解它会提高并发编程有很大帮助。</p>
<a id="more"></a>     
<h2><span id="二-synchronized的作用是什么">二、synchronized的作用是什么</span></h2><p>主要是在多线程环境下保证线程安全<br>    1. 保证了线程的原子性，即被保护的代码块或方法是一次被执行的，中间没有其他线程同时访问<br>    2. 保证了共享变量的可见性，即当执行完synchronized的代码块或方法之后，修改后的共享变量会更新到主内存中，其他线程是可见的。</p>
<h2><span id="三-synchronized的实现原理">三、Synchronized的实现原理</span></h2><h3><span id="synchronized基本用法">synchronized基本用法</span></h3><p>synchronized关键字在Java中使用很简单，可以使用在代码块中和方法上，具体的使用位置如下：<br><img src="https://img-blog.csdnimg.cn/20200411203809896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>synchronized是一种互斥锁，可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。</p>
<h3><span id="synchronized底层实现原理">synchronized底层实现原理</span></h3><ul>
<li>a. 监视器（monitor）机制<br>i. synchronized是一种内置锁/监视器锁，Java中每个对象都有一个内置锁（monitor监视器锁，就像一个标记一样），而synchronized就是使用对象的内置监视器锁来将代码块或方法锁定的。<br>ii. 在底层，synchronized关键字对代码块是通过monitorenter和moniterexit指令实现的；对方法是通过方法修饰符上的ACC_SYNCHRONIZED实现的。<br>iii. synchronized具有内置锁的可重入性，即它是重入锁，如果在一个线程中，方法A使用了synchronized锁，而在方法A中又存在方法a中也存在使用synchronized锁，那么从方法A调用方法a的过程中，即从外锁再进入内锁是不需要重新获取锁了，在外锁获取一次就可以了，到里面继续使用原来的锁，因为锁是线程持有的，在一个线程内不会重复获取锁，这就是重入锁<br>下面是在多线程中使用synchronized关键字的对象Object与监视器之间的关系：<br> <img src="https://img-blog.csdnimg.cn/20200411203857917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">上面可以看出，如果想要访问使用synchronized的对象Object，首先需要获取Object的监视器（使用monotorenter命令）,若获取失败则进入同步队列，线程状态变成Blocked状态，当Object的监视器占有者释放后，在同步队列中的线程就有机会重新获取该监视器了。</li>
<li>b. synchronized的happens-before规则<br> 监视器锁规则是：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。<br> 看一下下面代码，若有两个线程A和B分别执行writer和reader方法（假设线程A先执行），是怎么执行上面这条规则的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">	        a++;                                <span class="comment">// 2</span></span><br><span class="line">	    &#125;                                       <span class="comment">// 3</span></span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">	        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">	    &#125;                                      <span class="comment">// 6</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200411203955342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系。<br>    现在重点关注2 happens-before 5，通过这个关系我们可以得出什么？<br>    根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</p>
<ul>
<li>c. 锁获取和锁释放的内存定义<br> 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br> 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>参考：Java-并发理论-JMM内存模型：2）锁：锁释放和锁获取的内存定义</li>
</ul>
<h2><span id="四-synchronized的优化">四、synchronized的优化</span></h2><p> 对于上面已经很详细说了synchronized关键字的底层原理了，简单来说，它最大的特点就是：<br>    在同一时刻只有一个线程能够对得对象得监视器（monitor），从而在进入同步代码块或方法中，如果其他线程进来需要等监视器释放锁，这种行为表现为互斥性（排他性）。<br>但是如果每次都只能有一个线程进入方法或代码块，这样执行的效率必然很低的，就像我们买东西后排队付钱一样，原来的方式是拿现金到收银台给收银员付款，还要找零钱等等，得一个一个来，效率很低，现在呢，出现了微信支付和支付宝支付，付款只需要拿出收集扫一下二维码就可以付款了，很方便，效率相对于提高了很多；同样对于synchronized效率低得情况下也出现了类似的优化。</p>
<h3><span id="优化之cas算法无锁算法">优化之CAS算法（无锁算法）</span></h3><ul>
<li>a. 什么是CAS<br>CAS的全称为compare and swap(比较并替换)，是一种乐观的思想，相对于Synchronized是一种悲观的思想，也就是说synchronized时时刻刻都想着肯定会有其他线程跟我竞争资源的，我就把这个共享资源一直占用着，别的线程只能在外面等着，处于阻塞状态，直到我释放了你才能用；而CAS是这样想的，并不是时时刻刻都有别的线程跟我竞争资源的，如果真的有人过来跟我竞争资源的，我才告诉他等我用完释放了你才能使用，这样别的线程就不会都处于阻塞状态了，不需要竞争的线程还可以继续工作下去，只有真正需要竞争的才需要阻塞等待。那么CAS是怎么做到的呢？</li>
<li>b. CAS的实现过程<br>实现CAS的过程需要三个操作数：内存中的原值V，旧的预期值A，需要修改的新值B，实现的过程只需要三步：<pre><code>i. 比较A值与V值是否相等
ii. 如果相等则说明旧值A还是最新的内存值，没有被其他线程更改过，将B值替换V值，返回更新成功
iii. 如果不相等，则说明内存值已经被其他线程修改过了，不是最新的值，所以不能将B值图换成V值，更新失败，返回内存原值V即可；并可以重新尝试。</code></pre>当多个线程同时使用CAS操作一个变量时，只有一个线程会操作成功，但并不会阻塞其他线程，只是其余的都会收到失败的信号，失败的线程可以选择重新尝试也可以选择挂起线程。</li>
<li>c. CAS基本的底层原理<br> java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。<br> unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg<br> Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>
<li>d. 在Java中的应用<br>在JUC包中利用CAS算法实现的类有很多，可以说是支持起整个concurrency包的实现，在locks包中的实现会有CAS改变state变量，在atomic包中的实现类几乎都是利用CAS算法实现的，一般的应用场景：<pre><code>自旋锁，会一直while()循环，直到CAS操作成功为止，如下执行lock()方法的时候</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		  <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    <span class="keyword">while</span>(!sign .compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    sign .compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e. CAS的缺点<br> i. ABA的问题，CAS会检查旧值有没有变化，如果出现这种情况，旧值A跟原值V比较，相等了才替换称B值，若在比较之前，A值变成了B值，然后有变成A值，比较的时候旧值依然为A值没有变化，但实际上已经发生了变化，解决的方法也很简单，像数据库中使用的乐观锁的方式，加一个版本号就可以解决了，原来的变化为A-B-A,解决后为1A-2B-3A；Java在1.5版本以后的atomic包中就提供了AtomicStampedReference来解决ABA的问题。<br> ii. 自旋时间过长的问题，使用CAS时是非阻塞同步（无锁），也就是说不会将线程挂起，会自旋（就是一个死循环）进行下一次尝试，如果自旋时间过长也会对性能有很大的影响。目前只是限制自旋次数。最终自旋失败了就进去阻塞状态。如果JVM能支持处理器提供的pause指令，那么效率上会有很大的提升。<br> iii. 只能保证一个共享变量的原子操作<br> iv. 如果只对一个共享变量进行cas操作时能保证原子性，但是如果对多个共享变量进行操作，cas就不能保证其原子性了，有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-教程-简介</title>
    <url>/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1><span id="spring是什么">spring是什么</span></h1><p>spring是一个企业级应用的开源框架，它也是轻量级的、一站式的、面向切面编程的、依赖注入DI和容器IOC的、模块化的框架。<br>总的来说，Spring就是用来替代更加重量级的企业级的Java技术。</p>
<a id="more"></a>
<h1><span id="spring能做什么">spring能做什么</span></h1><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性的角度而言，绝大部分Java应用都可以从Spring中受益。<br>spring实现了使用简单的组件将Java对象配置组合成 了一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象。Spring对JavaEE中非常难开发的一些API（JDBC、JavaMail、远程调用等），都提供了封装，大大降低了这些API的应用难度。</p>
<ul>
<li>轻量级：立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>非侵入式：也就是自己开发的类不依赖Spring的API接口，对现有的类结构没有影响，也能够增强JavaBean的功能  </li>
<li>IOC容器：spring是一个容器，因为它包含并且管理应用对象的生命周期。<br>降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>一站式：在AOP和IOC的基础上可以整合出各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的JDBC）;<br>spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。<br>总的来说Spring可以简化Java的开发：</li>
</ul>
<ol>
<li>基于POJO（也叫Java bean）轻量级和最小侵入式开发</li>
<li>通过IOC、依赖注入和面向接口实现松耦合</li>
<li>基于切面进行声明式编程</li>
<li>通过切面和模板来减少样板式代码</li>
</ol>
<h1><span id="spring为什么出现">spring为什么出现</span></h1><p><img src="/images/Spring-1-1.png" alt="B/S结构"><br>这张图上展示了一个基于SSH,B/S结构的单体Java应用的搭建过程，首先通过浏览器进入到Filter拦截器，进入到Structs2，通过Service层进入到Hibernate，从而进行操作数据库，若整个过程都是由SpringIOC容器控制就显得那么简单了。说白了就是为了简化复杂的操作过程，减少问题的出现。这张图向我们展示了一个比较基础的JavaWeb的搭建过程。万变不离其宗，后来使用的SSM框架，现在比较火的微服务架构，都离不开这张图上展示的内容所提供给大家的思想。每个框架的实现宗旨都是一样的，只不过实现的方式不一样。其实在这个框架最初的时候应该是以JSP+Servlet比较常用，后来为了解决前后端分离的问题，降低耦合度。将这些功能结构按照MVC分层实现。<br>个人的理解MVC为一种程序设计思想，可以很多场合使用到，从Web、后端、移动端在很多的场合下将MVC作为一种程序设计思想应该是比较恰当的。</p>
<h1><span id="spring结构体系模块化">spring结构体系（模块化）</span></h1><p><img src="/images/Spring-1-2.png" alt="Spring结构"></p>
<h2><span id="核心容器">核心容器</span></h2><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：<br>-** spring-core模块**提供了框架的基本组成部分，包括 IoC容器 和依赖注入功能。</p>
<p>-** spring-beans 模块**提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
<p>-** context模块**建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
<p>-<strong>spring-expression模块</strong>提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
<p>它们的完整依赖关系如下图所示：<br><img src="/images/Spring-1-3.png" alt="Spring依赖关系图"><br><img src="/images/Spring-1-4.png" alt="Spring关系"></p>
<h2><span id="数据访问集成">数据访问/集成</span></h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：<br>注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）<br>• JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。<br>• ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。<br>• OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。<br>• JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。<br>• 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h2><span id="web">Web</span></h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：<br>• Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。<br>• Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。<br>• Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。<br>• Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
<h2><span id="其他">其他</span></h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：<br>• AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。<br>• Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。<br>• Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。<br>• Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。<br>• 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-JMM内存模型</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2><span id="一-什么是jmm内存模型">一、什么是JMM内存模型</span></h2><p>Java内存模型即 Java Menory Model，简称JMM。JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方法。JVM是整个计算机虚拟模型，所以JMM隶属于JVM的。<br>    Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此在Java1.5版本对其进行了重构，现在的Java8仍沿用了1.5的版本。 模型如下：<br><img src="https://img-blog.csdnimg.cn/20200411194726969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>     

<h2><span id="二-java内存模型与并发编程的关系">二、Java内存模型与并发编程的关系</span></h2><p>如果想要深入了解Java并发编程，就要先理解好Java内存模型。</p>
<h3><span id="并发编程的模型分类">并发编程的模型分类</span></h3><p>总共分成两类：</p>
<ul>
<li>共享内存并发模型</li>
<li>消息传递并发模型</li>
</ul>
<h3><span id="在并发编程中的关键问题">在并发编程中的关键问题</span></h3><ul>
<li>线程之间如何通信</li>
<li>线程之间如何同步</li>
</ul>
<p>通信是指线程之间以何种机制来交换信息，在命令式编程中（编程主要分类：允许有副作用的命令式编程，不允许有副作用的函数式编程和不描述操作执行顺序的声明式编程），线程之间的通信机制有两种：</p>
<ul>
<li>共享内存：在共享内存的并发模型里，线程之间共享程序的公共状态（共享变量），线程之间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递：在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信</li>
</ul>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制，有两种方式：</p>
<ul>
<li>共享内存：同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li>
<li>消息传递：由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</li>
</ul>
<p>Java里面的并发就是采用共享内存的并发模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员是完全透明的（即你是看不见就发生了并发过程）。</p>
<h3><span id="java的并发模型采用的是共享内存模型">Java的并发模型采用的是共享内存模型</span></h3><p>Java线程之前的通信总是隐式进行的，整个通信过程对程序员完全透明。如果编写多线程程序不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2><span id="三-java内存模型的抽象">三、Java内存模型的抽象</span></h2><p>在Java中的共享变量有：所有实例域和数组元素存储在堆内存中，堆内存在线程之间共享（方法区也是线程共享，方法区保存类信息【类名称，方法，字段属性】，常量和静态变量 ）。局部变量、方法定义参数和异常处理器参数不会再线程之间共享，他们不会有内存可见性的问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（JMM）控制。JMM决定了一个线程对共享变量的写入时对另一个线程可见。从抽象的角度来看，JMM定义了线程与主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不是真实存在。<br>JMM抽象模型图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195125640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从图上看，如果线程A要和线程B通信的话，所经历的步骤是：</p>
<ul>
<li>线程A需要将本地内存A中的共享变量副本刷新到主内存中去</li>
</ul>
<ul>
<li>线程B去主内存中读取线程A之前已经更新过的共享内存</li>
</ul>
<p>步骤图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195255403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整体看，这两个步骤实质上是线程A在向线程B发送消息，而这个通信过程必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为我们提供内存的可见性保证。</p>
<h3><span id="重排序带来的并发问题">重排序（带来的并发问题）</span></h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p>
<ul>
<li>编译器优化的重排序（编译器重排序）。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序（处理器重排序）。现代处理器<br>采用了指令级并行技术将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序。</li>
<li>内存系统的重排序（处理器重排序）。由于处理器使用缓存和读写缓存，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="https://img-blog.csdnimg.cn/20200411195837536.png" alt="在这里插入图片描述"><br>上面的重排序可能会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则则会禁止特定类型的编译器重排序（并不是所有的编译器重排序都要禁止），对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br> JMM属于语言级的内存模型，它确保在不同的编译器和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为我们提供一致的内存可见性保证。还有就是重排序（包括编译器和处理器重排序）必须遵守as-if-serial规则（解决编译器重排序问题），该语义也就是说不管怎么排序，单线程程序执行的结果都不能改变；让人感觉单线程程序是按程序的顺序执行的，如果多个线程操作之间没有数据的依赖性则是允许重排序的，但是如果存在数据的依赖，则不会重排序的，这一点的问题是有保证的，所以现在的主要问题是，处理器使用缓存来读写数据，会导致数据读取不一，带来一种代码指令被重排序的感觉，对于共享变量，很容易出现问题。</li>
</ul>
<h4><span id="编译器重排序">编译器重排序</span></h4><p>编译器重排序的定义为：如果两个操作它们之间没有任何的依赖关系，也就是说A操作的结果和B操作的结果相互间没有任何的影响，此时编译器就可以对这两个操作进行重排序，如果两个操作共同操作一个共享变量，其中有一个操作为写，那么它们两是有数据依赖性的，从重排序会对最终执行结果产生影响，所以编译器重排序（也包括处理器重排序）都会遵循数据依赖性，编译器和处理器不会改变存在依赖关系的两个操作的执行顺序</p>
<h4><span id="处理器重排序">处理器重排序</span></h4><p>现在的处理器使用写缓冲区来临时保存向内存写入的数据。写缓存区可有保证指令流水想般持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟，同时通过批处理方式刷新写缓存区，以及合并写缓存区中对同一内存地址的多次写，可以减少对内存总线的占用，。虽然写缓存区有这么多的好处，但是每个处理器上的写缓存区，仅仅对它所在的处理器可见，这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读写操作的执行顺序，不一定与内存实际发生的读写操作顺序是一致的。<br>举个例子：a，b变量为共享变量，两个处理器项目访问共享变量。<br><img src="https://img-blog.csdnimg.cn/20200411200004201.png" alt="在这里插入图片描述"><br> 初始状态：a=b=0;<br>处理器允许执行后可能得到的结果：x=y=0;<br>具体原因如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411200042338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
<p>出现的一个执行顺序：<br>处理器A和处理器B同时把共享变量写入在写缓冲区中（A1，B1步骤），然后再从主内存中读取另一个共享变量的值（A2,B2步骤），最后才把自己写缓冲区中保存的脏数据刷新到主内存中（A3,B3步骤）。但最后执行下来就会得到一个结果：x=y=0。<br>    从实际理想的发生的顺序来看，正常执行顺序是这样的：<br>    直到处理器A执行了A3步骤之后已经刷新自己的写内存，写操作A1才算真正被执行，然后接着读A2。即发生的顺序：A1-&gt;A2.<br>    但内存操作实际发生这种可能：A2–&gt;A1。此时处理器A的内存操作顺序被重排序了。由于写缓存区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一样。由于现在的处理器都会使用写缓存区，因此都会允许对读写操作指令进行重排序。</p>
<h3><span id="内存屏障指令解决处理器重排序问题">内存屏障指令（解决处理器重排序问题）</span></h3><p>为了解决上面说的重排序问题，需要保证内存的可见性，可以使用内存屏障来达到这个效果，通过在适当位置插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为以下四类：</p>
<ul>
<li>a. LoadLoad屏障<br> 适用场景：Load1;LoadLoad;Load2<br> Load1和Load2代表两条读指令。在Load2读取指令装载之前，确保Load1读指令已经装载完毕。</li>
<li>b. StoreStore屏障<br>适用场景：Store1;StoreStore;Store2<br>Store1和Store2代表两条写指令。在Store2写指令的存储之前（刷新到内存中），确保Store1写指令的数据对其他处理器可见（刷新到内存中）</li>
<li>c. LoadStore屏障<br> 适用场景：Load1；LoadStore；Store2<br> 在Store2写指令的存储之前（刷新到内存中），确保Load1读指令已经装载读取完毕。</li>
<li>d. StoreLoad屏障<br>使用场景：Store1;StoreLoad;Load2<br>在Load2读指令装载之前，确保Store1写指令的数据对其他处理器可见（刷新到内存中），开销最大；该屏障会使之前的所有内存访问指令（存储和状态指令）完成之后，才执行该屏障之后的内存访问指令。</li>
</ul>
<h3><span id="happens-before规则定义两个操作之间的执行顺序利用内存屏障指令提供内存可见性的保障">happens-before规则（定义两个操作之间的执行顺序，利用内存屏障指令提供内存可见性的保障）</span></h3><p>JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另外一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作可以是一个线程内的，也可以是不同线程之内的。<br>与程序员密切相关的happens-before规则（共有八大规则）如下：<br>(注意，两个操作之间具有happens-before关系，并不意味这一个操作必须在后一个操作之前执行，happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见。且前一个操作（执行的结果）按顺序排在第二个操作之前。)</p>
<ul>
<li>a.程序顺序规则：两个操作之间存在happens-before关系，那么第一个操作的结果对第二个操作可见并且第一个操作的执行顺序在第二个操作之前。</li>
<li>b. 监视器锁规则：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。</li>
<li>c. volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>d.  传递性规则：如果 A  happens-before B,且B happens-before C,则A<br>happens-before C.</li>
<li>e.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>f.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>g. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>h. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ul>
<h3><span id="总结一下">总结一下</span></h3><p>解决重排序问题主要两种规则：as-if-serial（解决编译器重排序）和happens-before（解决处理器重排序）</p>
<ul>
<li>a.As-if-serial规则保证单线程程序的执行结果不被改变，happens-before规则保证正确同步的多线程程序的执行结果不会被改变</li>
<li>b.as-if-serial规则给我们一种感觉：单线程程序是按照程序顺序来执行的，而happens-before规则是正确同步的多线程程序是按照happens-before指定的顺序来执行的，</li>
<li>c. as-if-serial和happens-before规则都是为了在不改变程序执行结果的前提下，尽可能的提高程序的执行并行度。            </li>
</ul>
<h2><span id="四-jmm在实际开发中遇到的问题及解决方法">四、JMM在实际开发中遇到的问题及解决方法</span></h2><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要有两个问题：</p>
<ul>
<li><p>a. 共享对象对各个线程的可见性（使用volatile关键字解决）</p>
</li>
<li><p>b. 共享对象的竞争现象（使用同步锁解决）</p>
</li>
</ul>
<p>我们在实际的多线程开发中需要从原子性、可见性、有序性这三方面进行考虑，有序性的话JMM已经帮我们基本优化了，重点看一下原子性和可见性</p>
<h3><span id="共享对象的可见性锁以synchronized为例">共享对象的可见性（锁以synchronized为例）</span></h3><p>当多个线程同时操作一个共享对象时，如果没有合理的使用volatile和synchronized关键字，一个线程对共享对象的更新有可能导致其他线程不可见。 我们的共享对象存储在主内存中，一个CPU的线程去读取主内存的数据到CPU缓存中，然后对共享内存做了更改，但CPU缓存中的更改后的对象还没有刷新到主内存中，此时其他线程对共享对象的更改是不可见的，最终每个线程都会拷贝共享变量位于不同的CPU缓存中。要解决这个可见性问题，我们可以使用Java volatile关键字，volatile关键字可以保证共享变量会直接从主内存中读取，而对共享变量也会直接写到主内存中去。volatile原理是基于CPU内存屏障实现的。</p>
<h3><span id="竞争现象锁以sybchronized为例">竞争现象（锁以sybchronized为例）</span></h3><p>如果多个线程共享一个对象，它们同时修改这个共享对象，这就产生了竞争关系。例如线程A和线程B共享一个对象，线程A从主内存中读取共享对象到CPU缓存中，同时，线程B也同时读取共享对象到它的CPU缓存中，线程A和B同时对该共享变量做相同的操作（如同时进行+1操作，对象初始值为1），不管线程A或B有没有刷新到主内存中，并行执行，结果都会出错（相加了两次，结果却为2）。要解决这种竞争关系问题，我们可以使用java中的synchronized代码块，synchronized代码块可以保证同一时刻只有一个线程进入到代码竞争区，synchronized代码块也能保证代码块中所有变量都是从主内存中读，当线程退出的时候，对所有变量的更新都将会flush到之内存中，不管这些变量是不是volatile类型的。</p>
<h3><span id="volatile和锁synchronizedlock">volatile和锁（synchronized，Lock）</span></h3><p>对于一个volatile变量的单个读/写操作，与对一个普通变量的读写操作使用同一个锁来同步，它们之间的执行效果时相同的（因为它们都是从主内存中读写变量的）。<br>相同点：</p>
<ul>
<li>a.可见性。锁的happens-before规则是保证释放锁和获取锁的两个线程之间的内存可见性，这跟volatile的可见性是一样的：对于一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>b.原子性。锁的语义（同步）就决定了临界区代码的执行具有原子性，跟volatile一样，对于volatile变量的读取也具有原子性，但是对于多个volatile操作（类似于volatile++这种复合操作）就不具备原子性。</li>
</ul>
<p>（原子性就是在执行的过程中不会被中断，一次执行的，不会被其他线程干扰）</p>
<p>不同点：</p>
<ul>
<li>c. volatile：读写内存定义<br> 当读一个volatile变量的时候，JMM会把线程对应的本地内存置为无效，线程将从主内存中读取共享变量。<br> 当写一个volatile变量的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</li>
</ul>
<p>volatile语义的实现：<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>a. 在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>b. 在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>c. 在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>d. 在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>因为确保写操作内存可见，所以前面的写和后面的读写都不能重排序（按照原来的顺序来执行）<br>因为确保别的线程读正确，所以后面的读写指令都不能重排序（必须确保volatile读完后才操作，为了可见性）<br>具体插入内存屏障后生成的指令示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411200926802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这种volatile读写操作的内存屏障是非常保守的，在实际执行过程中，只要不改变volatile读写的定义，编译器可以根据具体情况省略不必要的屏障。</p>
<ul>
<li>d. 锁：锁释放和锁获取的内存定义<br>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li>
</ul>
<p>锁内存定义的实现：<br>锁有很多，包括ReentrantLock，Synchronized，公平锁，非公平锁，AQS等等，现在借助ReentrantLock来说明一下锁内存定义的实现。<br>首先是concurrent包的实现：<br>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>a. 首先声明共享变量为volatile</li>
<li>b. 然后使用CAS的原子条件更新来实现线程之同步</li>
<li>c. 同时配合以volatile的读写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信</li>
<li>d. AQS</li>
<li>e. 非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类）</li>
</ul>
<p>这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411201135105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="五-总结">五、总结</span></h2><h3><span id="jmm的设计示意图">JMM的设计示意图</span></h3><p><img src="https://img-blog.csdnimg.cn/20200411201319944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>a.JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A<br>happens-before B）。</li>
<li>b.<br>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h3><span id="java程序的内存可见性保证">Java程序的内存可见性保证</span></h3><ul>
<li><p>a.单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同</p>
</li>
<li><p>b.正确同步多线程程序。正确的同步多线程与该程序在顺序一致性内存模型中执行的结果相同。JMM通过限制编译器和处理器的重排序来为我们提供内存可见性保证。</p>
</li>
<li><p>c.未同步/未正确同步的多线程程序。JMM为它们提供了最小的安全保证：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200411201341702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
</li>
</ul>
<h3><span id="最后">最后</span></h3><p>从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如i++不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。J.U.C包下的并发工具类和并发容器也是需要花时间去掌握的。</p>
<p>附录：<br>硬件内存架构<br>不管什么内存模型最终还是运行在硬件上，我们必须了解一个计算机的硬件内存。计算机架构图：<br><img src="https://img-blog.csdnimg.cn/2020041120135981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在计算机都有多个CPU,每个CPU又有多个核心，多线程就可以在各个不同的CPU核心中运行。<br>在CPU内部有一组CPU寄存器，也就是CPU的存储器，CPU操作寄存器的速度要比操作计算机的主内存快得多，所以为了提高效能，主内存和寄存器之间就存在一个CPU缓冲区，CPU操作缓冲区的速度快于主内存但慢于CPU寄存器，某些CPU可能有多个缓存区（一级缓存和二级缓存）。计算机的主内存也叫RAM，所有的CPU都能访问主内存，主内存比CPU缓存和CPU寄存器还要大得多。<br>当一个CPU需要访问主内存的时候，会先读取一部分主内存数据到CPU缓存，进而再读取CPU缓存到CPU寄存器。<br>当CPU需要写数据到主内存时，同样也会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主内存中。<br>Java内存模型和硬件内存架构之间的桥接<br>    <img src="https://img-blog.csdnimg.cn/20200411201410856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Java内存模型和硬件内存架构并不一样，硬件内存架构并没有区分栈和堆，从硬件上看，不管时栈还是堆，大部分数据都会存到主内存中，还可能一部分堆和栈数据存在CPU寄存器上。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-线程的基本状态和操作</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><p>线程拥有自己的生命周期，一条线程从创建到执行完毕的过程就是线程的生命周期，那么在线程的生命周期的每个过程中可能在不同的时候处于不同的状态，用状态来描述生命周期那是最好不过了。<br>那么线程的生命周期到底有多少种状态呢，它们不同的状态又是如何通过状态的转化操作来完成线程的生命周期呢，下面就按照线程的生命周期的状态和状态之间的转换操作来详细说明。</p>
<a id="more"></a>
<h2><span id="二-线程的基本状态">二、线程的基本状态</span></h2><p>线程的状态没有严格的定义，可以先简单划分以下几个基本状态：<br>    <img src="https://img-blog.csdnimg.cn/20200411192919905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图中的五种状态描述如下：<br>a. New（新建）状态：一个线程被创建了但未被启动就处于新建状态，即在程序中使用new Thread()创建的线程实例就处于新建状态。<br>b. Runnable(可运行)状态：创建的线程实例通过调用start（）方法之后该线程就处于可运行状态，处于此状态的线程不一定说处于运行状态，Java多线程使用的线程调度策略是抢占式调度，每个可运行线程轮着获取CPU时间片，可以想象成一个可运行线程池，start()方法就是把一个线程放进可运行线程池中，CPU按照一定规则一个个执行线程池里面的线程。<br>c. Running（运行）状态：当可运行线程获取到CPU执行时间片就立即进入运行状态。<br>d. Not Running（非运行）状态：运行中的线程因某种原因暂时放弃CPU的使用权，可能是因为只执行了挂起、睡眠或者等待操作；在执行IO操作时，由于外部设备速度远低于处理器速度也可能导致线程暂时方法CPU使用权；在获取对象的同步锁的过程中如果同步锁被其他线程获取了，这样也会导致线程暂时放弃CPU的使用权了。<br>e. Dead(死亡)状态：线程执行完run()方法的任务之后，或者因为异常而导致退出任务，线程就进入死亡状态，该状态下是不能转换成其他状态了。</p>
<h2><span id="三-线程的状态转换">三、线程的状态转换</span></h2><p>在上面的五个状态中，是通过这些基本操作来完成状态之间的转换，基本操作配合五种状态就完成了线程的交替运行，把Not Running状态分成：Blocked（阻塞）、Waiting（等待）和Timed_Waiting(超时等待)这三个状态（以Synchronized锁及相关方法为例），如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411193016770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Blocked(阻塞)状态：当线程出现资源竞争，等待获取同步锁时，线程就会进入阻塞状态，直到线程获取到了锁，线程才会进入可运行状态。</li>
<li>Waiting(等待)状态：运行中的线程执行了Object.wait(),Thread.join(),LockSupport.park()等方法或者被其他线程调用interrupt()中断方法的时候就会进入等待状态，便进入了等待线程队列，如果有锁会释放锁，当在其他线程中调用对象的notify(),notifyAll(),LockSupport.unpart()方法就会唤醒等待线程队列中的线程，notify是随机唤醒一个线程，notifyAll是唤醒所有线程，唤醒后的线程会对该对象的monitor占有权竞争，获得占有权的线程才能转化为可运行状态。</li>
<li>Timed_Waiting(超时等待)状态：在wait(long),sleep(long),join(long)和LockSupport.partNanos(long),LockSupport.partUntil(long)方法中都加入了超时，调用这些方法设置超时时间后线程会进入超时等待状态，同时会把占有的锁释放；如果调用了notify(),notifyAll(),LockSupport.unpart()方法或者超时时间到了，线程就会被唤醒，重新对该对象的monitor占有权竞争，获得占有权的线程才会转化为可运行状态</li>
</ul>
<h2><span id="四-线程的基本操作">四、线程的基本操作</span></h2><p>从上面的图可以看出，线程的基本操作就是为了完成线程状态之间的转化，同时还是线程间的通信方式。</p>
<h3><span id="新建线程">新建线程</span></h3><p>新建线程的方式有三种：</p>
<ul>
<li>重写Runnable接口的run()方法创建线程（Thread类实现了Runnable接口，两者启动线程都是通过Thread类，运行的目标线程是Runnable类型的，所以只要是Runnable的子类都可以通过Thread类来启动线程）:<br><strong>i.</strong> 创建Thread类型对象，同时重写run()方法，然后通过Thread类启动线程<br><strong>ii.</strong> 创建Runnable类型对象，同时实现run()方法，然后通过Thread类启动线程</li>
<li>重写Callable接口的call()方法实现创建线程，由于含有回调的方法，所以配合FutureTask类可以实现异步结果返回效果（FutureTask类实现了RunnableFuture接口【该接口又继承了Runnable接口和Future接口】）<br>i. 创建Callable类型对象，同时实现call()方法，然后创建FutureTask类对象并传入Callable类型对象同时指定返回值类型，然后通过Thread类启动线程。</li>
<li>利用线程池Excutor创建线程（推荐使用这种）。ExcutorService接口含有submit()方法，参数可以是Callable接口类型和Runnable接口类型；若<br>参数是Callable接口类型，返回的是Future接口类型，可以使用Executors工具类来创建ExcutorService类型对象，然后使用ExcutorService对象调用Callable接口实现类，最后使用Future接收返回的结果。若参数是Runnable接口，则直接调用即可。（后面会专门分析FutureTask类和Excutors工具类）</li>
</ul>
<p>代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020/2/26</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@desc</span> 创建线程的方式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * 方法一：通过创建Thread类型对象，同时重写run()方法</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span>  Thread()&#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Thread类型对象，同时重写run()方法。。。"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;.start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式二：通过创建Runnable类型对象,同时实现run()方法</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Runnable类型对象,同时实现run()方法"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;).start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式三：通过实现Callable接口并实现call()方法,并异步返回执行结果</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        FutureTask&lt;String&gt; result=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过实现Callable接口并实现call()方法,并异步返回执行结果"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程执行完成"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">	        System.out.println(<span class="string">"callable接口执行返回的结果："</span>+result.get());</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式四：通过线程池来创建（只列举实现Callable接口）</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">	        FutureTask&lt;String&gt; result1= (FutureTask&lt;String&gt;) service.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line">	</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过线程池方式创建线程"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程池执行Callable的call方法返回的结果"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        System.out.println(<span class="string">"线程池返回的结果："</span>+result1.get());</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="其他对于线程的操作方法">其他对于线程的操作方法</span></h3><p>可以参考：Java-并发理论-源码分析-Thread类:常用方法（主要是操作线程的方法）<br>列举一下join()方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        Thread previousThread = Thread.currentThread();</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	            Thread curThread = <span class="keyword">new</span> JoinThread(previousThread);</span><br><span class="line">	            curThread.start();</span><br><span class="line">	            previousThread = curThread;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">private</span> Thread thread;</span><br><span class="line">	</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                thread.join();</span><br><span class="line">	                System.out.println(thread.getName() + <span class="string">" terminated."</span>);</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                e.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程，直到for循环执行完了，main线程执行完了，就会从上往下一个个继续执行。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-首页</title>
    <url>/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<h2><span id="简介">简介：</span></h2><p>基本包含了Java并发编程的知识内容同时囊括并发Concurrent包的重点源码分析，如有问题欢迎评论指出，谢谢支持！<br>关注微信公众号获取更多知识：当代猿</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200409181814334.png#pic_center" alt="微信公共号二维码"></p>
<h2><span id="思维导图">思维导图：</span></h2><p><img src="https://img-blog.csdnimg.cn/20200409181910892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：思维导图链接，待完成后一起公布。</p>
<h2><span id="目录">目录：</span></h2><p>说明：目录会持续更新</p>
<ol>
<li>Java-并发编程-认识并发编程</li>
<li>Java-并发基础-线程的基本状态和操作</li>
<li>Java-并发理论-JMM内存模型</li>
<li>Java-并发理论-对象锁（monitor）</li>
<li>Java-并发理论-关键字-synchronized</li>
<li>Java-并发理论-关键字-volatile</li>
<li>Java-并发理论-关键字-final</li>
<li>Java-并发理论-三大特性</li>
<li>Java-并发理论-源码分析-Thread类</li>
<li>Java-并发concurrent包-简介</li>
<li>Java-并发concurrent包-atomic包</li>
<li>Java-并发concurrent包-locks包</li>
<li>Java-并发工具-并发容器-ConcurrentHashMap</li>
<li>Java-并发工具-并发容器-CopyOnWriteArrayList</li>
<li>Java-并发工具-并发容器-CopyOnWriteSet</li>
<li>Java-并发工具-并发容器-阻塞队列</li>
<li>Java-并发工具-线程池-原理&amp;ThreadPoolEcecutor</li>
<li>Java-并发工具-线程池-原理&amp;ScheduledThreadPoolExecutor</li>
<li>Java-并发工具-基本类FutureTask</li>
<li>Java-并发工具-工具类Excutors</li>
<li>Java-并发工具-工具类CountDownLatch</li>
<li>Java-并发工具-工具类CyclicBarrier</li>
<li>Java-并发工具-工具类Semaphore</li>
<li>Java-并发工具-工具类Exchanger</li>
<li>Java-并发实践-生产者与消费者</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-认识并发编程</title>
    <url>/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><h3><span id="什么是并发">什么是并发</span></h3><p>在Java中并发就是指多线程的进程环境，进程是系统进行资源分配和调度的独立单位，每一个进程都有它的内存空间和系统资源，在同一个进程内执行的多个任务就可以看作是多个进程，线程存在于进程内，进程负责分配调度线程，线程负责执行程序，多个线程就执行多个程序。<br>实际上，Java程序天生就是一个多线程程序，包含了：</p>
<ul>
<li>分发处理发送给JVM信号的线程</li>
<li>调用对象的finalize清除方法的线程</li>
<li>清除相互引用reference的线程</li>
<li>main线程，也就是用户程序的入口，main线程里面还可以拥有很多的子线程<a id="more"></a>
<h3><span id="为什么需要多线程">为什么需要多线程</span></h3>如果没有多线程，若为了使程序并发执行，那么系统需要花费大量的时间在：创建进程–&gt;撤销进程–&gt;进程上下文切换调度,在这一过程中，需要的空间开销也非常大，执行效率也非常低（如下图）；若在一个进程中执行多个线程，则上面的空间开销和时间花费将会大大较少，何乐而不为呢，多线程提高了系统的执行效率，充分利用多核CPU的计算能力，提高应用性能。<br><img src="https://img-blog.csdnimg.cn/20200411183436680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2><span id="二-并发编程带来的问题">二、并发编程带来的问题</span></h2></li>
</ul>
<h3><span id="频繁的上下文切换问题">频繁的上下文切换问题</span></h3><p>正如上图中的时间片，时间片使CPU分配给各个线程的时间，因为时间非常短，所以CPU需要不断切换线程，让我们觉得多个线程是同时执行的，时间片一般是十几毫秒；每次切换都需要保存当前线程的状态，以便进行恢复先前的状态。这个切换是非常耗性能的，过于频繁就无法发挥出多线程编程的优势了。那么该怎么解决这频繁的上下文切换的问题的，目前有大概几种解决方法，后面会详细讨论：</p>
<ol>
<li>采用无锁并发编程：JDK8以前的concurrentHashMap采用的锁分段思想，不同线程处理不同段的数据，这样在多线程环境下可以减少上下文的切换时间。</li>
<li>采用CAS算法：JDK8以后的concurrentHashMap采用的是无锁CAS算法；利用Atomic和乐观锁，可以减少一部分不必要的锁竞争带来的上下文切换。</li>
<li>尽量减少线程的使用：避免创建不需要的线程，比如任务少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态。</li>
<li>采用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。<br>因此，并发累加未必会比串行累加的速度快，这上下文切换的问题在实际中是需要解决的。</li>
</ol>
<h3><span id="线程安全问题主要问题也是我们程序开发关心的问题">线程安全问题（主要问题，也是我们程序开发关心的问题）</span></h3><p>对线程编程中最难控制的就是临界区（共享内存的地方）的线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。那么怎么解决这种问题呢，解决方法如下：</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内部占用多个资源，尽量保证一个锁只占用一个资源</li>
<li>尝试使用定时锁，如使用lock.tryLock(timeOut),当超时等待时当前线程也不会阻塞</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里（同一个事务），否则会出现解锁失败的情况<br>后面还有JMM内存模型在原子性、有序性和可见性带来的问题，比如数据脏读，内存泄漏等等问题，这是又该如何保证线程安全呢，这一方面是非常重要的，后面会详细讨论。</li>
</ul>
<h2><span id="三-并发编程的相关概念">三、并发编程的相关概念</span></h2><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步通常用来形容方法的一次调用。<br>同步方法从被调用开始，调用者就必须等待被调用的方法结束后，调用者后面的代码才能继续执行。<br>异步方法指的是，调用者不管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。</p>
<h3><span id="并发和并行">并发和并行</span></h3><p>并发是指多个任务线程交替进行。<br>并行是指真正意义上的“同时进行”。<br>实际上，如果系统只有一个CPU，而使用多线程时，那么真实环境下时不能并行执行的，只能通过切换时间片的方式交替进行，完成并发执行任务，真正的并行只能出现在拥有多个CPU系统中。</p>
<h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。<br>阻塞是指如果一个线程占用了临界区的资源，那么其他线程需要这个资源的话就必须等待资源的释放，就会导致等待的线程挂起，这种情况就叫做阻塞。<br>非阻塞刚好跟阻塞相反，它强调的是没有一个线程可以阻塞其他线程，所有的线程都会尝试的向前运行。</p>
<h3><span id="临界区">临界区</span></h3><p>临界区用来表示一种公共资源会共享数据，可以被多个线程使用，出于线程安全问题，如果一个线程占用了临界区的资源，那么其他线程就必须等待，知道临界区的资源被释放。</p>
<h3><span id="守护线程">守护线程</span></h3><p>守护线程是一种特殊的线程，是系统的服务线程，是专门为其他线程服务的，像垃圾回收线程就是守护线程，与之对应的是用户线程，用户线程作为系统的工作线程，守护线程的服务对象就是用户线程，当全部的用户线程执行任务完成之后，这个系统就没有什么需要服务的了，那么守护线程就没有对象需要守护了，那么守护线程就会结束，也就是说当一个java程序只有守护线程的时候，虚拟机就会退出了。</p>
<h2><span id="四-java中的线程thread类">四、Java中的线程Thread类</span></h2><p>参考看一下Thread类的源码注释，了解Java中的线程，有专门对Thread类的源码做分析：Java-源码分析-Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1.一个Thread类对象代表程序中的一个线程，jvm是允许多线程的</span></span><br><span class="line"><span class="comment">	 * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment">	 * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment">	 * execution running concurrently.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.每一个线程都有优先级，具有高优先级的线程优先于底优先级的线程执行，每一个线程都可以设置成一个守护线程，创建线程的时候，通过线程设置setDaemon(true)就可以设置该线程为守护线程，设置守护线程需要先于start()方法</span></span><br><span class="line"><span class="comment">	 * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment">	 * executed in preference to threads with lower priority. Each thread</span></span><br><span class="line"><span class="comment">	 * may or may not also be marked as a daemon. When code running in</span></span><br><span class="line"><span class="comment">	 * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment">	 * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment">	 * creating thread, and is a daemon thread if and only if the</span></span><br><span class="line"><span class="comment">	 * creating thread is a daemon.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.只有当一个Java程序只存在守护线程的时候，虚拟机就会退出，让虚拟机不继续执行线程的方法有：</span></span><br><span class="line"><span class="comment">		2.1调用system.exit方法.</span></span><br><span class="line"><span class="comment">		2.2所有非守护线程都处于死亡状态（只有守护线程）或线程运行抛出了异常</span></span><br><span class="line"><span class="comment">	   注意：在线程启动前可以将该线程设置为守护线程，方法是setDaemon(boolean on)</span></span><br><span class="line"><span class="comment">		     使用守护线程最好不要在方法中使用共享资源，因为守护线程随时都可能挂掉</span></span><br><span class="line"><span class="comment">		     在守护线程中产生的线程也是守护线程</span></span><br><span class="line"><span class="comment">	 * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment">	 * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment">	 * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment">	 * occurs:</span></span><br><span class="line"><span class="comment">	 * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment">	 *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment">	 *     to take place.</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment">	 *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment">	 *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 *     method.</span></span><br><span class="line"><span class="comment">	 * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	3.创建线程的方式有两种（重写Runnable接口的run()方法）：</span></span><br><span class="line"><span class="comment">		3.1创建子类并继承Thread 类，同时重写run()方法（因为Thread类实现了Runnable接口）</span></span><br><span class="line"><span class="comment">		3.2创建子类并实现Runnable接口，同时重写run()方法</span></span><br><span class="line"><span class="comment">		下面有例子：</span></span><br><span class="line"><span class="comment">	 * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment">	 * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment">	 * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment">	 * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment">	 * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment">	 *     p.start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment">	 * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment">	 * style looks like the following:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment">	 *     new Thread(p).start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	4.每个线程都有一个名称，如果没有会在创建的时候自动生成一个，除非指定为null。</span></span><br><span class="line"><span class="comment">	 * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment">	 * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment">	 * a thread is created, a new name is generated for it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment">	 * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment">	 * thrown.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="五-总结">五、总结</span></h2><p>我们需要了解并发，为什么需要并发，还必须知道并发的优缺点，同时清楚使用并发编程之后所带来的问题：频繁上下文切换问题和线程安全问题等等，后面在并发编程的时候就朝着这些问题去编程，尝试解决这些问题，让并发编程发挥出真正的作用。<br>理解Java并发的关键点在于理解它的两大核心（JMM内存模型【工作内存和主内存】和happes-before规则【八大规则】）以及三大特性：原子性、可见性、有序性</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
</search>
