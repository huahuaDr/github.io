<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-基础-笔试题10</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%9810/</url>
    <content><![CDATA[<p>1.请看如下代码<br>class Person {<br>    private int a;<br>    public int change(int m){return m;}<br>}<br>public class Teacher extends Person{<br>    public int b;<br>    public static void main(String arg[]){<br>        Person p = new Person();<br>        Teacher t = new Teacher();<br>        int i;<br>        // point x<br>    }<br>}<br>下面哪些放在// point x?行是正确的？ ()<br>A， i = m;<br>B， i = b;<br>C， i = p.a;<br>D， i = p.change(3);<br>E， i = t.b;<br>答案：D</p>
<a id="more"></a>
<p>【解析】本题考查类的声明。选项A中m没有被声明过，不能使用；选项B中虽然b是类Teacher的public成员变量，但在静态方法中，不能使用类中的非静态成员；选项C中a是类Person的private成员，在类外不能直接引用；选项D中change(intm)方法是pubtic方法，并且返回一个int型值，可以通过类的实例变量P引用并赋值给一个int型变量。<br>2.method(){?}的重载函数？（）<br>A.public void method( int m){?}<br>B.public int method(){?}<br>C.public void method2(){?}<br>D.public int method(int m，float f ){?}<br>答案：同第三题<br>3.下面那几个函数是public void method(){̷}的重载函数？（）<br>A.public void method( int m){̷}<br>B.public int method(){̷}<br>C.public void method2(){̷}<br>D.public int method(int m，float f ){̷}<br>答案：A D<br>解析：<br>重载就是方法名一样(必须的)，里面执行的内容不一样，但是呢，又出现一个问题，你写的两个或者多个方法要能让JVM(JAVA 虚拟机)认识是唯一的，所以，这里就和返回的类型无关了，因为如果返回类型不一样，其他都一样的话，那JVM是不知道到底是调用哪个方法的。所以方法名一样，入参的类型，个数，顺序（术语：方法的签名）只要有一个不同就是方法的重载了。<br>4.下面的哪些声明是合法的？（ ）<br>A.long 1 = 499<br>B.int i = 4L<br>C.float f =1.1<br>D.double d = 34.4<br>答案：AD<br>解析：<br>B.4L应该是long类型的写法，<br>C.1.1是double类型 ，float f=1.1f是正确写法<br>5.问：Java 匿名内部类在使用时如何初始化吗？<br>解析：匿名内部类无法通过构造方法初始化，所以我们只能通过构造代码块进行初始化。<br>6问：开发中使用 Java 匿名内部类有哪些注意事项（经验）？<br>答：常见的注意事项如下。<br>使用匿名内部类时必须是继承一个类或实现一个接口（二者不可兼得且只能继承一个类或者实现一个接口）。<br>匿名内部类中是不能定义构造函数的，如需初始化可以通过构造代码块处理。<br>匿名内部类中不能存在任何的静态成员变量和静态方法。<br>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>匿名内部类不能是抽象类，必须要实现继承的类或者实现接口的所有抽象方法。<br>7.问：请简单谈谈 TreeMap 与 HashMap 的区别？<br>答：TreeMap 实现了 SortMap 接口，其能够根据键排序，默认是按键的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时得到的记录是排过序的，所以在插入和删除操作上会有些性能损耗，TreeMap 的键和值都不能为空，其为非并发安全 Map，此外 TreeMap 基于红黑树实现。<br>HashMap 是最常用的 Map，其基于哈希散列表实现，主要根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度，当用 Iterator 遍历 HashMap 时得到的记录顺序是随机的，HashMap 只允键值均为空，其为非并发安全 Map。<br>所以一般情况下我们选用 HashMap，因为 HashMap 的键值对在取出时是随机的，其依据键的 hashCode 值和键的 equals 方法存取数据，具有很快的访问速度，所以在 Map 中插入、删除及索引元素时其是效率最高的实现。而 TreeMap 取出来的是排序后的键值对，所以效率会低点。<br>8.问：说说 HashSet 与 HashMap 的区别？<br>答：从实质上说 HashSet 的实现实质就是一个 Map 对象的包装，只是 Map 的 value 为 Object 固定对象，Set 只利用了 Map 的 key 而已。具体区别来说如下：<br>HashMap 实现了 Map 接口，而 HashSet 实现了 Set 接口。<br>HashMap 储存键值对，而 HashSet 仅仅存储对象。<br>HashMap 使用 put 方法将元素放入 Map 中，而 HashSet 使用 add 方法将元素放入 Set 中。<br>HashMap 中使用键对象来计算 hashcode 值，而 HashSet 使用成员对象来计算 hashcode 值。<br>9.问：简单说说什么是二叉树？什么是完全二叉树？什么是满二叉树？什么是排序二叉树？<br>二叉树是一种从上往下分叉的一种数据结构，其每个节点最多有两个孩子节点，一左一右，左边的称为左孩子，右边的称为右孩子。<br>完全二叉树是普通二叉树除最后一层外，在每一层上的结点数均达到最大值，在最后一层上只缺少右边若干结点的二叉树<br>满二叉树是普通二叉树中的每个结点恰好有两个孩子结点且所有叶子结点都在同一层的二叉树<br>若普通二叉树每个节点满足左子树所有节点值小于它的根节点值且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树<br>10.问：面向对象的三大特征是什么？请详细介绍他们各自的部分原理？<br>解答：<br>答：特征可以说有三种，继承、封装、多态，也可以说有四种，继承、封装、多态、抽象。<br>继承性是类的一种层次模型，其提供了一种明确表述共性的方法，对象的新类可以从现有的类中继承派生，类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br>封装性是把过程和数据包围起来，使得数据的访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性。<br>多态性是对象在不同时刻表现出来的多种状态，是一种编译时期状态和运行时期状态不一致的现象，多态性包括参数化多态性和包含多态性。<br>抽象性是指对一类事物的高度提炼以得到共同的共性部分，抽象不需要了解全部细节，而只是一种通用的描述约束，抽象可以是过程抽象或者数据抽象。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题9</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%989/</url>
    <content><![CDATA[<p>1.已知表达式 int m [ ] = {9，1，2，3，4，5，6}；<br>下面哪个表达式的值与数组下标量总数相等？（ ）<br>A .m.length()<br>B.m.length<br>C.m.length()+1<br>D.m.length+1<br>答案：B</p>
<a id="more"></a>
<p>解析：数组下标是从零开始的，但是数据下标的总量和数据长度相同。<br>2.下面能让线程停止执行的有（多选）( )<br>A. sleep();<br>B. stop();<br>C. notify();<br>D. synchronized();<br>E. yield();<br>F. wait();<br>G. notifyAll();<br>答案：ABDEF<br>解析：sleep：导致此线程暂停执行指定时间<br>stop: 这个方法将终止所有未结束的方法，包括run方法。<br>notify();唤醒线程<br>synchronized():对象锁<br>yield：当前正在被服务的线程可能觉得cpu的服务质量不够好，于是提前退出，这就是yield。<br>wait：当前正在被服务的线程需要睡一会，醒来后继续被服务<br>notifyAll();唤醒所有线程<br>3.下列说法正确的有（）<br>A． 在类方法中可用this来调用本类的类方法<br>B． 在类方法中调用本类的类方法时可直接调用<br>C． 在类方法中只能调用本类中的类方法<br>D． 在类方法中绝对不能调用实例方法<br>答案：B<br>解析：<br>A.在类方法中不能使用this关键字<br>C．在类方法中可以调用其它类中的类方法<br>D．在类方法中可以通过实例化对象调用实例方法<br>4.关于Java语言，下列描述正确的是（多选）<br>A. switch 不能够作用在String类型上<br>B. List， Set， Map都继承自Collection接口<br>C. Java语言支持goto语句<br>D. GC是垃圾收集器，程序员不用担心内存管理<br>答案：AD<br>解析：<br>B. Map没有继承Collection接口<br>C．java不支持goto语句<br>5.Which two demonstrate a ?has a” relationship(Choose two)?()<br>A. public interface Person { }<br>public class Employee extends Person{ }<br>B. public interface Shape { }<br>public interface Rectandle extends Shape { }<br>C. public interface Colorable { }<br>public class Shape implements Colorable<br>{ }<br>D. public class Species{ }<br>public class Animal{private Species species;}<br>E. interface Component{ }<br>class Container implements Component{<br>private Component[] children;<br>}<br>答案：D<br>解析：<br>“has a”是关联关系，关联分双向关联和单向关联，双向关联是A，B类分别持有对方的引用(有是对方的属性).<br>单向关联是一方持另一方的引用.<br>6.Given the folowing classes which of the following will compile without error?()<br>interface IFace{}<br>class CFace implements IFace{}<br>class Base{}<br>public class ObRef extends Base{<br>public static void main(String argv[]){<br>ObRef ob = new ObRef();<br>Base b = new Base();<br>Object o1 = new Object();<br>IFace o2 = new CFace();<br>}<br>}<br>A. o1=o2;<br>B. b=ob;<br>C. ob=b;<br>D. o1=b;<br>答案：B<br>解析：<br>b和ob对应的类之间没有任何关系，要想b=ob成立要么是父子关系，要么是接口实现类的关系<br>7.问：简单说说 Array 和 ArrayList 的区别？<br>答：这题相当小儿科，Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型；Array 的大小是固定的，ArrayList 的大小是动态变化的；ArrayList 提供了更多的方法和特性，譬如 addAll()、removeAll()、iterator() 等。<br>8.问：为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键，即为什么使用它们可以减少哈希碰撞？<br>答：因为 String、Integer 等包装类是 final 类型的，具有不可变性，而且已经重写了 equals() 和 hashCode() 方法。不可变性保证了计算 hashCode() 后键值的唯一性和缓存特性，不会出现放入和获取时哈希码不同的情况且读取哈希值的高效性，此外官方实现的 equals() 和 hashCode() 都是严格遵守相关规范的，不会出现错误。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题8</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%988/</url>
    <content><![CDATA[<p>1.一个以”.java”为后缀的源文件，正确的是（）<br>A. 只能包含一个类，类名必须与文件名相同<br>B. 只能包含与文件名相同的类以及其中的内部类<br>C. 只能有一个与文件名相同的类，可以包含其他类<br>D. 可以包含任意类<br>答案: C</p>
<a id="more"></a>
<p>解析：一个.java文件中，只能存在一个类是用public修饰的，并且这个类必须与类名一致，文件中其他的类不能是public权限的，但可以有很多个类。<br>2.Which is not Java primitive types?<br>A. short<br>B. Boolean<br>C. byte<br>D. float<br>答案: B<br>解析：java规定类名首字母必须大写，这里可以直观的看出来Boolean是一个引用类型，不是基本数据类型。<br>java中的基本数据类型都对应一个引用类型，如Float是float的引用类型，Integer是int的引用类型。<br>3.多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为 ()<br>A:类型定义机制;<br>B:数据封装机制;<br>C:类型定义机制和数据封装机制<br>D:上述都不对;<br>答案: A<br>解析：<br>对该数据加锁，放在同步代码块中<br>synchronize(){<br>}<br>4.下面有关List接口、Set接口和Map接口的描述，错误的是？<br>A. 他们都继承自Collection接口<br>B. List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置<br>C. Set是一种不包含重复的元素的Collection<br>D. Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value<br>答案: A<br>解析：<br>1、List接口和Set接口都继承自Collection接口，Collection接口继承Iterable接口（Iterable有一个Iterator方法），即可迭代的；Collection只能存储引用类型，并且是单个存储；<br>2、List接口存储元素特点：有序（存进去什么顺序取出来还什么顺序），可重复；Set接口存储元素特点：无序，不可重复<br>3、实现List接口主要的类包括ArrayList，LinkedList，Vector；实现Set的主要类包括：hashSet，另外还有一个TreeSet接口继承它（自动排序）<br>4、Map接口以键值对方式存储元素，键无序不可重复，Map和Collection没有任何关系<br>5.在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？<br>A. int float<br>B. int double<br>C. long float<br>D. long double<br>答案: B<br>解析：<br>Java中，如果对整数不指定类型，默认时int类型，对小数不指定类型，默认是double类型<br>如果要指定长整型，最好写为long a = 100000000L,如果要指定为单精度最好写为float a= 12.34F<br>6.下面有关webservice的描述，错误的是？<br>A. Webservice是跨平台，跨语言的远程调用技术<br>B. Webservice通信机制实质就是json数据交换<br>C. Webservice采用了soap协议（简单对象协议）进行通信<br>D. WSDL是用于描述 Web Services 以及如何对它们进行访问<br>答案: B<br>解析：Web service顾名思义是基于web的服务，它是一种跨平台，跨语言的服务。<br>我们可以这样理解它，比如说我们可以调用互联网上查询天气信息的web服务，把它嵌入到我们的B/S程序中，当用户从我们的网点看到天气信息时，会认为我们为他提供很多的服务，但其实我们什么也没做，只是简单的调用了一下服务器上的一端代码而已。Web service 可以将你的服务发布到互联网上让别人去调用，也可以调用别人发布的web service，和使用自己的代码一样。<br>它是采用XML传输格式化的数据，它的通信协议是SOAP(简单对象访问协议).<br>7.从下面四段（A，B，C，D）代码中选择出正确的代码段（）<br>A．abstract class Name {<br>    private String name;<br>public abstract boolean isStupidName(String name) {}<br>                                        }<br>B．public class Something {<br>void doSomething () {<br>private String s = ?”;<br>int l = s.length();<br>}<br>}<br>C．public class Something {<br>public static void main(String[] args) {<br>Other o = new Other();<br>new Something().addOne(o);<br>}<br>public void addOne(final Other o) {<br>o.i++;<br>}<br>}<br>class Other {<br>    public int i;<br>}<br>D．public class Something {<br>public int addOne(final int x) {<br>return ++x; }<br>}<br>答案：C<br>解析：<br>A..抽象方法不能有方法体<br>B．方法中定义的是局部变量，不能用类成员变量修饰符private<br>D．final修饰为常量，常量的值不能被改变<br>8.选择下面代码的运行结果：（）。<br>public class Test{<br>public void method()<br>{<br>for(int i = ; i &lt; 3; i++)<br>{<br>System.out.print(i);<br>}<br>System.out.print(i);<br>}<br>}<br>A．122<br>B．123<br>C．编译错误<br>D．没有任何输出<br>答案：C<br>解析：i变量的作用范围是整个for循环<br>9.Java 创建对象的方式有哪几种？<br>有4种显式地创建对象的方式：<br>1.用new语句创建对象，这是最常用的创建对象的方式。<br>2.运用反射手段，调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>3.调用对象的clone()方法。<br>4.运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.<br>10.问：抽象类（abstract class）和接口（interface）有什么区别？<br>解答：<br>1.语法层面上的区别<br>    a. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>    b. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>    c. 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>    d. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>2.设计层面上的区别<br>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。<br>那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。<br>此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系。<br>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。<br>2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。<br>什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。<br>也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。<br>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>abstract class Door {<br>public abstract void open();<br>public abstract void close();<br>}<br>或者<br>interface Door {<br>public abstract void open();<br>public abstract void close();<br>}</p>
<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：<br>1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；<br>2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。<br>从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。<br>interface Alram {<br>   void alarm();<br>}  </p>
<p>abstract class Door {<br>   void open();<br>   void close();<br>}  </p>
<p>class AlarmDoor extends Door implements Alarm {<br>   void oepn() {<br>     //….<br>  }<br>   void close() {<br>     //….<br>  }<br>   void alarm() {<br>     //….<br>  }<br>}</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题7</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%987/</url>
    <content><![CDATA[<p>1.Math.round(11.5)等于多少? Math.round(-11.5)等于多少？<br>A.11—— 11<br>B.11 ——11<br>C.12——12<br>D.12 ——11<br>答案： D</p>
<a id="more"></a>
<p>解析：<br>Math.round(11.5)==12;Math.round(-11.5)==-11;round方法返回与参数最接近的长整数，参数加1/2后求其floor<br>2.代码如下<br>1.Float pi = new Float(3.14f);<br>2. if (pi &gt; 3) {<br>3. System.out.print(“pi is bigger than 3. “);<br>4. }<br>5. else {<br>6. System.out.print(“pi is not bigger than 3. “);<br>7. }<br>8. finally {<br>9. System.out.println(“Have a nice day.”);<br>10. }<br>输出结果是（）<br>A. 编译失败。<br>B. pi is bigger than 3.<br>C. 在运行时发生n个异常。<br>D. pi is bigger than 3. Have a nice day.<br>E. pi is not bigger than 3. Have a nice day.<br>答案: A<br>解析：<br>finally不是用在这种地方，仅仅在try/catch/finally内使用。<br>3.数组有没有length()这个方法? String有没有length()这个方法<br>A. 有 没有<br>B. 有 有<br>C. 没有 没有<br>D. 没有 有<br>答： D<br>解析：<br>数组没有length()这个方法，有length的属性。String有有length()这个方法<br>4.List, Set, Map哪一个不是继承自Collection接口？<br>A. List<br>B. Set<br>C. Map<br>D. 都继承自Collection接口<br>答： C<br>解析：<br>List，Set继承自Collection接口，Map不是。<br>5.是否可以从一个static方法内部发出对非static方法的调用？<br>A. 是<br>B. 否<br>答： B<br>解析：<br>不可以,如果其中包含对象的method()；不能保证对象初始化.<br>6.下列哪个叙述是正确的()<br>A. 创建File对象可能发生异常。<br>B. BufferedRead流可以指向FileInputStream流<br>C. BufferedWrite流可以指向FileWrite流<br>D.RadomAccessFile流一旦指向文件，就会刷新该文件<br>答案：C<br>解析：<br>创建File对象不会发生异常，创建新文件的时候会发生IOException异常。<br>BufferedRead流只能指向FileRead流，它们都是以字符读取数据的。<br>RadomAccessFile流指向文件时，不刷新文件。<br>7.为了向文件hello.txt尾加数据，下列哪个是正确创建指向hello.txt的流？<br>A. try{ OutputStream out = new FileOutputStream(“hello.txt”);<br>}<br>catch(IOException e){}<br>B. try { OutputStream out = new FileOutputStream(“hello.txt”,true);<br>}<br>catch(IOException e){}<br>C.try{ OutputStream out = new FileOutputStream(“hello.txt”,false);<br>}<br>catch(IOException e){}<br>D.try{ OutputStream out = new OutputStream(“hello.txt”,true);<br>}<br>catch(IOException e){}<br>答案：B<br>FileOutputStream类是文件字节输出流，它是OutputStream类的子类，所以FileOutputStream的实例方法都是从OutputStream类继承来的，那么在这道题中需要使用上转型对象才能调用重写父类的方法，排除D。ABC在于FileOutpurStream的构造方法的不同，题目要求向文件尾加数据，A选项是具有刷新功能的构造方法，也就是会覆盖掉原来文件的数据，B选项参数为true表示不会刷新所指向的文件，而是从文件的末尾开始向文件写入数据，取值为false，输出流将刷新所指向的文件。<br>8.下面关于Java类的构造方法的说法中正确的是：（ ）<br>A. 一个类至少有一个构造方法<br>B. 构造方法的返回值类型必须是void<br>C. 构造方法的可见性修饰符必须是public<br>D. 构造方法必须显式的定义<br>正确答案: A<br>解析：<br>构造方法是一种特殊的方法：它必须具备和所在类相同的名字；没有返回值类型，甚至连void也没有；构造方法是在创建一个对象使用new操作符时调用的，作用是初始化对象。<br>造方法可以默认提供而不显式定义。<br>简单的说就是，每个类至少有一个构造方法，即使没有写出来，即可以不用显示定义。她没有返回值，连void都没有，但是也可以使用private修饰构造方法。<br>9.为什么构造方法里 this 或者 super 函数调用必须放在第一行且无法共存？<br>答：super 方法在构造函数的第一行原因是子类有可能访问了父类对象，比如在构造函数中使用父类对象的成员函数和变量，在成员初始化使用了父类，在代码块中使用了父类等，所以放在第一行可以保证在子类可以访问父类对象之前完成对父类对象的初始化。<br>this 方法在构造函数的第一行原因是为保证父类对象初始化的唯一性，因为假设类 B 是类 A 的子类，如果 this 方法可以在构造函数的任意行使用则首先程序运行到构造函数 B() 的第一行发现没有调用 this() 和 super()，就自动在第一行补齐了 super() 方法（这是 java 默认的机制），以此完成了对父类对象的初始化，然后返回子类的构造函数继续执行，当运行到构造函数 B() 的 this(参数) 调用行时, 调用 B 类对象的另一个构造方法 B(参数)，在 B(参数) 中还会对父类对象再次初始化，这就造成了对资源的浪费，也有可能造成某些意想不到的结果，所以 this 方法不能出现在构造方法除第一行以外的其他行。<br>这也就解释了为啥在构造方法里面 this 与 super 方法不能同时存在的原因。<br>10.Java 构造方法能否被重写和重载？<br>答：重写是子类方法重写父类的方法，重写的方法名不变，而类的构造方法名必须与类名一致，假设父类的构造方法如果能够被子类重写则子类类名必须与父类类名一致才行，所以 Java 的构造方法是不能被重写的。而重载是针对同一个的，所以构造方法可以被重载。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题6</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%986/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-基础-笔试题5</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%985/</url>
    <content><![CDATA[<p>1、 JAVA所定义的版本中不包括：（ ）<br>A、 JAVA2 EE<br>B、 JAVA2 Card<br>C、 JAVA2 ME<br>D、 JAVA2HE<br>E、 JAVA2 SE<br>答案：D</p>
<a id="more"></a>
<p>解析：<br>Java企业版：JEE 适用于创建服务器应用程序和服务的Java 平台企业版<br>Java标准版: JSE 适用于桌面系统的Java 平台标准版<br>JME:适用于小型设备和智能卡的Java 平台Micro版<br>Java Card技术主要是让智能卡或与智能卡相近的设备上，以具有安全防护性的方式来运行小型的Java Applet，此技术也被广泛运用在SIM卡、提款卡上。<br>2、 下列说法正确的是（ ）<br>A、 JAVA程序的main方法必须写在类里面<br>B、 JAVA程序中可以有多个main方法<br>C、 JAVA程序中类名必须与文件名一样<br>D、 JAVA程序的main方法中如果只有一条语句，可以不用{}(大括号)括起来<br>答案：A<br>解析：<br>A:main()方法必须都写在类里面，在Java中，main()方法是Java应用程序的入口方法，也就是说，程序在运行的时候，第一个执行的方法就是main()方法，这个方法和其他的方 法有很大的不同，比如方法的名字必须是main，方法必须是public static void 类型的，方法必须接收一个字符串数组的参数等等。<br>B:这个之前没用过多个main方法，自己试一下，可以用多个mian为方法名的方法，但是只能有一个publi 0static void main(String[] args){}这个方法<br>C:只有标记为public的类，名字才必须与文件名相同,public外部类必须与文件名相同，这样的类有且只有一个，public 内部类 名字不与文件名相同<br>D: JAVA程序的main方法中，不管有多少条语句都必须用{}（大括号）括起来<br>3、 变量命名规范说法正确的是（ ）<br>A、 变量由字母、下划线、数字、$符号随意组成；<br>B、 变量不能以数字作为开头；<br>C、 A和a在java中是同一个变量；<br>D、 不同类型的变量，可以起相同的名字；<br>答案：B<br>解析：<br>变量名只能是字母(a-z A-Z)，数字(0-9)，下划线(_)的组合，并且之间不能包含空格，数字不能放在变量名首位。<br>不要在同一个类的不同上下文中重用相同的变量名<br>4、 下列javaDoc注释正确的是（ ）<br>A、 /* 我爱北京天安门 /<br>B、 // 我爱北京天安门 <em>/<br>C、 /** 我爱北京天安门 <em>/<br>D、 / 我爱北京天安门 *</em>/<br>答案：C<br>解析：<br>对于Java注释我们主要了解两种：<br>// 注释一行<br>/</em> …… <em>/ 注释若干行<br>但还有第三种，文档注释：<br>/*</em>  …… <em>/ 注释若干行，并写入 javadoc 文档<br>5、 为一个boolean类型变量赋值时，可以使用( )方式<br>A、 boolean = 1;<br>B、 boolean a = (9 &gt;= 10);<br>C、 boolean a=”真”;<br>D、 boolean a = = false;<br>答案：B<br>boolean即java中的基本类型——布尔类型，值只有true和false两种。<br>分析：<br>A是对int类型的赋值方式。<br>B中（9&gt;=10）的值是false，因为有关系运算符是用来比较运算，结果只有对（true）与错（false）两种，是boolean类型，所以B正确<br>C的赋值方式根本不对，既不符合char类型，也不符合String类型<br>D中“==”是关系运算符，不能用来赋值，如果“==”改成“=”就是正确的<br>6、 以下( )不是合法的标识符<br>A、 STRING<br>B、 x3x;<br>C、 void<br>D、 de$f<br>答案：C<br>void属于java中的关键字<br>[1]Java标识符只能由数字、字母、下划线“”或“$”符号以及Unicode字符集组成<br>[2]Java标识符必须以字母、下划线“”或“$”符号以及Unicode字符集开头<br>[3]Java标识符不可以是Java关键字、保留字（const、goto）和字面量（true、false、null）<br>[4]Java标识符区分大小写，是大小写敏感的<br>7、 表达式(11+3</em>8)/4%3的值是( )<br>A、 31<br>B、 0<br>C、 1<br>D、 2<br>答案： D<br>先乘除后加减，有括号先按括号算<br>3*8=24<br>11+24=35<br>35/4=8<br>8%3=2<br>结果是2<br>8. 什么是java 序列化，如何实现java 序列化？<br>答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream 对象的writeObject(Object obj)方法就可以将参数为obj 的对象写出(即保存其状态)，要恢复的话则用输入流。<br>9、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。<br>10. java中栈和堆得区别？<br>    1. 功能不同<br>栈内存用来存储局部变量和方法调用。<br>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br>    2. 共享性不同<br>栈内存是线程私有的。<br>堆内存是所有线程共有的。<br>3.异常错误不同<br>如果栈内存或者堆内存不足都会抛出异常。<br>栈空间不足：java.lang.StackOverFlowError。<br>堆空间不足：java.lang.OutOfMemoryError。<br>4.空间大小<br>栈的空间大小远远小于堆的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题4</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%984/</url>
    <content><![CDATA[<ol>
<li>下面float的赋值语句错误的是？()<br>A:float f=3.4;<br>B:float f=3.4F;<br>C:float f=1.0;<br>D:float f=1;<br>答:AC<br>解析</li>
<li>4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;<br>float a = 1;这里的1是整形，当赋值给一个float时，存在一个隐式转换，不损失精度。<br>float a = 1f;<br>1f就是float类型的。<br>如果你这样定义<br>float f = 1.0;<br>肯定会出错。 因为1.0默认是double类型的。double范围比float大。为了不损失精度，不会自动转换。这是必须这样写<br>float f = 1.0f;</li>
<li>面向对象的特征有哪些方面?()<br>A:抽象;<br>B:继承;<br>C:多态;<br>D:封装;<br>答：面向对象的特征主要有以下几个方面：<br>1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。<br>2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。<br>3)封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。<br>4)多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
<li>java类可以作为？()<br>A:类型定义机制;<br>B:数据封装机制;<br>C:类型定义机制和数据封装机制<br>D:上述都不对;<br>答：C<br>解析：类即可以作为类型定义机制也可以作为数据封装机制。</li>
<li>以下哪个约束符可用于定义成员常量？（）<br>A、 static<br>B、final<br>C、abstract<br>D、No modifier can be used<br>答案 B<br>解析：static 静态成员变量(在定义这个变量的类的实例中,这个变量是唯一的,即多个实例间这个变量为共享的)<br>final 成员常量(必须在定义时或在构造方法中赋初值)<br>final static 静态成员常量,必须在定义这个常量时给定其初始化值</li>
<li>在使用interface声明一个接口时，只可以使用（）修饰符修饰该接口<br>A private<br>B protected<br>C private protected<br>D public<br>答案：D<br>解析：接口必须要具体类实现才有意义，所以必须是public。</li>
<li>java语言使用的字符码集是()<br>A ASCII<br>B BCD<br>C DCB<br>D Unicode<br>答案：D<br>解析：Java语言使用的是Unicode字符集，ASCII是国际上使用最广泛的字符编码</li>
<li>下列关于继承的哪项叙述是正确的？<br>A 在java中允许多继承<br>B 在java中一个类只能实现一个接口<br>C 在java中一个类不能同时继承一个类和实现一个接口<br>D java的单一继承使代码更可靠<br>答案：D<br>解析：<br>A：Java只能单继承。所以A选项错误<br>B：Java中一个类可以实现多个接口，所以B错误<br>C：Java中一个类只能实现继承一个父类但是可以同时实现多个接口，所以C错误<br>D：Java的单一继承使代码更可靠，是正确的。</li>
<li>(不定项选择题)不能用来修饰interface的有（ ）<br>A private<br>B public<br>C protected<br>D static<br>答案：ACD<br>解析：<br>A,C,D都不能用来修饰interface。<br>就访问来说，可以用public,默认修饰符，而不能用private，因为接口本身就是为了让别的类或接口使用的，用private就没有了意义。<br>protected也是不可以的，ptotected的访问权限是包内对象以及包外继承该类的包外对象，其实和public意义也就一样了，也就没必要选择protected。<br>static是用来修饰变量或者方法的，而不修饰类。（在接口中 static只能修饰变量不能修饰方法）<br>（final同样不能修饰接口）。</li>
<li>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？<br>这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。</li>
<li>在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？<br>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题3</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%983/</url>
    <content><![CDATA[<ol>
<li>以下哪些定义的变量是正确的（）<br>A int 1abc;<br>B char abc1;<br>C long #abc;<br>D boolean $abc;<br>E：String_123456asdfghjklqwertyuiopzmnbvasdf12345;<br>答案 B D<br>解析：<br>因为java中变量名必须是一个以字母开头并由字母或者数字构成的序列。<br>字母包括 A-Z,a-z,_,$或在某种语言中表示的字母的任何Unicode字符。变量名中所有的字符都是有意义的，并且大小写敏感，变量名基本上没有限制.</li>
<li>代码如下<br>public class Test {<br> public final String a;<pre><code>public Test() {
    a = &quot;10&quot;;
}</code></pre> public void setA1(){<pre><code>       a = &quot;20&quot;;
}</code></pre>  public static void main(String[] args) {<pre><code>    Test t = new Test();
    t.setA1();
    System.out.println(t.a);
}</code></pre>}<br>t.a的值为（）<br>A “10”<br>B “20”<br>C “”<br>D 以上都不对，并且编译错误<br>答案 D<br>解析 ：<br>因为a被final（只能在初始化时赋值一次，一旦被赋值后，就不能再更改了，习惯上常量名使用全大写）修饰了，所以在setA1中再次赋值了，直接导致编译错误。</li>
<li>代码如下<br>double a = 15.0;<br>  int b=2;<br>   system.out.println(a+b);<br>打印出来的数值类型为（）<br>A int<br>B float<br>C String<br>D double<br>答案 D<br>解析：<br>如果两个操作数中有一个是double类型，另一个操作数就会自动转换为double类型。</li>
<li>以private修饰的元素的作用域的是（）<br>A. 当前类<br>B. 同一个package 内<br>C. 子孙类中<br>D. 其他的package 内<br>答案 A<br>解析：<br>共有四个访问修饰符public protected friendly private<br>public 的作用域有当前类，同一个package，子孙类和其他的package<br>protected的作用域有当前类，同一个package，和子孙类<br>friendly的作用域有当前类和同一个package<br>private 的作用域只有当前类</li>
<li>String s =new String (“xyz”);这句一共创建了几个String Object？<br>A. 1<br>B. 2<br>C. 3<br>D. 4<br>答案:B<br>解析：<br>一共创建了两个对象，一个是”xyz”，为缓冲区对象。另一个是new出来的String 对象。这两个对象的值相同，但不是同一个对象。</li>
<li>String 是最基本的数据类型吗？()<br>A：是<br>B：不是<br>答案：B<br>解析<br>String类并不是基本数据类，而是一个类（class），是C++、java等编程语言中的字符串。<br>String类是不可变的，对String类的任何改变，都是返回一个新的String类对象。 String 对象是 System.Char 对象的有序集合，用于表示字符串。String 对象的值是该有序集合的内容，并且该值是不可变的。</li>
<li>选择下面代码的运行结果：（）。<br>public class Test{<br> public void method()<br> {<pre><code>for(int i = ; i &lt; 5; i++)</code></pre> {<pre><code>System.out.print(i);</code></pre> }<pre><code>System.out.print(i);</code></pre> }<br>}<br>A．122<br>B．123<br>C．编译错误<br>D．没有任何输出<br>答案：C<br>解析：<br>本试题属于 本身该试题就有严重的语法程序错误，并且没有主方法。</li>
<li>下面程序的运行结果是（）<br>String str1 = “banalan”;<br>String str2 = “bana” + new String(“lan”);<br>System.err.println(str1 == str2);<br>A：true<br>B：false<br>C：不确定<br>答案：B<br>解析<br>对于字符串，==比较引用对象的内存地址，equals比较的是字符串的内容<br>String str1 = “banalan”; //一个对象<br>String str2 = “bana” + new String(“lan”); //new了一个对象，总的就是2个对象 System.err.println(str1 == str2); // ==是比较引用，两个对象的地址能一样么？只有重写equals比较内容（值）才能为TRUE</li>
<li>String能被继承吗？为什么？<br>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str=”a”;其实和String str=new String(“a”)还是有差异的。<br>前者默认调用的是String.valueOf来返回String实例对象，至于调用哪个则取决于你的赋值，比如String num=1,调用的是<br>public static String valueOf(int i) {<br>return Integer.toString(i);<br>}<br>后者则是调用如下部分：<br>public String(String original) {<br>this.value = original.value;<br>this.hash = original.hash;<br>}<br>最后我们的变量都存储在一个char数组中<br>private final char value[];</li>
<li>Java I/O中字符流和字节流的区别 ?<br>字节流是传递0<del>255的整数而Java中有一些(如unicode代码)不能使用字符流，是特殊的字节流。<br>字节流：Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了一组基本的输入字节流和输出字节流。InputStream类与OutputStream类均为抽象类，我们在实际使用中通常使用Java类库中提供的它们的一系列子类。下面我们以InputStream类为例，来介绍下Java中的字节流。<br>字符流：Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常用来处理文本数据。所谓Unicode码元，也就是一个Unicode代码单元，范围是0×0000</del>0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题2</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%982/</url>
    <content><![CDATA[<ol>
<li>对于以下，有int x = 5, y =6, z;<br>z = ++x + y++;<br>z的结果下面正确是是（）<br>A：10<br>B:8<br>C:11<br>D:12<br>答案：D<br>解析：</li>
</ol>
<p>++x ，y++ 将 x = 5, y =6带入里面 得到 6 ，6 所以结果为12</p>
<a id="more"></a>
<ol start="2">
<li>代码如下<br>int a=5;<br>int b=++a;<br>int c=a+(++b)<br>C的正确结果是（）<br>A：11<br>B：13<br>C：10<br>D：12<br>答案 B<br>解析：<br>a=5; b=++a; // 相当于a=a+1;b=a; 结果是a=6，b=6<br>int c=a+(++b) //先计算 ++b =6+1=7; c=6+7=13;<br>这个主要是考察 自增的运算， ++在变量前面就是先让变量+1 在运算；++在变量的后面就是 先运算。</li>
<li>下列运算符合法的是（）<br>A．&amp;&amp; B．&lt;&gt; C．if D．:=<br>答案：A<br>解析：<br>Java 运算符可以分成以下<br>算术运算符，关系运算符，位运算符，逻辑运算符，赋值运算，其他运算符<br>经常提到的四大类为算数运算符、关系运算符、逻辑运算符、位运算符。<br>算数运算符(9)：+ – * / % ++ —<br>关系运算符(6)：== != &gt; &gt;= &lt; &lt;=<br>逻辑运算符(6)：&amp;&amp; || ! ^ &amp; |<br>位运算符(7)：&amp; | ~ ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt;<br>&amp;&amp;是在编程中使用的一种符号。是逻辑（条件）与。<br>java 中没有&lt;&gt; := 这种运算符，if else不算运算符</li>
<li>下列哪种说法是正确的（ ）<br>A． 实例方法可直接调用超类的实例方法<br>B． 实例方法可直接调用超类的类方法<br>C． 实例方法可直接调用其他类的实例方法<br>D． 实例方法可直接调用本类的类方法<br>答案 D<br>解析:<br>AC选项 如果方法是private 则不可以;<br>B选项类父类的类方法是属于父类本身的;<br>D选项虽然类方法可以类名.类方法来调用 但是new 该类 的实例方法去调也不不会报错 ;<br>记住一句话：实例方法只能直接调用本类的方法，其他类的方法得需要引用调用</li>
<li>计算2 &lt;&lt; 3，下面正确的是（）<br>A：6<br>B:54<br>C:8<br>D:16<br>答案D<br>解析：<br>2&lt;&lt;3； 表示 2向左移 3位：2 * 2^3(2的3次方) = 2 * 8；<br>因为一个数左移 n位，就相当于 2的 n次方，那么一个数乘以 8只要将其左移 3位即可，而为运算符的效率最高，所以 2乘以 8等于几的最有效方法是 2&lt;&lt;3。</li>
<li>提供Java存取数据库能力的包是（）<br>A．java.sql<br>B．java.awt<br>C．java.lang<br>D．java.swing<br>答案：A<br>解析<br>A存储在数据源（通常是一个关系数据库）中的数据的 API<br>B java.awt是一个软件包，包含用于创建用户界面和绘制图形图像的所有分类<br>C是提供利用 Java 编程语言进行程序设计的基础类<br>D Swing是一个用于开发Java应用程序用户界面的开发工具包</li>
<li>选择下面代码的运行结果：（）。<br>public class Test{<br> public void method()<br> {<pre><code>for(int i = ; i &lt; 5; i++)</code></pre> {<pre><code>System.out.print(i);</code></pre> }<pre><code>System.out.print(i);</code></pre> }<br>}<br>A．122<br>B．123<br>C．编译错误<br>D．没有任何输出<br>答案：C<br>解析：<br>本试题属于 本身该试题就有严重的语法程序错误，并且没有主方法。</li>
<li>下面程序的运行结果是（）<br>String str1 = “banalan”;<br>String str2 = “bana” + new String(“lan”);<br>System.err.println(str1 == str2);<br>A：true<br>B：false<br>C：不确定<br>答案：B<br>解析<br>对于字符串，==比较引用对象的内存地址，equals比较的是字符串的内容<br>String str1 = “banalan”; //一个对象<br>String str2 = “bana” + new String(“lan”); //new了一个对象，总的就是2个对象 System.err.println(str1 == str2); // ==是比较引用，两个对象的地址能一样么？只有重写equals比较内容（值）才能为TRUE</li>
<li>String能被继承吗？为什么？<br>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str=”a”;其实和String str=new String(“a”)还是有差异的。<br>前者默认调用的是String.valueOf来返回String实例对象，至于调用哪个则取决于你的赋值，比如String num=1,调用的是<br>public static String valueOf(int i) {<br>return Integer.toString(i);<br>}<br>后者则是调用如下部分：<br>public String(String original) {<br>this.value = original.value;<br>this.hash = original.hash;<br>}<br>最后我们的变量都存储在一个char数组中<br>private final char value[];</li>
<li>String, Stringbuffer, StringBuilder 的区别?<br>String 字符串常量(final修饰，不可被继承)，String是常量，当创建之后即不能更改。(可以通过StringBuffer和StringBuilder创建String对象(常用的两个字符串操作类)。)<br>StringBuffer 字符串变量（线程安全）,其也是final类别的，不允许被继承，其中的绝大多数方法都进行了同步处理，包括常用的Append方法也做了同步处理(synchronized修饰)。其自jdk1.0起就已经出现。其toString方法会进行对象缓存，以减少元素复制开销。<br>public synchronized String toString() {<br>if (toStringCache == null) {<br>toStringCache = Arrays.copyOfRange(value, 0, count);<br>}<br>return new String(toStringCache, true);<br>}<br>StringBuilder 字符串变量（非线程安全）其自jdk1.5起开始出现。与StringBuffer一样都继承和实现了同样的接口和类，方法除了没使用synch修饰以外基本一致，不同之处在于最后toString的时候，会直接返回一个新对象。<br>public String toString() {<br>// Create a copy, don’t share the array<br>return new String(value, 0, count);<br>}</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-基础-笔试题1</title>
    <url>/2020/04/14/Java-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AF%95%E9%A2%981/</url>
    <content><![CDATA[<ol>
<li>Byte类型可以存储多少个字节和取值范围？（）<br>A 1个字节 ， -128 ~ 127<br>B 2个字节， 32 768 – 32 767<br>C 4字节 -2 147 483 648 – 2 147 483 647 (正好超过 20 亿)<br>D 8个字节 -9 223 372 036 854 775 808 – 9 223 372 036 854 775 807<br>答案：A<br>解析：<br>byte是一个字节保存的，有8个位，即8个0、1。<br>8位的第一个位是符号位，<br>也就是说0000 0001代表的是数字1<br>1000 0000代表的就是-1<br>所以正数最大位0111 1111，也就是数字127<br>负数最大为1111 1111，也就是数字-128<br>所以Java中的一个byte是1个字节，其范围是-128~127<a id="more"></a></li>
<li>short类型可以存储多少个字节和取值范围？（）<br>A 1个字节 ， -128 ~ 127<br>B 2个字节， 32 768 – 32 767<br>C 4字节 -2 147 483 648 – 2 147 483 647 (正好超过 20 亿)<br>D 8个字节 -9 223 372 036 854 775 808 – 9 223 372 036 854 775 807<br>答案 B<br>解析：<br>与byte类似道理，16位,（-32768~32767） (-2的15次方到2的15次方-1)需要2个字节存储所以答案为B</li>
<li>long类型可以存储多少个字节和取值范围？（）<br>A 1个字节 ， -128 ~ 127<br>B 2个字节， 32 768 – 32 767<br>C 4字节 -2 147 483 648 – 2 147 483 647 (正好超过 20 亿)<br>D 8个字节 -9 223 372 036 854 775 808 – 9223 372 036 854 775 807<br>答案 D<br>解析：<br>与byte类似道理,64位，（-9223372036854774808~9223372036854774807）（-2的63次方到2的63次方-1）需要4个字节存储。</li>
<li>下面能通过编译运行出Hello World的是()<br>A:public class Hello {<br>public static void main(String[]args) {<br>System.out.println(“Hello World”);<br>  }<br>}<br>B:.public class Hello {<br>public static void main(String[] args) {<br>system.out.println(“Hello World”);<br>  }<br>}<br>C:public class Hello {<br>public static void main(String[] args) {<br>System.out.println(“Hello World”);<br>  }<br>}<br>D:public class Hello {<br>public static  main(String[] args) {<br>System.out.println(“Hello World”);<br>  }<br>}<br>答案：A C<br>解析：<br>这个题主要考察的是对基础知识的掌握程度，还有你得慧眼。<br>这道题错误率100%</li>
<li>java源文件和编译后得文件拓展名分别为（）<br>A:.class和.java B: .java 和.class<br>C:.class和.class D:.java和.javac<br>答案：B<br>解析：<br>源文件就是程序员们所编写出来的java代码<br>类文件则是通过java虚拟机编译后没有语法错误生成的.class文件</li>
<li>如下哪些不是java的关键字？（ ）<br>A.const<br>B.NULL<br>C.false<br>D.this<br>E.native<br>答案：BC<br>解析：<br>虽然null false 还有true不是java的关键字，但是都有特殊用途，不建议作为标识符。</li>
<li>下面哪个表达式的值与数组下标量总数相等？（ ）<br>A .m.length()<br>B.m.length<br>C.m.length()+1<br>D.m.length+1<br>答案：B<br>数组下标是从零开始的，但是数据下标的总量和数据长度相同。</li>
<li>如下代码<br>public class Sortof {<pre><code>public static void main(String[] args) {
    ArrayList&lt;Integer&gt; a=new ArrayList&lt;&gt;();
     a.add(1);a.add(5);a.add(3);
    Collections.sort(a);
    a.add(2);
    Collections.reverse(a);
    System.out.println(a);
}</code></pre>}<br>下面哪一个是正确的（）<br>A[1,2,3,5)]<br>B.[2 ,1,3,5]<br>C.[2,5,3,1]<br>D [5, 3,2, 1]<br>E [1,3 ,5,2)<br>F Compilation fails.<br>G An exception is thrown at runtime<br>答案：C<br>解析：<br>Collections.sort(a);默认是升序排列，所以变成了1，3，5然后在加上2，就会变成1，3，5，2，<br>而reverse方法是反转集合中的所有元素，所以反转之后就成了2，5，3，1.</li>
<li>如下代码<br>public class Alpha{<pre><code>public void foo(){
       System.out.print(&quot;Afoo &quot;);
  }</code></pre>｝<br>   public class Beta extends Alpha{<pre><code>public void foo() {
       System.out.print(&quot;Bfoo&quot; );
 }</code></pre>  public static void main(String[] args){<pre><code>     Alpha a = new Beta();
     Beta b=(Beta)a;
     a.foo();
     b.foo();
}</code></pre>｝<br>下面哪一个是正确的（）<br>A.Afoo Afoo<br>B. Afoo Bfoo<br>C. Bfoo Afoo<br>D. Bfoo Bfoo<br>E. Compilation fails<br>F.An exception is thrown at runtime<br>答案:D<br>考察多态性，编译器认为a是Alpha 类型，b 是Beta 类型，但是虚拟机知道a 和b 的真实类型是Beta，所以调用Beta 类的函数。如果还是不了解，建议大家看看面向对象的多态。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-web.xml配置文件</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-web-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-web.xml.png" alt="思维导图"></p>
<a id="more"></a>
<h2><span id="一-基本配置">一、基本配置</span></h2><pre><code>Web.xml主要是用来加载servlet实例的。默认的servlet实例：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">servlets</span>.<span class="title">DefaultServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">debug</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;0&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">listings</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应servlet实例处理的url请求映射，servlet&gt;和servlet-mapping&gt;标签是成对出现的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>标签元素说明：<br>    1. servlet-name&gt;:设置servlet实例的名字。<br>    2. servlet-class&gt;:servlet实例对应的类。<br>    3. init-param&gt;:表示初始化该servlet实例时的一些初始化参数，里面含有param-name&gt;标签标识参数名，<param-value>标签标识参数值。<br>        a. debug：表示调试等级，0表示提供最少的信息，9表示提供最多的信息<br>        b. listings：表示是否列出web路径下的所有页面，false表示不显示目录结构<br>    4. load-on-startup&gt;：表示在servlet容器标记启动时是否加载这个servlet实例并调用其init()方法，它的值必须是一个整数，表示servlet实例被载入的顺序，当值为0或者大于0时表示在容器启动的时候就加载并初始化这个servlet，当值小于0或者没有指定时，表示该servlet被选择时，容器才会去加载；正值的数越小，该servlet的优先级越高，容器启动时就先加载，当值相同时，容器会自己选择顺序加载。<br>二、init-param&gt;元素详解<br>    再看一个专门处理jsp的servlet配置：</param-value></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">servlet</span>.<span class="title">JspServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">fork</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">xpoweredBy</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;3&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对用的url映射路径：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>其中主要说一下init-param&gt;元素里面的参数：</p>
<p><img src="https://img-blog.csdnimg.cn/20200413222911821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="三-其他配置标签">三、其他配置标签</span></h2><ol>
<li>设置session会话超时时间</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Mime-mapping标签</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;mime-mapping&gt;</span><br><span class="line">	        &lt;extension&gt;zip&lt;/extension&gt;</span><br><span class="line">	        &lt;mime-type&gt;application/zip&lt;/mime-type&gt;</span><br><span class="line">	    &lt;/mime-mapping&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;mime-mapping&gt;</span><br><span class="line">	     &lt;extension&gt;htm&lt;/extension&gt; </span><br><span class="line">	      &lt;mime-type&gt;text/html;charset=gb2312&lt;/mime-type&gt;</span><br><span class="line">	 &lt;/mime-mapping&gt;</span><br><span class="line">	</span><br><span class="line">	 &lt;mime-mapping&gt;</span><br><span class="line">	      &lt;extension&gt;html&lt;/extension&gt; </span><br><span class="line">	      &lt;mime-type&gt;text/html;charset=gb2312&lt;/mime-type&gt; </span><br><span class="line">	 &lt;/mime-mapping&gt;</span><br></pre></td></tr></table></figure>


<p>mime-mapping是web.xml中的一个节点，用来指定对应的格式的浏览器处理方式，另外也可以用来配置静态页面的打开编码。</p>
<p>常见的MIME类型:<br>    超文本标记语言文本 .htm,.html text/html<br>    普通文本 .txt text/plain<br>    RTF文本 .rtf application/rtf<br>    GIF图形 .gif image/gif<br>    JPEG图形 .ipeg,.jpg image/jpeg<br>    au声音文件 .au audio/basic<br>    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>    MPEG文件 .mpg,.mpeg video/mpeg<br>    AVI文件 .avi video/x-msvideo<br>    GZIP文件 .gz application/x-gzip<br>    TAR文件 .tar application/x-tar</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-server.xml配置文件</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-server-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-server.xml.png" alt="思维导图"></p>
<h2><span id="一-目前tomcat8的serverxml配置">一、目前tomcat8的server.xml配置：</span></h2><p>该配置文件描述了如何启动Tomcat 服务以及怎么处理请求服务。</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> SSLEngine=<span class="string">"on"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;Resource name=<span class="string">"UserDatabase"</span> auth=<span class="string">"Container"</span></span><br><span class="line">              type=<span class="string">"org.apache.catalina.UserDatabase"</span></span><br><span class="line">              description=<span class="string">"User database that can be updated and saved"</span></span><br><span class="line">              factory=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="line">              pathname=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span><br><span class="line">  &lt;/GlobalNamingResources&gt;</span><br><span class="line">  &lt;Service name=<span class="string">"Catalina"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;Connector port=<span class="string">"8009"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;Realm className=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br><span class="line">        &lt;Realm className=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span><br><span class="line">               resourceName=<span class="string">"UserDatabase"</span>/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span></span><br><span class="line">            unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">	&lt;Logger&gt;</span><br><span class="line">	&lt;Context&gt;</span><br><span class="line">        &lt;Valve className=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> directory=<span class="string">"logs"</span></span><br><span class="line">               prefix=<span class="string">"localhost_access_log"</span> suffix=<span class="string">".txt"</span></span><br><span class="line">               pattern=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="二-根据上面的配置文件tomcat-server的结构图">二、根据上面的配置文件，tomcat server的结构图</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413215547844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id><img src="https://img-blog.csdnimg.cn/20200413215640150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="三、配置文件的各个标签及属性说明"></span></h2><h2><span id="四-serverxml标签元素详解">四、server.xml标签元素详解</span></h2><h3><span id="server标签元素">Server标签元素</span></h3><p>server标签代表着这个容器，但自身并不是一个”container”容器，不能在里面定义其他像Loggers等组件，它是tomcat实例的顶层元素，由org.apache.catalina.Server接口定义，其使用的默认className是：org.apache.catalina.core.StandarServer类。它包含<service>元素，并且它不能作为任何元素的子元素。<br>    一个server是一个提供完整的JVM的独立组件，它可以包含一个或者多个Service实例。server服务器再指定的端口上监听shutdown命令。</service></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面表示：启动server,在端口8005处等待关闭命令，如果接收到“SHUTDOWN”字符串则关闭服务器。<br>测试一下：<br>我们先启动tomcat服务器：<br>    <img src="https://img-blog.csdnimg.cn/20200413222005468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在cmd命令控制台上连接8005端口：telnet localhost 8005<br>然后输入：SHUTDOWN 按回车就会发现启动的tomcat被关闭了。</p>
<h3><span id="service标签元素">Service标签元素</span></h3><p>该元素由org.apache.catalina.Service接口定义，默认实现类是org.apache.catalina.StandardService类；它包含一个<engine>元素以及多个connector元素，这些connector元素共享同一个Engine元素。<br>        Service name=”Catalina”:表示处理所有直接由tomcat服务器接收到的web客户请求。<br>        Service name=”Apache”:表示处理所有由Apache服务器转发过来的web客户请求。</engine></p>
<h3><span id="connector标签元素">Connector标签元素</span></h3><p>由connector接口定义，该元素代表与客户端实际交互的组件，它负责接受客户端请求，以及向客户端返回响应结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 一个“Connector”（连接器）代表一个请求被接收和应答所需要的端点。每个连</span><br><span class="line">	        接器通过相关的“Container”（容器）处理请求。</span><br><span class="line">	         </span><br><span class="line">	         默认情况下，一个非SSL的HTTP/<span class="number">1.1</span>的连接器被绑定在端口<span class="number">8080</span>。你也可以通过</span><br><span class="line">	         根据后面的使用说明并取消第二个连接器入口的注释，在端口<span class="number">8443</span>上建立一个</span><br><span class="line">	         SSL HTTP/<span class="number">1.1</span>的连接器。开放SSL支持需要下面几步（参见Tomcat <span class="number">5</span>文档中怎样</span><br><span class="line">	         配置SSL的说明以取得更多的详细信息）：</span><br><span class="line">	         * 如果你的JDK是<span class="number">1.3</span>或<span class="number">1.3</span>以前的版本，下载安装JSSE <span class="number">1.0</span><span class="number">.2</span>或以后版本，并放</span><br><span class="line">	           置JAR文件到“$JAVA_HOME/jre/lib/ext”目录下。</span><br><span class="line">	         * 带一个“changeit”的口令值执行：</span><br><span class="line">	             %JAVA_HOME%\bin\keytool -genkey -alias tomcat -<span class="function">keyalg <span class="title">RSA</span> <span class="params">(Windows)</span></span></span><br><span class="line"><span class="function">	             $JAVA_HOME/bin/keytool -genkey -alias tomcat -keyalg <span class="title">RSA</span> <span class="params">(UNIX)</span></span></span><br><span class="line"><span class="function">	           来生成它自己的证书私钥。</span></span><br><span class="line"><span class="function">	           </span></span><br><span class="line"><span class="function">	         默认情况下，当一个web应用程序调用请求时，DNS查询是可行的。这将对性能造</span></span><br><span class="line"><span class="function">	         成一些不利的影响，因此，你可以将“enableLookups”设置为“<span class="keyword">false</span>”来关闭DNS</span></span><br><span class="line"><span class="function">	         查询。当DNS查询被关闭时，request.<span class="title">getRemoteHost</span><span class="params">()</span>将返回包含远程客户IP地</span></span><br><span class="line"><span class="function">	         址的字符串。</span></span><br><span class="line"><span class="function">	  --&gt;</span></span><br><span class="line"><span class="function">	&lt;!-- Coyote HTTP/1.1 Connector</span></span><br></pre></td></tr></table></figure>
<p>className : 该Connector的实现类是org.apache.coyote.tomcat4.CoyoteConnector<br>port : 在端口号8080处侦听来自客户browser的HTTP1.1请求.如果把8080改成80,则只要输入<a href="http://localhost/即可" target="_blank" rel="noopener">http://localhost/即可</a><br> protocol:设定Http协议,默认值为HTTP/1.1<br>    minSpareThreads: 该Connector先创建5个线程等待客户请求，每个请求由一个线程负责</p>
<p>maxSpareThread:设定在监听端口的线程的最大数目,这个值也决定了服务器可以同时响应客户请求的最大数目.默认值为200</p>
<p> acceptCount : 当现有线程已经达到最大数75时，为客户请求排队.当队列中请求数超过100时，后来的请求返回Connection refused错误</p>
<p>redirectport : 当客户请求是https时，把该请求转发到端口8443去<br> enableLookups:如果设为true,表示支持域名解析,可以把IP地址解析为主机名.WEB应用中调用request.getRemoteHost方法返回客户机主机名.默认值为true<br>connectionTimeout:定义建立客户连接超时的时间.如果为-1,表示不限制建立客户连接的时间<br>    allowTrace：是否允许HTTP的TRACE方法，默认为false<br>emptySessionPath：如果设置为true，用户的所有路径都将设置为/，默认为false。<br>    enableLookups：调用request、getRemoteHost()执行DNS查询，以返回远程主机的主机名，如果设置为false，则直接返回IP地址。<br>    maxPostSize：指定POST方式请求的最大量，没有指定默认为2097152。<br>    protocol：值必须为HTTP1.1，如果使用AJP处理器，该值必须为AJP/1.3<br>    proxyName：如这个连接器正在一个代理配置中被使用，指定这个属性，在request.getServerName()时返回<br>    redirectPort：如连接器不支持SSL请求，如收到SSL请求，Catalina容器将会自动重定向指定的端口号，让其进行处理。<br>    scheme：设置协议的名字，在request.getScheme()时返回，SSL连接器设为”https”，默认为”http”<br>    secure：在SSL连接器可将其设置为true，默认为false<br>    URIEncoding：用于解码URL的字符编码，没有指定默认值为ISO-8859-1<br>    useBodyEncodingForURI：主要用于Tomcat4.1.x中，指示是否使用在contentType中指定的编码来取代URIEncoding，用于解码URI查询参数，默认为false<br>    xpoweredBy：为true时，Tomcat使用规范建议的报头表明支持Servlet的规范版本，默认为false<br>    acceptCount：当所有的可能处理的线程都正在使用时，在队列中排队请求的最大数目。当队列已满，任何接收到的请求都会被拒绝，默认值为10<br>    bufferSize：设由连接器创建输入流缓冲区的大小，以字节为单位。默认情况下，缓存区大的大小为2048字节<br>    compressableMimeType：MIME的列表，默认以逗号分隔。默认值是text/html，text/xml，text/plain<br>    compression：指定是否对响应的数据进行压缩。off：表示禁止压缩、on：表示允许压缩（文本将被压缩）、force：表示所有情况下都进行压缩，默认值为off<br>    connectionTimeout：设置连接的超时值，以毫秒为单位。默认值为60000=60秒<br>    disableUploadTimeOut：允许Servlet容器，正在执行使用一个较长的连接超时值，以使Servlet有较长的时间来完成它的执行，默认值为false<br>    maxHttpHeaderSize：HTTP请求和响应头的最大量，以字节为单位，默认值为4096字节<br>    maxKeepAliveRequest：服务器关闭之前，客户端发送的流水线最大数目。默认值为100<br>    maxSpareThreads：允许存在空闲线程的最大数目，默认值为50<br>    minSpareThreads：设当连接器第一次启协创建线程的数目，确保至少有这么多的空闲线程可用。默认值为4<br>    port：服务端套接字监听的TCP端口号，默认值为8080（必须）<br>    socketBuffer：设Socket输出缓冲区的大小（以字节为单位），-1表示禁止缓冲，默认值为9000字节<br>    toNoDelay：为true时，可以提高性能。默认值为true<br>    threadPriority：设JVM中请求处理线程优先级。默认值为NORMAL-PRIORITY<br>    例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Connector </span><br><span class="line">port=<span class="string">"8080"</span> maxHttpHeaderSize=<span class="string">"8192"</span> maxThreads=<span class="string">"150"</span> minSpareThreads=<span class="string">"25"</span> maxSpareThreads=<span class="string">"75"</span> enableLookups=<span class="string">"false"</span></span><br><span class="line">redirectPort=<span class="string">"8443"</span> acceptCount=<span class="string">"100"</span> connectionTimeout=<span class="string">"20000"</span> disableUploadTimeout=<span class="string">"true"</span> /&gt; </span><br><span class="line">AJP连接器：</span><br><span class="line">用于将Apache与Tomcat集成在一起，当Apache接收到动态内容请求时，通过在配置中指定的端口号将请求发送给在此端口号上监听的AJP连接器组件。</span><br><span class="line">属性：</span><br><span class="line">backlog：当所有可能的请求处理线程都在使用时，队列中排队的请求最大数目。默认为<span class="number">10</span>，当队列已满，任何请求都将被拒绝</span><br><span class="line">maxSpareThread：允许存在空闲线程的最大数目，默认值为<span class="number">50</span></span><br><span class="line">maxThread：最大线程数，默认值为<span class="number">200</span></span><br><span class="line">minSpareThreads：设当连接器第一次启动时创建线程的数目，确保至少有这么多的空闲线程可用，默认值为<span class="number">4</span></span><br><span class="line">port：服务端套接字的TCP端口号，默认值为<span class="number">8089</span>（必须）</span><br><span class="line">topNoDelay：为<span class="keyword">true</span>时，可以提高性能，默认值为<span class="keyword">true</span></span><br><span class="line">soTimeout：超时值</span><br><span class="line">例：</span><br><span class="line">&lt;!—Define an AJP1<span class="number">.3</span> Connector on port <span class="number">8089</span>--&gt;</span><br><span class="line">&lt;Connector port=”<span class="number">8089</span>” enableLookups=”<span class="keyword">false</span>” redirectPort=”<span class="number">8443</span>” protocol=”AJP/<span class="number">1.3</span>” /&gt;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;Connector port=<span class="string">"8080"</span> maxThread=<span class="string">"50"</span> minSpareThreads=<span class="string">"25"</span> maxSpareThread=<span class="string">"75"</span> enableLookups=<span class="string">"false"</span> redirectPort=<span class="string">"8443"</span> acceptCount=<span class="string">"100"</span> debug=<span class="string">"0"</span> connectionTimeout=<span class="string">"20000"</span> disableUploadTimeout=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;Connection port=<span class="string">"8009"</span> enableLookups=<span class="string">"false"</span> redirectPort=<span class="string">"8443"</span> debug=<span class="string">"0"</span> protocol=<span class="string">"AJP/1.3"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>第一个Connector元素定义了一个HTTP Connector,它通过8080端口接收HTTP请求;第二个Connector元素定义了一个JD Connector,它通过8009端口接收由其它服务器转发过来的请求.</p>
<h3><span id="engine标签元素">Engine标签元素</span></h3><p>每个service元素只能有一个Engine元素，处理同一个Service中所有Connector元素接收到的客户请求，由Engine接口定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Engine用来处理Connector收到的Http请求</span><br><span class="line"></span><br><span class="line">         它将匹配请求和自己的虚拟主机，并把请求转交给对应的Host来处理</span><br><span class="line"></span><br><span class="line">         默认虚拟主机是localhost</span><br><span class="line"></span><br><span class="line">         --&gt;</span><br><span class="line"></span><br><span class="line">&lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span> debug=<span class="string">"0"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>1&gt;className指定实现Engine接口的类,默认值为StandardEngine<br>2&gt;defaultHost指定处理客户的默认主机名,在Engine中的Host子元素中必须定义这一主机<br>3&gt;name定义Engine的名字<br>    在Engine可以包含如下元素Logger, Realm, Value, Host</p>
<h3><span id="host标签元素">Host标签元素</span></h3><p>它由Host接口定义，一个Engine元素可以包含多个Host元素，每个Host元素定义了一个虚拟机主机，它包含一个或多个web应用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">	 appBase : 指 定虚拟主机的目录,可以指定绝对目录,也可以指定相对于&lt;CATALINA_HOME&gt;的相对目录.如果没有此项,默认 为&lt;CATALINA_HOME&gt;/webapps. 它将匹配请求和自己的Context的路径，并把请求转交给对应的Context来处 理</span><br><span class="line">	              autoDeploy:如果此项设为<span class="keyword">true</span>,表示Tomcat服务处于运行状态时,能够监测appBase下的文件,如果有新有web应用加入进来,会自运发布这个WEB应用</span><br><span class="line">	              unpackWARs:如果此项设置为<span class="keyword">true</span>,表示把WEB应用的WAR文件先展开为开放目录结构后再运行.如果设为<span class="keyword">false</span>将直接运行为WAR文件</span><br><span class="line">	              alias:指定主机别名,可以指定多个别名</span><br><span class="line">	              deployOnStartup:如果此项设为<span class="keyword">true</span>,表示Tomcat服务器启动时会自动发布appBase目录下所有的Web应用.如果Web应用 中的server.xml没有相应的&lt;Context&gt;元素,将采用Tomcat默认的Context</span><br><span class="line">	</span><br><span class="line">	           --&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;Host name=<span class="string">"localhost"</span> debug=<span class="string">"0"</span> appBase=<span class="string">"webapps"</span> unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在Host元素中可以包含如下子元素<br>    Logger, Realm, Value, Context</p>
<h3><span id="context标签元素">Context标签元素</span></h3><p>它是由Context接口定义，是使用最频繁的元素，每个Context元素代表了运行在虚拟主机上的单个web应用，一个Host可以包含多个Context元素，每一个web应用都有唯一一个相对应的context元素，servlet容器就是作为第一个web应用被创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Context，对应于一个Web App</span><br><span class="line">	 path : 该Context的路径名是<span class="string">""</span>，故该Context是该Host的默认Context</span><br><span class="line">	 docBase : 该Context的根目录是webapps/mycontext/</span><br><span class="line">	 reloadable:如果这个属性设为<span class="keyword">true</span>, Tomcat服务器在运行状态下会监视在WEB-INF/classes和Web-INF/lib目录CLASS文件的改运.如果监视到有<span class="class"><span class="keyword">class</span>文件 被更新,服务器自重新加载<span class="title">Web</span>应用</span></span><br><span class="line">	 useNaming:指定是否支持JNDI,默认值为了true </span><br><span class="line">	 cookies指定是否通过Cookies来支持Session,默认值为<span class="keyword">true</span></span><br><span class="line">	 -&gt;</span><br><span class="line">	&lt;Context path=<span class="string">""</span> docBase=<span class="string">"mycontext"</span> debug=<span class="string">"0"</span>/&gt;</span><br></pre></td></tr></table></figure>


<h2><span id="五-tomcat处理一个http请求的过程">五、tomcat处理一个http请求的过程</span></h2><p>假设来自客户端的请求：<a href="http://localhost:8080/index/index.html.jsp" target="_blank" rel="noopener">http://localhost:8080/index/index.html.jsp</a><br>        1. 请求被发送到本机端口8080上，并被监听8080端口、HTTP/1.1协议的Connector获取到。<br>        2. Connector把该请求交给它所在Service的Engine来处理，并等待来自Engine的响应<br>        3. Engine获得该请求后，匹配它所拥有的所有虚拟主机Host.<br>        4. Engine匹配到名为localhost的主机Host(即使匹配不到也会交给localhost主机来处理，因为Engine的默认主机就是localhost)<br>        5. localhost的主机解析获取到请求/index/index.jsp,匹配它所拥有的所有Context。<br>        6. Host匹配到路径为/index的Context。<br>        7. Path=”/index”的Context获取到请求index.jsp,在它的mapping table中寻找对应的servlet<br>        8. Context匹配到URL为.jsp的servlet类(其实就是JspServlet类做处理)<br>        9. 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用servlet类的doGet或doPost方法<br>        10. Context把执行完的HttpServletResponse对象返回给Host<br>        11. Host把HttpServletResponse对象返回给Engine<br>        12. Engine把HttpServletRespongse对象返回给Connector<br>        13. Connector把HttpServletResponse对象返回给客户端。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-基本使用</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8.png" alt="思维导图"></p>
<a id="more"></a>
<h2><span id="一-什么是tomcat">一、什么是Tomcat</span></h2><p> tomcat是一个Web服务器，是一个运行java程序的网络服务器，底层是Socket的一个程序，它也是jsp和Servlet的一个容器。<br><img src="https://img-blog.csdnimg.cn/20200413213630443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="二-配置tomcat">二、配置tomcat</span></h2><p> 运行Tomcat需要JDK的支持，tomcat会通过JAVA_HOME找到所需要的JDK，所以只需要配置JDK的环境变量就可以了。注意tomcat的版本与JDK的版本有一定的关系，例如JDK8不能匹配tomcat7，需要降低jdk的版本。<br>启动tomcat的时候一般出现的问题：</p>
<ul>
<li>JAVA_HOME没有配置正确</li>
<li>端口被占用了，解决办法：<pre><code>a. 查看端口被谁占用了，将该进程杀死
b. 主动修改tomcat启动使用的端口，修改的位置在tomcat主目录下的conf/server.xml配置文件中修改成其他端口：</code></pre><img src="https://img-blog.csdnimg.cn/20200413213710893.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200413213732843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2><span id="三-tomcat目录结构tomcat8">三、tomcat目录结构（tomcat8）</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413213819316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>bin目录：存放启动和关闭tomcat的bat文件</li>
<li>conf目录：存放配置文件，主要有的配置文件：<pre><code>a. Server.xml：该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机（Host），该文件描述了如何启动tomcat。详细看Tomcat-server.xml配置文件里面包含了tomcat处理一个Http请求的详细过程
b. Web.xml:Web应用的配置文件
Tomcat-web.xml配置文件和Web应用-web.xml配置文件
c. Tomcat-user.xml:配置用户名密码和相关权限</code></pre></li>
<li>lib目录：存放tomcat运行所需要的jar包</li>
<li>logs:存放日志文件，可以查看tomcat运行web程序的相关日志信息</li>
<li>webapps：放置我们的web应用</li>
<li>work：该目录用于存放jsp被访问后生成对应的server文件和.class文件</li>
</ol>
<h2><span id="四-webapps目录">四、webapps目录</span></h2><p>我们使用tomcat部署项目，接触最多的就是webapps目录，所以有必要单独拿出来说明一下。webapps目录结构如下：<br>    <img src="https://img-blog.csdnimg.cn/20200413213904708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么这样设计这样的webapps目录结构呢，因为webapps下的web应用目录是可以直接存放html等文件，是直接允许访问的资源，如果有多个html文件呢，tomcat启动的时候该访问哪个html文件呢，这就很难决定了；于是就存在WEB-INF目录下的web.xml文件，有了web.xml的支持，就可以给web应用指定规范了，当然上面的问题也能够得到解决。<br>    web.xml配置详解：Tomcat-web.xml配置文件和Web应用-web.xml配置文件<br>    指定访问首页可以添加一下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;welcome-file-list&gt;</span><br><span class="line">       &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line"> &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="五-配置虚拟目录">五、配置虚拟目录</span></h2><h3><span id="为什么需要配置虚拟目录">为什么需要配置虚拟目录</span></h3><p>当存在很多web应用项目的目录的时候，空间很多，可能导致该磁盘所在的空间不够用，不利于对web项目目录的管理，可以把wen应用的目录分散到其他磁盘，这样就需要配置虚拟目录，然后创建映射，即可管理不同磁盘位置的目录了。</p>
<h3><span id="怎么配置虚拟目录">怎么配置虚拟目录</span></h3><p>两种方法：<br>a. 第一种<br>        在tomcat目录下/conf/server.xml文件中配置，在<host>元素下添加<context>元素并设置path和docBase属性值，其中path标识url中的项目名称，如：<a href="http://localhost:8080/path/index.html；docBase表示web项目的绝对路径，例如：" target="_blank" rel="noopener">http://localhost:8080/path/index.html；docBase表示web项目的绝对路径，例如：</a></context></host></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Context path=<span class="string">"/demo"</span> docBase=<span class="string">"D:\demo"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>设置好了之后，在浏览器输入<a href="http://localhost:8080/demo/index.html，就会在D盘的demo目录下访问index.html资源了。" target="_blank" rel="noopener">http://localhost:8080/demo/index.html，就会在D盘的demo目录下访问index.html资源了。</a><br>b. 第二种<br>在conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是web项目名称，例如创建了一个叫demo1.xml,同时设置web项目路径</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt; </span><br><span class="line">&lt;Context </span><br><span class="line">    docBase=<span class="string">"D:\demo"</span> </span><br><span class="line">    reloadable=<span class="string">"true"</span>&gt; </span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器直接访问:<a href="http://localhost:8080/demo1/index.html；就会去D盘下的demo目录访问index.xml资源了。" target="_blank" rel="noopener">http://localhost:8080/demo1/index.html；就会去D盘下的demo目录访问index.xml资源了。</a></p>
<h2><span id="六-配置临时域名">六、配置临时域名</span></h2><ol>
<li>访问tomcat服务器的方式：<pre><code>a. 使用localhost域名访问（localhost表示本机）
b. 使用127.0.0.1访问
c. 使用本机的具体ip地址访问
d. 使用本机的机器电脑名称访问
e. 还可以使用给服务器配置的临时域名进行访问</code></pre></li>
<li>怎么配置临时域名<br> 自定义本机的域名：（在C:\Windows\System32\drivers\etc\hosts文件）<pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413214314465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70)</code></pre> 然后在tomcat目录下conf\server.xml配置文件的<host>元素上添加上面自定义的域名：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Host name=<span class="string">"huahua"</span> appBase=<span class="string">"D:\demo"</span>&gt;</span><br><span class="line">	&lt;Context path=<span class="string">"/demo"</span> docBase=<span class="string">"D:\demo"</span>&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>



</host></li>
</ol>
<h2><span id="七-tomcat的体系结构">七、tomcat的体系结构</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413214350867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="八-tomcat在浏览器访问web资源的流程图">八、tomcat在浏览器访问web资源的流程图</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413214409735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-思维导图</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/Tomcat%E6%95%99%E7%A8%8B.png" alt="思维导图"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-教程-自定义全局异常处理</title>
    <url>/2020/04/13/SpringMVC-%E6%95%99%E7%A8%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2><span id="一-说明">一、说明</span></h2><p>SpringMVC中的异常处理总览：<br><img src="https://img-blog.csdnimg.cn/20200412235824891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>     
<h2><span id="二-实现自定义全局异常处理">二、实现自定义全局异常处理</span></h2><p>在Web应用中，有时候我们在对客户端请求进行处理的时候，在响应的过程中往往会出现各种各样的异常，比如在业务层捕获到的异常等等，有些异常对应web应用来说不能单纯的往上抛或者随便处理一下，如果这样做都会影响客户端的体验效果的，我们需要做的是就是正确的捕获并处理这些异常信息，用正确的方式响应给客户端，让客户端知道哪里出问题了，这样我们就不能单单做局部异常管理了，需要做统一的异常处理，在SpringMVC中就提供了一个接口：HandlerExceptionResolver，让我们去实现自定义全局异常处理。<br>基本步骤：</p>
<ol>
<li><p>实现HandlerExceptionResolver接口</p>
</li>
<li><p>重写resolverException抽象方法<br> resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)<br> 参数说明：<br>  2.1 httpServletRequest： 当前的http请求 current HTTP request<br>  2.2 httpServletResponse： 当前的http响应 current HTTP response<br>  2.3 handler： 表示已经执行过的处理操作 the executed handler, or if none chosen at the<br>   time of the exception (for example, if multipart resolution failed)<br>  2.4 ex：表示当前发生的异常 the exception that got thrown during handler execution<br>  2.5 返回一个模型视图对象来表示一个异常错误的视图页面 return a corresponding ModelAndView to forward to,</p>
</li>
<li><p>实现Ordered接口并实现其抽象方法，设置优先级<br> 3.1重写getOrder方法，返回设置的优先级数值，数值越小优先级就越高</p>
</li>
<li><p>自定义异常类（自定义一个异常基类，同时可以让不同的子类去继承该基类，相当于做个异常类型的分类）</p>
</li>
<li><p>自定义结果响应码</p>
</li>
<li><p>自定义结果响应格式</p>
</li>
</ol>
<h2><span id="三-代码实现">三、代码实现</span></h2><ol>
<li>实现了HandlerExceptionResolver和Ordered接口的具体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * springMVC自定义统一异常处理；</span></span><br><span class="line"><span class="comment">	 * 1.实现HandlerExceptionResolver接口</span></span><br><span class="line"><span class="comment">	 * 2.重写resolverException抽象方法,参数说明：</span></span><br><span class="line"><span class="comment">	 * 2.1 httpServletRequest： 当前的http请求 current HTTP request</span></span><br><span class="line"><span class="comment">	 * 2.2 httpServletResponse： 当前的http响应 current HTTP response</span></span><br><span class="line"><span class="comment">	 * 2.3 handler： 表示已经执行过的处理操作 the executed handler, or if none chosen at the</span></span><br><span class="line"><span class="comment">	 *          time of the exception (for example, if multipart resolution failed)</span></span><br><span class="line"><span class="comment">	 * 2.4 ex：表示当前发生的异常 the exception that got thrown during handler execution</span></span><br><span class="line"><span class="comment">	 * 2.5 返回一个模型视图对象来表示一个异常错误的视图页面 return a corresponding ModelAndView to forward to,</span></span><br><span class="line"><span class="comment">	 * 3.实现Ordered接口并实现其抽象方法，设置优先级，</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * 所有的非主依赖项目统一使用日志桥接，主项目使用具体日志收集日志交接的日志信息做统一处理。</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">	</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	        Result result=<span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ApplicationException)&#123;</span><br><span class="line">	            <span class="comment">//自定义异常类</span></span><br><span class="line">	            ApplicationException applicationException= (ApplicationException) ex;</span><br><span class="line">	            result =Result.creat(applicationException.getCode()).setMessage(applicationException.getMessage());</span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	            result=Result.creat(ResultCode.ERROR).setMessage(<span class="string">"出现未知异常"</span>);</span><br><span class="line">	            logger.error(ex.getMessage(),ex);</span><br><span class="line">	        &#125;</span><br><span class="line">	        httpServletResponse.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">	        httpServletResponse.setStatus(HttpStatus.OK.value());<span class="comment">//记得debug一下</span></span><br><span class="line">	        PrintWriter writer= <span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            writer = httpServletResponse.getWriter();</span><br><span class="line">	            writer.write(JSON.toJSONString(result));</span><br><span class="line">	            writer.flush();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	            logger.error(<span class="string">" resolver json result exception "</span>, e);</span><br><span class="line">	        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	            writer.close();</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//这里可以自定义返回错误的视图页面。</span></span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义异常类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 18:09</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 统一的自定义应用基类异常：</span></span><br><span class="line"><span class="comment">	 * 需要继承已有的异常类如RuntimeException、Exception类等，这里继承了RuntimeException类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4895794930959697784L</span>;</span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE = <span class="string">"应用异常"</span>;</span><br><span class="line">	<span class="comment">//自定义统一响应结果码</span></span><br><span class="line">	    <span class="keyword">protected</span> <span class="keyword">int</span> code = ResultCode.APPLICATION_ERROR;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(MESSAGE);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message);</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message, cause);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(<span class="keyword">int</span> code, String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message, cause);</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(cause);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自定义响应结果格式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 17:16</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * SpringMVC统一响应请求的返回结果格式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//返回的结果体</span></span><br><span class="line">	    <span class="keyword">protected</span>  Object data;</span><br><span class="line">	    <span class="comment">//返回的结果状态码</span></span><br><span class="line">	    <span class="keyword">protected</span> Integer code;</span><br><span class="line">	    <span class="comment">//返回的结果信息</span></span><br><span class="line">	    <span class="keyword">protected</span> String message;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * setting/getting方法</span></span><br><span class="line"><span class="comment">	    * set方法返回当前对象，可用于伸缩</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> data;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.data = data;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> message;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.message = message;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * 构造器私有化，推荐使用静态工厂方法代替构造方法，</span></span><br><span class="line"><span class="comment">	    * 但没有公共或受保护的构造方法不能被子类化即不能被继承，推荐使用组合</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="function"><span class="keyword">private</span>  <span class="title">Result</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code=code;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//提供静态工厂方法获取实体类对象实例,可按参数伸缩</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creat(ResultCode.SUCCESS);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Result <span class="title">creat</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> Result(code);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">(Object data,String message)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creatSuccessResult().setData(data).setMessage(message);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">(Object data,String message,Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creat(code).creatSuccessResult(data,message);</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>自定义响应结果的状态码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 17:32</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 自定义响应返回结果状态码，具体业务返回码可以继承ResultCode</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultCode</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//成功状态码1</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">static</span> <span class="keyword">int</span> SUCCESS=<span class="number">1</span>;</span><br><span class="line">	    <span class="comment">//错误状态码以4开头</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">5555</span>;<span class="comment">// 未知错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> APPLICATION_ERROR = <span class="number">5000</span>;<span class="comment">// 应用级错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VALIDATE_ERROR = <span class="number">5001</span>;<span class="comment">// 参数验证错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SERVICE_ERROR = <span class="number">5002</span>;<span class="comment">// 业务逻辑验证错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_ERROR = <span class="number">5003</span>;<span class="comment">// 缓存访问错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DAO_ERROR = <span class="number">5004</span>;<span class="comment">// 数据访问错误</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC-异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title> Java-并发concurrent包-locks包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-locks%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发concurrent包</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-atomic包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-atomic%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发concurrent包</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-简介</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发concurrent包</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-源码分析-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Thread%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-Thread%E7%B1%BB/</url>
    <content><![CDATA[<h2><span id="一-简介">一、简介</span></h2><p>Thread类是启动线程并执行任务的基本类，通过实现Runnable接口的run方法或实现Callable接口的Call方法来创建线程执行的任务，这些任务的创建方式有三种：</p>
<ol>
<li>继承Thread类，重写run方法，直接调用Thread类的方法启动线程</li>
<li>实现Runnable接口，重写run方法，通过创建Thread对象并传入Runnable，调用Thread类的方法启动线程。</li>
<li>实现Callable接口，重写call方法，将其封装成FutureTask类型，通过创建Thread对象并闯入FutureTask，调用Thread类方法启动线程。<a id="more"></a>

</li>
</ol>
<p>##二、线程的基本属性</p>
<h3><span id="1-优先级">1. 优先级</span></h3><p>Thread 有个优先级字段：<code>private int priority</code><br>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。<br>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。<br>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。<br>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久；频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程的默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p> 线程优先级只是对操作系统分配时间片的建议。<br> 虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
<h3><span id="2-守护线程">2. 守护线程</span></h3><p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。<br>Thread 中有个布尔值标识当前线程是否为守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Daemon 属性需要在调用线程的 start() 方法之前调用。</span><br></pre></td></tr></table></figure>

<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。<br>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。<br>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonTreadTest0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" finally is called!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DaemonThread thread = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。<br>如果将setDaemon方法注释掉，就会发现有运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="keyword">finally</span> is called!</span><br></pre></td></tr></table></figure>

<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。也就是不建议在守护线程中使用finally</p>
<h2><span id="三-线程的生命周期">三、线程的生命周期</span></h2><p>线程具有如下几个状态：<br>    <code>NEW:</code>   新创建,还未调用 start() 方法；还不是活着的 (alive)<br>    <code>RUNNABLE :</code>就绪的,调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)<br>    <code>RUNNING:</code> 运行中,线程获得 CPU 资源，正在执行任务；活着的<br>    <code>BLOCKED:</code> 阻塞的 ,线程阻塞于锁或者调用了 sleep；活着的<br>    <code>WAITING:</code> 等待中 ,线程由于某种原因等待其他线程；活着的<br>    <code>TIME_WAITING:</code> 超时等待 ,与 WAITING 的区别是可以在特定时间后自动返回；活着的<br>    <code>TERMINATED :</code>    终止 ,执行完毕或者被其他线程杀死；不是活着的<br>有几点注意：<br>    Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE<br>让线程进入 WAITING 状态的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object.wait()</span><br><span class="line">Thread.join()</span><br><span class="line">LockSupport.park()</span><br><span class="line">Lock.lock()</span><br></pre></td></tr></table></figure>

<p>Thread 中有个判断是否为活着的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Java 中线程除了 <code>NEW</code> 和 <code>TERMINITED</code> 状态，其他状态下调用 <code>isAlive()</code> 方法均返回 true，也就是活着的。</p>
<h2><span id="四-线程的关键方法">四、线程的关键方法</span></h2><h3><span id="1threadsleeplong-millis">1.Thread.sleep(long millis)</span></h3><p><code>Thread.sleep(long millis)</code> 是一个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>   使当前所在线程进入阻塞只是让出 CPU ，并没有释放对象锁。<br>   由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数； 如果被中断会抛出 InterruptedException，注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程阻塞。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</p>
<h3><span id="2objectwait">2.Object.wait()</span></h3><p>与 <code>Thread.sleep()</code> 容易混淆的是 <code>Object.wait()</code> 方法。<br><code>Object.wait()</code> 方法：<br>    让出 CPU，释放对象锁。<br>    在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用；<br>    使该线程进入该对象监视器的等待队列。</p>
<h3><span id="3threadyield">3.Thread.yield()</span></h3><p><code>Thread. yield()</code> 也是一个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。 和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。<br>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。<br>yield() 一般使用较少。</p>
<h3><span id="4threadjoin">4.Thread.join()</span></h3><p>Thread.join() 表示线程合并，调用的当前线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。<br> 线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。<br>比如下述代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread is running!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br><span class="line">System.out.println(<span class="string">"main thread "</span>);</span><br></pre></td></tr></table></figure>

<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread is running!</span><br><span class="line">main thread</span><br></pre></td></tr></table></figure>

<p>Thread.join 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.无参方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	    join(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.有参方法，表示等待 millis 毫秒后自动返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">	    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">	            wait(<span class="number">0</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">	            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">	            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            wait(delay);</span><br><span class="line">	            now = System.currentTimeMillis() - base;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">	                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">	        millis++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    join(millis);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以发现，<code>Thread.join</code> 是通过 <code>synchronized + Object.wait()</code> 实现的。<br>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>
<h2><span id="五-线程的中断">五、线程的中断</span></h2><p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> running;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InterruptThread</span><span class="params">(<span class="keyword">boolean</span> running)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.running = running;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> running;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> running)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.running = running;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        InterruptThread thread = <span class="keyword">new</span> InterruptThread(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.setRunning(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。<br>因此我们可以通过修改这个标志位为 false 来中断该线程。<br>其实 Thread 内部也为我们提供了同样的机制 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">//试图中断调用线程，设置中断标志位为 false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> <span class="comment">//返回调用线程是否被中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span><span class="comment">//返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="1public-void-interrupt">1.public void interrupt()</span></h3><p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如Runnable 的 run() 方法就无法响应中断。<br>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnInterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnInterruptThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            setName(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is running!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">UnInterruptRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" is running!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        UnInterruptThread thread = <span class="keyword">new</span> UnInterruptThread(<span class="string">"无法中断的线程"</span>);</span><br><span class="line"><span class="comment">//        Thread thread = new Thread(new UnInterruptRunnable(), "无法中断");</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//先让它执行一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">//不立即退出</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！<br>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>
<h3><span id="2public-boolean-isinterrupted">2.public boolean isInterrupted()</span></h3><p>我们可以通过 <code>isInterrupted()</code> 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。<br> <code>isInterrupted()</code> 在刚创建时默认为 false 不用多说；<br> 线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false；<br>线程结束后，线程的中断标志位也会复位为 false。<br>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程中断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptTest</span> </span>&#123;</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException</span></span><br><span class="line"><span class="comment">	     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">SleepThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	            setName(s);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">	                <span class="keyword">try</span> &#123;</span><br><span class="line">	                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">	                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());</span><br><span class="line">	                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                    e.printStackTrace();</span><br><span class="line">	                    System.out.println(<span class="string">"SleepRunner 在 sleep 时被中断了，此时中断标志位为："</span> + isInterrupted());</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">BusyThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	            setName(s);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">	                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	        SleepThread sleepThread = <span class="keyword">new</span> SleepThread(<span class="string">"SleepRunner："</span>);</span><br><span class="line">	        BusyThread busyThread = <span class="keyword">new</span> BusyThread(<span class="string">"BusyRunner："</span>);</span><br><span class="line">	        <span class="comment">//新创建的线程 中断标志为 false</span></span><br><span class="line">	        System.out.println(<span class="string">"SleepThread 新创建时的中断标志位："</span> + sleepThread.isInterrupted());</span><br><span class="line">	        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	        <span class="comment">//启动两个线程</span></span><br><span class="line">	        sleepThread.start();</span><br><span class="line">	        busyThread.start();</span><br><span class="line">	        <span class="comment">//让它们运行一秒</span></span><br><span class="line">	        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	        <span class="comment">//分别中断两个线程</span></span><br><span class="line">	        sleepThread.interrupt();</span><br><span class="line">	        busyThread.interrupt();</span><br><span class="line">	        <span class="comment">//查看线程的中断标志位</span></span><br><span class="line">	        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	        System.out.println(<span class="string">"由于中断标志位变为 true 导致运行结束的线程，中断标志位为: "</span> +       busyThread.isInterrupted());</span><br><span class="line">	        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。<br>可以看到：<br>    线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false<br>    这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</p>
<h3><span id="3public-static-boolean-interrupted">3.public static boolean interrupted()</span></h3><p>Thread.interrupted() 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。<br>因此 Thread.interrupted() 第二次调用永远返回 false。<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="六-thread类总结">六、Thread类总结</span></h2><p>线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-三大特性</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2><span id="一-什么是并发三大性质">一、什么是并发三大性质</span></h2><p>在并发编程中，去解决线程安全的问题，一般可以从两大核心和三大特性作为切入点来思考怎么去解决，两大核心就是JMM内存模型和happens-before规则（三、Java内存模型的抽象和happens-before规则），三大特性主要是原子性、可见性和有序性。并发关键字synchronized和volatile都涉及到了三大特性，说明了三大特性的重要性。从这两个关键字分析这三大特性。</p>
<a id="more"></a>
<h2><span id="二-原子性">二、原子性</span></h2><p>什么是原子性：就是指一个操作是不可中断的，要么执行成功要么执行失败，在多线程中，一个线程正在执行就不会被其他线程干扰。分析如下例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//1</span></span><br><span class="line">a++; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span> b=a; <span class="comment">//3</span></span><br><span class="line">a = a+<span class="number">1</span>; <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>上面这四个语句中只有第1个语句是原子操作，将10赋值给线程工作内存的变量a,而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3,4的分析同理可得这两条语句不具备原子性。当然，java内存模型中定义了8中操作都是原子的，不可再分的：<br>        <code>a. lock(锁定)：</code>作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；<br>        <code>b. unlock(解锁):</code>作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br>        <code>c. read（读取）：</code>作用于主内存的变量，它把一个变量的值从主内存复制传输到线程的工作内存中，以便后面的load动作使用；<br>        <code>d. load（载入）：</code>作用于工作内存中的变量，它把read操作从主内存中得到的变量值复制放入工作内存中的变量副本<br>        <code>e. use（使用）：</code>作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；<br>        <code>f. assign（赋值）：</code>作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；<br>        <code>g. store（存储）：</code>作用于工作内存的变量，它把工作内存中一个变量的值同步传送给主内存中以便随后的write操作使用；<br>        <code>h. write（操作）：</code>作用于主内存的变量，它把store操作从工作内存中得到的变量的值同步放入主内存的变量中。<br>    上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。那么如何理解这些指令了?比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：<code>read a,read b, load b,load a。</code><br>    由原子性变量操作<code>read,load,use,assign,store,write</code>，可以大致认为基本数据类型的访问读写具备原子性（<code>例外就是long和double的非原子性协定</code>）</p>
<h3><span id="1-synchronized">1. synchronized</span></h3><p>上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下lock和unlock两条原子操作。如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是synchronized关键字，也就是说synchronized满足原子性。</p>
<h3><span id="2-volatile">2. volatile</span></h3><p>我们先来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                        counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000;可是运行多次都是小于100000的结果，问题在于 volatile并不能保证原子性，在前面说过counter++这并不是一个原子操作，包含了三个步骤：1.读取变量counter的值；2.对counter加一；3.将新值赋值给变量counter。如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。<br>    <code>如果让volatile保证原子性，必须符合以下两条规则</code>：<br>        1. 运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；<br>        2. 变量不需要与其他的状态变量共同参与不变约束</p>
<h2><span id="二-可见性">二、可见性</span></h2><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized具有可见性。同样的在volatile分析中，会通过在指令中添加内存屏障指令，以实现内存可见性。因此, volatile具有可见性</p>
<h2><span id="三-有序性">三、有序性</span></h2><h3><span id="1-synchronized">1. synchronized</span></h3><p>synchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此synchronized具有有序性。</p>
<h3><span id="2-volatile">2. volatile</span></h3><p>在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。volatile包含禁止指令重排序的语义，其具有有序性。</p>
<h2><span id="四-总结">四、总结</span></h2><p>synchronized: 具有原子性，有序性和可见性； volatile：具有有序性和可见性</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-final</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-final/</url>
    <content><![CDATA[<h2><span id="一-什么是final">一、什么是final</span></h2><p>final是java中关键字修饰符，可以修饰变量、方法和类，用于表示所修饰的内容一旦赋值之后就不能被改变了，例如final修饰基本类型，一旦赋值之后就不能改变了；Sting类就是一个final类；final修饰引用类型的时候，不可改变的是它的引用地址；final在对线程中存在的重排序问题也有一定的作用，我们可以从final的具体使用场景：变量、方法、类上修饰final类分析一下。</p>
<a id="more"></a>
<h2><span id="二-final修饰的变量">二、final修饰的变量</span></h2><p>在java中的变量，可以分为成员变量和局部变量（存在方法中），又可以从这两个方面来分析。上边说了final修饰的变量一旦赋值了就不可以被改变了，那么变量需要有值才算完整，那么变量就会存在初始赋值时机。</p>
<h3><span id="1-final修饰成员变量">1. final修饰成员变量</span></h3><p>在每个类中的成员变量又可以分为类变量（使用static修饰）和实例变量，那么这两种成员变量的初始赋值时机是在什么时候呢？<br>    它们两的赋值时机是不同的:</p>
<h4><span id="a-类变量赋初值的时机有两种">a. 类变量：赋初值的时机有两种：</span></h4><p>i. 类变量可以在声明变量的时候直接赋初值<br>ii. 可以在静态代码块中赋初值</p>
<h4><span id="b-实例变量赋初值的时机有三种">b. 实例变量：赋初值的时机有三种：</span></h4><p>i. 可以在声明变量的时候直接赋初值<br>ii. 可以在非静态代码块中赋初值<br>iii. 可以在构造器中赋初值<br>        <img src="https://img-blog.csdnimg.cn/20200414211557937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4><span id="总结一下">总结一下：</span></h4><p>1）final修饰的成员变量必须要进行初始化，初始化的方法如上面赋初值时机<br>2）成员变量初始化的时候必须按照上面所说的位置进行初始化，不能乱位置，否则会报错<br>3）已经赋值过了的final变量就不能再赋值了</p>
<h3><span id="2-final修饰局部变量">2. final修饰局部变量</span></h3><p>final修饰的局部变量需要由程序员进行显示初始化，如果final局部变量已经进行初始化了后面就不能进行再次更改了，如果final局部变量未进行初始化，则可以进行赋值，但一旦赋了值就不能进行更改了，否则会出错。</p>
<h4><span id="注意">注意：</span></h4><p>1）final基本数据类型和final引用类型是有点不一样的，final修饰基本类型并初始化的时候，不能对基本类型变量进行再次赋值；而final修饰的引用类型变量而言，它仅仅保存的是一个引用，final只能保证这个引用类型变量的引用地址不会发生改变，至于它引用的对象的属性是可以改变的。<br>2）如果变量使用final修饰并且指定了初始值，该初始值在编译时就能唯一指定的话，该变量就是常量</p>
<h2><span id="三-final修饰的方法">三、final修饰的方法</span></h2><ol>
<li>final修饰方法的时候，父类的final方法不能被子类重写，但final方法是可以被重载的。</li>
</ol>
<h2><span id="四-final修饰的类">四、final修饰的类</span></h2><p>final修饰类的时候，表明该类是不能被子类所继承的，这个主要的作用是为了让子类不可以修改父类的方法和属性。<br>    不可变类：创建该类的实例之后，该实例的成员变量是不可变的；需要满足以下条件：<br>        1. 使用private和final修饰该类的成员变量<br>        2. 提供带参数的构造器用于初始化类的成员变量<br>        3. 仅为该类提供getter方法，不提供setter方法，因为普通方法无法修改final修饰的成员变量<br>        4. 如果有必要就重写Object类的hashCode()方法和equals()方法，应该保证用equals（）判断相同的两个对象其Hashcode值也是相等的。<br>    JDK中提供的八个包装类和String类都是不可变类。</p>
<h2><span id="五-多线程的final">五、多线程的final</span></h2><p>在Java内存模型中，处理器和编译器为了提高性能对指定进行重排序，其中只要有编译器重排序和处理器重排序，其实final对重排序也有一定的作用。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-volatile</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-volatile/</url>
    <content><![CDATA[<h2><span id="一-什么是volatile">一、什么是volatile</span></h2><p>synchronized是阻塞式同步机制，在线程竞争激烈的情况下会升级为重量级锁（不使用自旋，直接阻塞线程），而volatile可以说是Java虚拟机提供的最轻量级的同步机制。<br>volatile的作用是保证使用volatile修饰的共享变量的可见性，即线程对volatile变量的修改会立即更新到主内存中，以被其他线程所感知，就不会出现数据脏读的现象，保证了数据的可见性。<br>对于volatile的内存定义参考：Java-并发理论-JMM内存模型：1）volatile：读写内存定义</p>
<a id="more"></a>
<h2><span id="二-volatile的实现原理">二、volatile的实现原理</span></h2><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：<br>        1. 通过对声明了volatile的变量使用Lock前缀指令引起处理器缓存写回内存；<br>        2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；<br>        3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。<br>    这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
<h2><span id="三-volatile的happens-before规则">三、volatile的happens-before规则</span></h2><p><code>volatile变量规则：</code>对于一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>列举一个例子，如果有两个线程A和线程B操作一个volatile共享变量，根据happens-before规则，volatile变量先写后读，那么得到的执行流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        a = <span class="number">1</span>;          <span class="comment">//1</span></span><br><span class="line">	        flag = <span class="keyword">true</span>;   <span class="comment">//2</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        <span class="keyword">if</span>(flag)&#123;      <span class="comment">//3</span></span><br><span class="line">	            <span class="keyword">int</span> i = a; <span class="comment">//4</span></span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200414212223522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加锁线程A先执行writer方法，然后线程B执行reader方法图中每一个箭头两个节点就代码一个happens-before关系，黑色的代表根据程序顺序规则推导出来，红色的是根据volatile变量的写happens-before 于任意后续对volatile变量的读，而蓝色的就是根据传递性规则推导出来的。这里的2 happen-before 3，同样根据happens-before规则定义：如果A happens-before B,则A的执行结果对B 可见，并且A的执行顺序先于B的执行顺序，我们可以知道操作2执行结果对操作3来说是可见的，也就是说当线程A将volatile变量 flag更改为true后线程B就能够迅速感知。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-synchronized</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-synchronized/</url>
    <content><![CDATA[<h2><span id="一-什么是synchronized">一、什么是Synchronized</span></h2><p>这个可以参考一下介绍：Java-并发理论-JMM内存模型：volatile和锁（synchronized，ReentrantLock）。<br>Synchronized关键字主要是用来解决多线程的线程安全问题的。是一种同步机制。那么这些安全性问题主要是来源JMM内存模型中主内存和线程的工作内存带来共享变量的可见性问题，以及重排序带来的问题；Java中的关键字synchronized同步机制就具备解决这些共享数据的线程安全问题，但是这种同步机制的效率很低，但是synchronized是其他并发容器实现的基础，理解它会提高并发编程有很大帮助。</p>
<a id="more"></a>     
<h2><span id="二-synchronized的作用是什么">二、synchronized的作用是什么</span></h2><p>主要是在多线程环境下保证线程安全<br>    1. 保证了线程的原子性，即被保护的代码块或方法是一次被执行的，中间没有其他线程同时访问<br>    2. 保证了共享变量的可见性，即当执行完synchronized的代码块或方法之后，修改后的共享变量会更新到主内存中，其他线程是可见的。</p>
<h2><span id="三-synchronized的实现原理">三、Synchronized的实现原理</span></h2><h3><span id="synchronized基本用法">synchronized基本用法</span></h3><p>synchronized关键字在Java中使用很简单，可以使用在代码块中和方法上，具体的使用位置如下：<br><img src="https://img-blog.csdnimg.cn/20200411203809896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>synchronized是一种互斥锁，可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。</p>
<h3><span id="synchronized底层实现原理">synchronized底层实现原理</span></h3><ul>
<li>a. 监视器（monitor）机制<br>i. synchronized是一种内置锁/监视器锁，Java中每个对象都有一个内置锁（monitor监视器锁，就像一个标记一样），而synchronized就是使用对象的内置监视器锁来将代码块或方法锁定的。<br>ii. 在底层，synchronized关键字对代码块是通过monitorenter和moniterexit指令实现的；对方法是通过方法修饰符上的ACC_SYNCHRONIZED实现的。<br>iii. synchronized具有内置锁的可重入性，即它是重入锁，如果在一个线程中，方法A使用了synchronized锁，而在方法A中又存在方法a中也存在使用synchronized锁，那么从方法A调用方法a的过程中，即从外锁再进入内锁是不需要重新获取锁了，在外锁获取一次就可以了，到里面继续使用原来的锁，因为锁是线程持有的，在一个线程内不会重复获取锁，这就是重入锁<br>下面是在多线程中使用synchronized关键字的对象Object与监视器之间的关系：<br> <img src="https://img-blog.csdnimg.cn/20200411203857917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">上面可以看出，如果想要访问使用synchronized的对象Object，首先需要获取Object的监视器（使用monotorenter命令）,若获取失败则进入同步队列，线程状态变成Blocked状态，当Object的监视器占有者释放后，在同步队列中的线程就有机会重新获取该监视器了。</li>
<li>b. synchronized的happens-before规则<br> 监视器锁规则是：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。<br> 看一下下面代码，若有两个线程A和B分别执行writer和reader方法（假设线程A先执行），是怎么执行上面这条规则的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">	        a++;                                <span class="comment">// 2</span></span><br><span class="line">	    &#125;                                       <span class="comment">// 3</span></span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">	        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">	    &#125;                                      <span class="comment">// 6</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200411203955342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系。<br>    现在重点关注2 happens-before 5，通过这个关系我们可以得出什么？<br>    根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</p>
<ul>
<li>c. 锁获取和锁释放的内存定义<br> 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br> 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>参考：Java-并发理论-JMM内存模型：2）锁：锁释放和锁获取的内存定义</li>
</ul>
<h2><span id="四-synchronized的优化">四、synchronized的优化</span></h2><p> 对于上面已经很详细说了synchronized关键字的底层原理了，简单来说，它最大的特点就是：<br>    在同一时刻只有一个线程能够对得对象得监视器（monitor），从而在进入同步代码块或方法中，如果其他线程进来需要等监视器释放锁，这种行为表现为互斥性（排他性）。<br>但是如果每次都只能有一个线程进入方法或代码块，这样执行的效率必然很低的，就像我们买东西后排队付钱一样，原来的方式是拿现金到收银台给收银员付款，还要找零钱等等，得一个一个来，效率很低，现在呢，出现了微信支付和支付宝支付，付款只需要拿出收集扫一下二维码就可以付款了，很方便，效率相对于提高了很多；同样对于synchronized效率低得情况下也出现了类似的优化。</p>
<h3><span id="优化之cas算法无锁算法">优化之CAS算法（无锁算法）</span></h3><ul>
<li>a. 什么是CAS<br>CAS的全称为compare and swap(比较并替换)，是一种乐观的思想，相对于Synchronized是一种悲观的思想，也就是说synchronized时时刻刻都想着肯定会有其他线程跟我竞争资源的，我就把这个共享资源一直占用着，别的线程只能在外面等着，处于阻塞状态，直到我释放了你才能用；而CAS是这样想的，并不是时时刻刻都有别的线程跟我竞争资源的，如果真的有人过来跟我竞争资源的，我才告诉他等我用完释放了你才能使用，这样别的线程就不会都处于阻塞状态了，不需要竞争的线程还可以继续工作下去，只有真正需要竞争的才需要阻塞等待。那么CAS是怎么做到的呢？</li>
<li>b. CAS的实现过程<br>实现CAS的过程需要三个操作数：内存中的原值V，旧的预期值A，需要修改的新值B，实现的过程只需要三步：<pre><code>i. 比较A值与V值是否相等
ii. 如果相等则说明旧值A还是最新的内存值，没有被其他线程更改过，将B值替换V值，返回更新成功
iii. 如果不相等，则说明内存值已经被其他线程修改过了，不是最新的值，所以不能将B值图换成V值，更新失败，返回内存原值V即可；并可以重新尝试。</code></pre>当多个线程同时使用CAS操作一个变量时，只有一个线程会操作成功，但并不会阻塞其他线程，只是其余的都会收到失败的信号，失败的线程可以选择重新尝试也可以选择挂起线程。</li>
<li>c. CAS基本的底层原理<br> java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。<br> unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg<br> Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>
<li>d. 在Java中的应用<br>在JUC包中利用CAS算法实现的类有很多，可以说是支持起整个concurrency包的实现，在locks包中的实现会有CAS改变state变量，在atomic包中的实现类几乎都是利用CAS算法实现的，一般的应用场景：<pre><code>自旋锁，会一直while()循环，直到CAS操作成功为止，如下执行lock()方法的时候</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		  <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    <span class="keyword">while</span>(!sign .compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    sign .compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e. CAS的缺点<br> i. ABA的问题，CAS会检查旧值有没有变化，如果出现这种情况，旧值A跟原值V比较，相等了才替换称B值，若在比较之前，A值变成了B值，然后有变成A值，比较的时候旧值依然为A值没有变化，但实际上已经发生了变化，解决的方法也很简单，像数据库中使用的乐观锁的方式，加一个版本号就可以解决了，原来的变化为A-B-A,解决后为1A-2B-3A；Java在1.5版本以后的atomic包中就提供了AtomicStampedReference来解决ABA的问题。<br> ii. 自旋时间过长的问题，使用CAS时是非阻塞同步（无锁），也就是说不会将线程挂起，会自旋（就是一个死循环）进行下一次尝试，如果自旋时间过长也会对性能有很大的影响。目前只是限制自旋次数。最终自旋失败了就进去阻塞状态。如果JVM能支持处理器提供的pause指令，那么效率上会有很大的提升。<br> iii. 只能保证一个共享变量的原子操作<br> iv. 如果只对一个共享变量进行cas操作时能保证原子性，但是如果对多个共享变量进行操作，cas就不能保证其原子性了，有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-教程-简介</title>
    <url>/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1><span id="spring是什么">spring是什么</span></h1><p>spring是一个企业级应用的开源框架，它也是轻量级的、一站式的、面向切面编程的、依赖注入DI和容器IOC的、模块化的框架。<br>总的来说，Spring就是用来替代更加重量级的企业级的Java技术。</p>
<a id="more"></a>
<h1><span id="spring能做什么">spring能做什么</span></h1><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性的角度而言，绝大部分Java应用都可以从Spring中受益。<br>spring实现了使用简单的组件将Java对象配置组合成 了一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象。Spring对JavaEE中非常难开发的一些API（JDBC、JavaMail、远程调用等），都提供了封装，大大降低了这些API的应用难度。</p>
<ul>
<li>轻量级：立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>非侵入式：也就是自己开发的类不依赖Spring的API接口，对现有的类结构没有影响，也能够增强JavaBean的功能  </li>
<li>IOC容器：spring是一个容器，因为它包含并且管理应用对象的生命周期。<br>降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>一站式：在AOP和IOC的基础上可以整合出各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的JDBC）;<br>spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。<br>总的来说Spring可以简化Java的开发：</li>
</ul>
<ol>
<li>基于POJO（也叫Java bean）轻量级和最小侵入式开发</li>
<li>通过IOC、依赖注入和面向接口实现松耦合</li>
<li>基于切面进行声明式编程</li>
<li>通过切面和模板来减少样板式代码</li>
</ol>
<h1><span id="spring为什么出现">spring为什么出现</span></h1><p><img src="/images/Spring-1-1.png" alt="B/S结构"><br>这张图上展示了一个基于SSH,B/S结构的单体Java应用的搭建过程，首先通过浏览器进入到Filter拦截器，进入到Structs2，通过Service层进入到Hibernate，从而进行操作数据库，若整个过程都是由SpringIOC容器控制就显得那么简单了。说白了就是为了简化复杂的操作过程，减少问题的出现。这张图向我们展示了一个比较基础的JavaWeb的搭建过程。万变不离其宗，后来使用的SSM框架，现在比较火的微服务架构，都离不开这张图上展示的内容所提供给大家的思想。每个框架的实现宗旨都是一样的，只不过实现的方式不一样。其实在这个框架最初的时候应该是以JSP+Servlet比较常用，后来为了解决前后端分离的问题，降低耦合度。将这些功能结构按照MVC分层实现。<br>个人的理解MVC为一种程序设计思想，可以很多场合使用到，从Web、后端、移动端在很多的场合下将MVC作为一种程序设计思想应该是比较恰当的。</p>
<h1><span id="spring结构体系模块化">spring结构体系（模块化）</span></h1><p><img src="/images/Spring-1-2.png" alt="Spring结构"></p>
<h2><span id="核心容器">核心容器</span></h2><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：<br>-** spring-core模块**提供了框架的基本组成部分，包括 IoC容器 和依赖注入功能。</p>
<p>-** spring-beans 模块**提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
<p>-** context模块**建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
<p>-<strong>spring-expression模块</strong>提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
<p>它们的完整依赖关系如下图所示：<br><img src="/images/Spring-1-3.png" alt="Spring依赖关系图"><br><img src="/images/Spring-1-4.png" alt="Spring关系"></p>
<h2><span id="数据访问集成">数据访问/集成</span></h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：<br>注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）<br>• JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。<br>• ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。<br>• OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。<br>• JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。<br>• 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h2><span id="web">Web</span></h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：<br>• Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。<br>• Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。<br>• Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。<br>• Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
<h2><span id="其他">其他</span></h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：<br>• AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。<br>• Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。<br>• Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。<br>• Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。<br>• 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-属性配置类-PropertyPlaceholderConfigurer</title>
    <url>/2020/03/11/Spring-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%B1%BB-PropertyPlaceholderConfigurer/</url>
    <content><![CDATA[<h2><span id="是什么">是什么</span></h2><p>PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。在bean初始化前执行的后置处理器</p>
<a id="more"></a>
<h2><span id="作用">作用</span></h2><p>在Spring中，使用PropertyPlaceholderConfigurer可以在XML配置文件中加入外部属性文件，当然也可以指定外部文件的编码。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改</p>
<h2><span id="使用方法">使用方法</span></h2><h3><span id="编写properties文件">编写.properties文件</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdbc.properties 文件</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/ds?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;allowMultiQueries=true</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<h3><span id="在xml中引入外部文件即properties文件">在.xml中引入外部文件，即.properties文件</span></h3><ul>
<li>如果引单个文件：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		&lt;value&gt;jdbc.properties&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;property name=<span class="string">"fileEncoding"</span>&gt;</span><br><span class="line">	   &lt;value&gt;UTF-8&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果引多个文件（添加）：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		 &lt;list&gt;  </span><br><span class="line">			&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;classpath:inter.properties&lt;/value&gt;</span><br><span class="line">		 	&lt;value&gt;classpath:email.properties&lt;/value&gt;</span><br><span class="line">		 &lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="引入外部文件后就可以在xml中用key替换指定的properties文件中的值通常项目中都会将jdbc的配置放在properties文件中">引入外部文件后，就可以在xml中用${key}替换指定的properties文件中的值，通常项目中都会将jdbc的配置放在properties文件中</span></h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置dbcp数据源 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSourceDefault"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>在启动容器时，初始化bean时，${key}就会替换成properties文件中的值<br>为简化PropertyPlaceholderConfigurer的使用，Spring提供了<a href="context:property-placeholder/">context:property-placeholder/</a>元素,启用它后，开发者便不用配置PropertyPlaceholderConfigurer对象了</p>
<h4><span id="编写properties文件">编写.properties文件</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/jdbc.properties 文件</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//66.59.208.106:3306/ds?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;allowMultiQueries=true</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
<h4><span id="配置属性文件的位置">配置属性文件的位置</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库配置文件位置 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>PropertyPlaceholderConfigurer内置的功能非常丰富，如果它未找到${xxx}中定义的xxx键，它还会去JVM系统属性（System.getProperty()）和环境变量（System.getenv()）中寻找。通过启用systemPropertiesMode和searchSystemEnvironment属性，开发者能够控制这一行为。context:property-placeholder大大的方便了我们数据库的配置。这样就可以为spring配置的bean的属性设置值了</p>
<h4><span id="配置bean的属性">配置bean的属性</span></h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置dbcp数据源 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSourceDefault"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<p>注：spring容器中最多只能定义一个context:property-placeholder，否则会报错：Could not resolve placeholder XXX,但如果想引入多个属性文件怎么办那，可以使用通配符：<code>&lt;context:property-placeholder location=&quot;classpath*:conf*.properties&quot;/&gt;</code></p>
<h2><span id="自定义-propertyplaceholderconfigurer">自定义 PropertyPlaceholderConfigurer</span></h2><p>继承PropertyPlaceholderConfigurer 类，重写processProperties（）方法，之所以自定义，很有可能是因为java代码中使用了属性值，那些经常变得值，但又是常量，但是这样配置的话，如果属性文件中的属性值改变了，必须重启容器，因为容器启动时，已经将属性值初始化进了代码中就不变了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholder</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; propertyMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.processProperties(beanFactoryToProcess, props);</span><br><span class="line">        propertyMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">            String keyStr = key.toString();</span><br><span class="line">            String value = props.getProperty(keyStr);</span><br><span class="line">            propertyMap.put(keyStr, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个方法，即根据key拿属性值,方便java代码中取属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyMap.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring在创建bean时就会调用processProperties（）方法，属性文件中设置的键值对都放在了Properties中<br>自定义了PropertyPlaceholderConfigurer类之后，在xml中配置时，配置bean中的class就必须设置为自定义的类（包路径+类名），不能再写为PropertyPlaceholderConfigurer类，否则自定义的方法不能使用，因为根本没有创建自定义类的bean。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyCondigDefine"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.huahua.springmvc.base.config.PropertyPlaceholder "</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"location"</span>&gt;</span><br><span class="line">        &lt;value&gt;classpath:config-test.properties&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"testmodel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.huahua.springmvc.model.TestModel"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-属性配置类</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-教程-简介</title>
    <url>/2020/02/11/SpringMVC-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2><span id="一-spring-mvc运行原理">一、spring mvc运行原理</span></h2><p>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。<br><img src="https://img-blog.csdnimg.cn/2020041123510668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>(1) Http请求：客户端请求提交到DispatcherServlet。</li>
<li>(2)寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</li>
<li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。</li>
<li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。</li>
<li>(6)(7)处理视图映射并返回模型：DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。</li>
<li>(8) Http响应：视图负责将结果显示到客户端。</li>
</ul>
<h2><span id="二-主要注解">二、主要注解</span></h2><p><img src="https://img-blog.csdnimg.cn/20200411235319423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="三-springmvc的启动过程">三、SpringMVC的启动过程</span></h2><p>spring mvc启动过程主要有两个过程：</p>
<ul>
<li>ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。</li>
<li>DispatcherServlet初始化。</li>
</ul>
<h3><span id="contextloaderlistener">ContextLoaderListener</span></h3><p>在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。</p>
<ul>
<li>一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。</li>
<li>当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param&gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet​。（同类多个节点以出现顺序依次加载）<br><img src="https://img-blog.csdnimg.cn/20200412161931698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们来看一下SpringMVC中的web.xml配置<br><img src="https://img-blog.csdnimg.cn/20200412161944853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p>其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。</p>
<h3><span id="contextloaderlistener在webxml中的配置">ContextLoaderListener在web.xml中的配置</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 配置contextConfigLocation初始化参数 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">	&lt;!-- 配置ContextLoaderListerner --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ServletContextListener 接口有两个方法:contextInitialized,contextDestroyed</p>
<h3><span id="dispatcherservlet">DispatcherServlet</span></h3><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。<br>下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。</p>
<ul>
<li>流程图<br><img src="https://img-blog.csdnimg.cn/20200411235550692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>在web.xml中的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- servlet定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">	</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">dispatcher</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>load-on-startup：表示启动容器时初始化该Servlet；</li>
<li>url-pattern：表示哪些请求交给Spring Web MVC处理， “/”<br>是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。</li>
</ul>
<p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。<br>WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）<br><img src="https://img-blog.csdnimg.cn/2020041123563619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。<br><img src="https://img-blog.csdnimg.cn/2020041123564796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中，常用的ViewResolver的配置。以jsp作为视图为例</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 对模型视图名称的解析,即在模型视图名称添加前后缀 --&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">配置上传文件限制MultipartResolver</span><br><span class="line">	&lt;!-- 上传限制 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">     &lt;!-- 上传文件大小限制为<span class="number">31</span>M，<span class="number">31</span>*<span class="number">1024</span>*<span class="number">1024</span> --&gt;</span><br><span class="line">     &lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"32505856"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="applicationcontextxml中的标签">applicationContext.xml中的标签</span></h3><p><img src="https://img-blog.csdnimg.cn/20200411235735116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3><span id="文件上传">文件上传</span></h3><p>前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。</p>
<ul>
<li>表单</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">	&lt;form method=<span class="string">"post"</span> action=<span class="string">"/form"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">     &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@RequestMapping</span>(path = <span class="string">"/form"</span>, method = RequestMethod.POST)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, </span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">          <span class="comment">// store the bytes somewhere</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="异常处理">异常处理</span></h3><p>先来说下常见的异常处理有几种方式，如下图：<br><img src="https://img-blog.csdnimg.cn/20200411235847237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。<br>某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。</p>
<ul>
<li>HandlerExceptionResolver 提供resolveException接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;  </span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在BaseController中使用 @ExceptionHandler注解处理异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Object</span> <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">ex</span>, <span class="title">HttpServletResponse</span> <span class="title">response</span>, </span></span><br><span class="line"><span class="class">              <span class="title">HttpServletRequest</span> <span class="title">request</span>) <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">		String url = <span class="string">""</span>;</span><br><span class="line">		String msg = ex.getMessage();</span><br><span class="line">		Object resultModel = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex.getClass() == HttpRequestMethodNotSupportedException<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				url = <span class="string">"admin/common/500"</span>;</span><br><span class="line">				System.out.println(<span class="string">"--------毛有找到对应方法---------"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex.getClass() == ParameterException<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//自定义的异常</span></span><br><span class="line">                                </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex.getClass() == UnauthorizedException<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				url = <span class="string">"admin/common/unauth"</span>;</span><br><span class="line">				System.out.println(<span class="string">"--------毛有权限---------"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">String header = req.getHeader(<span class="string">"X-Requested-With"</span>);</span><br><span class="line">			<span class="keyword">boolean</span> isAjax = <span class="string">"XMLHttpRequest"</span>.equalsIgnoreCase(header);</span><br><span class="line">			String method = req.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isPost = <span class="string">"POST"</span>.equalsIgnoreCase(method);</span><br><span class="line"><span class="keyword">if</span> (isAjax || isPost) &#123;</span><br><span class="line">				<span class="keyword">return</span> Message.error(msg);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ModelAndView view = <span class="keyword">new</span> ModelAndView(url);</span><br><span class="line">				view.addObject(<span class="string">"error"</span>, msg);</span><br><span class="line">				view.addObject(<span class="string">"class"</span>, ex.getClass());</span><br><span class="line">				view.addObject(<span class="string">"method"</span>, request.getRequestURI());</span><br><span class="line">				<span class="keyword">return</span> view;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">			logger.error(exception.getMessage(), exception);</span><br><span class="line">			<span class="keyword">return</span> resultModel;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			logger.error(msg, ex);</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在web.xml中处理异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 默认的错误处理页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">	&lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">	&lt;location&gt;/403.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">	&lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">	&lt;location&gt;/404.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&gt;</span><br><span class="line">&lt;!-- 这样配置也是可以的，表示发生<span class="number">500</span>错误的时候，转到<span class="number">500</span>.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">	&lt;error-code&gt;500&lt;/error-code&gt; </span><br><span class="line">	&lt;location&gt;/500.html&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line">	&lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到<span class="number">500</span>.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">	&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; </span><br><span class="line">	&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line">	&lt;error-page&gt; </span><br><span class="line">	&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; </span><br><span class="line">	&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">	&lt;!-- 当error-code和exception-type都配置时，exception-type配置的页面优先级高及出现<span class="number">500</span>错误，发生异常Exception时会跳转到<span class="number">500</span>.jsp--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题<br>HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？</li>
<li>解答：<br>如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： return a corresponding ModelAndView to forward to, or null for default processing.</li>
</ul>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC-简介</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-动态代理</title>
    <url>/2020/01/15/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-反射</title>
    <url>/2020/01/15/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-枚举</title>
    <url>/2020/01/14/Java-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-泛型</title>
    <url>/2020/01/14/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-数据结构-哈希表</title>
    <url>/2020/01/13/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-注解</title>
    <url>/2020/01/13/Java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器-Map-总览</title>
    <url>/2020/01/12/Java%E5%AE%B9%E5%99%A8-Map-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h2><span id="源代码">源代码：</span></h2><p>Map是将一个键key映射到值value的对象，一个map集合不能有重复的键key,一个键key最多只能映射到一个值value。Map只是一个接口，提供接口方法规范给子类去继承和实现，Map提供的基本方法有添加、删除、获取、修改等操作Map的方法，其中使用最频繁也是我们最关系的是获取的功能，主要的方法有keySet()方法返回的是所有key值的set集合（因为Map的key是不允许重复的，所以使用set集合来存），values()方法返回的是所有value值的Conllection集合（因为value可以是重复的，没有什么要求，关键是使用者的需要，如果需要value集合没有重复的可以使用set集合来存，可以重复的可以使用list集合来存等，这都是可以的）；这里想到了一个问题：上面两个方法都是分开获取key和value的，如果想获取所有key对应的value值，那得先获取key值，再调用get(key)方法，需要进行两次操作；那么能不能同时返回包含key和value的对象呢，答案是可以的，Map接口在内部又提供了一个内部接口Entry，Entry&lt;K,V&gt;也是一个键值对映射，然后我们获取这个Entry&lt;K,V&gt;实体是通过Map提供的方法entrySet()返回的是Map.Entry&lt;k,v&gt;接口类型的set集合，包含了key和value键值对；那么获取这个set集合里面的元素也只有一个，那就是通过迭代器iterator()方法遍历获取，例如：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,String&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">"--------"</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200414214700856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414214711111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">    </p>
<h2><span id="map集合的继承结构图">Map集合的继承结构图</span></h2><p><img src="https://img-blog.csdnimg.cn/2020041421473021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="map和collection的区别">Map和Collection的区别</span></h2><p>Map的特点就是将键映射到值的对象，一个键只能对应一个值，不能存在相同的键（即不能包含重复的键，键是唯一的），值是可以相同的（值可以是重复的）。<br>Collection集合是存储元素是单独出现的，set集合是唯一的，List集合是可重复的。<br>Map集合的数据结构针对键有效，跟值无效，Collection集合的数据结构针对元素有效。</p>
<h2><span id="map的基本功能">Map的基本功能</span></h2><h3><span id="1添加功能">1.添加功能</span></h3><p><code>V Put(k,v):</code>添加元素，如果键是第一次添加的，则直接存储元素，返回null，如果键已存在，就替换原来的值，并返回原来的值。</p>
<h3><span id="2删除功能">2.删除功能</span></h3><p>Viod clear()移除所有键值对。<br>V Remove（Object key）：根据键删除值，返回被删除的值。</p>
<h3><span id="3判断功能">3.判断功能</span></h3><p><code>Boolean containsKey(Object key)：</code>判断集合是否包含指定的键。<br><code>Boolean containValue(Object value):</code>判断集合是否包含指定的值。<br><code>Boolean isEmpty():</code>判断集合是否为空</p>
<h3><span id="4获取功能">4.获取功能</span></h3><p><code>Set&lt;Map.Entry&lt;K key,V value&gt;  entrySet():</code>返回的是键值对对象的集合<br><code>V get(Object key):</code>根据键获取值<br><code>Set&lt;K&gt; keySet()</code>获取集合中所有的键的集合<br><code>Collection&lt;V&gt; values():</code>获取集合中所有值的集合</p>
<h3><span id="5长度功能">5.长度功能</span></h3><p><code>Int size（）:</code>返回集合中键值对的对数。</p>
<h2><span id="hash散列表">Hash散列表</span></h2><p>无论是Set还是Map，我们发现都会对应有HashSet和HashMap，因此先讲一下Hash散列表。  </p>
<h3><span id="散列表的工作原理">散列表的工作原理</span></h3><p>散列表为每个对象计算出一个整数（通过Hash函数计算），称之为散列码，根据这些计算出来的整数（散列码）保存在对应的位置上，它是一种存储键值对的数据结构，如果想要在其中查找一个键，需要的步骤是：</p>
<p>i. 首先使用散列函数将给定的键转化为一个“数组的索引”，理想情况下，理想的情况下不同的键会转化成不同的索引，但是实际中我们经常遇到不同的键转化为相同索引的情况，这种情况就叫做碰撞。</p>
<p>ii. 得到了索引之后，就可以像访问数组一样，通过索引访问到相应的键值对。</p>
<p>在散列表内部，我们使用桶（bucket）来保存键值对，我们前面所说的数组索引即为桶号，决定了给定的键存于散列表的哪个桶中。散列表所拥有的桶数被称为散列表的容量（capacity），在JDK1.8中桶满时，会从链表变成红黑树；如果桶容量超过了75%（装填因子为0.75）的话哈希表就会自动扩容，以双倍的桶容量新建哈希表，将原来的元素插入到新表中，TreeSet和TreeMap底层都是使用红黑树来实现的。</p>
]]></content>
      <categories>
        <category>Java容器</category>
      </categories>
      <tags>
        <tag>Map集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器-Conllection-总览</title>
    <url>/2020/01/11/Java%E5%AE%B9%E5%99%A8-Conllection-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h2><span id="1为什么需要collection">1.为什么需要Collection</span></h2><p>java是一门面向对象的语言，我们需要处理对象同时操作多个对象是先把对象们存储起来，那么我们存储对象就得需要容器如数组等，但数组只是存储同一种类型的元素，因此出现了Collection，只存引用类型来操作对象。</p>
<a id="more"></a>
<h2><span id="2数组和集合的区别">2.数组和集合的区别</span></h2><p><code>长度的区别：</code>数组的长度固定，集合的长度可变。<br><code>存储的区别</code>：数组存储的是同一类型的元素，集合可以存储不同类型的元素<br>存储的数据类型的区别：数组可以存储基本类型也可以存储引用类型，集合只能存储引用类型（对于基本类型int等会自动装箱成Integer等）</p>
<h2><span id="3collection集合的框架图">3.Collection集合的框架图</span></h2><p>集合可以存储不同的元素，这些元素之间可以不相同的，也可以按照某些规则排序</p>
<p><img src="https://img-blog.csdnimg.cn/20200414213702161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="4集合的基本功能">4.集合的基本功能</span></h2><h3><span id="a-添加功能">a. 添加功能</span></h3><p><code>Boolean add(Object obj):</code>添加一个元素<br><code>Boolean addAll(Collection c):</code>添加一个集合元素</p>
<h3><span id="b-删除功能">b. 删除功能</span></h3><p><code>Void clear():</code>移除所有的元素<br><code>Boolean remove(Object obj ):</code>移除一个元素<br><code>Boolean removeAll(Collection c):</code>移除一个集合的元素，只要一个元素被移除，就返回true。</p>
<h3><span id="c-判断功能">c. 判断功能</span></h3><p><code>Boolean contains(Object obj):</code>判断集合是否有该元素<br><code>Boolean containsAll(Collection c):</code>判断集合中是否包含指定的集合元素，只要包含所有元素，就返回true。<br><code>Boolean isEmpty():</code>判断集合是否为空。</p>
<h3><span id="d-获取功能">d. 获取功能</span></h3><p><code>Iterator&lt;E&gt; iterator():</code>迭代器</p>
<h3><span id="e-长度功能">e. 长度功能</span></h3><p><code>Int size()：</code>元素的个数</p>
<h3><span id="f-交集功能">f. 交集功能</span></h3><p><code>boolean retainAll(Collection c)</code>:移除集合中未包含指定的collection中的所有元素。</p>
<h2><span id="5迭代器iterator">5.迭代器(Iterator)</span></h2><p><img src="https://img-blog.csdnimg.cn/20200414214017870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Collection接口继承了Iterable接口，Iterable接口里面有个iterator()方法，该方法返回一个Iterator接口类型，该接口有两个抽象方法hasNext()和next()，和两个default默认方法remove()和forEachRemaining()方法【JDK1.8添加的】。<br>Iterator就是在遍历集合，所以我们遍历集合的元素都可以使用Iterator，Iterator仅是一个接口，它的具体实现是以具体集合类使用内部类的方式实现的，那么为什么将迭代器定义为接口而不是一个类呢，因为java中有很多集合类，每个集合类的数据结构都不同，存储的方式和遍历的方式也不一样，做不到通用的，所以就没有定义成迭代类，而是接口，让不同的集合类自己以内部类的形式等去实现。<br>    迭代器和集合的关系：迭代器是遍历集合的一种方式，迭代器依赖集合而存在。</p>
<h2><span id="6使用集合的步骤">6.使用集合的步骤</span></h2><h4><span id="a-创建集合对象">a. 创建集合对象</span></h4><h4><span id="b-创建元素对象">b. 创建元素对象</span></h4><h4><span id="c-将元素添加到集合">c. 将元素添加到集合</span></h4><h4><span id="d-遍历集合">d. 遍历集合</span></h4><pre><code>a. 通过集合对象获取迭代器对象
b. 通过迭代器对象的hasNext()方法判断是否有元素
c. 通过迭代器对象的next()方法获取元素并移动到下一个位置</code></pre><h2><span id="7collection集合的分类">7.Collection集合的分类</span></h2><p>Collection集合：分为三类：List集合，Set集合，queue集合；collection一个独立元素的序列，这些元素都服从一条或者多条的规则，List集合必须按照插入的顺序保存元素；Set不能有重复的元素；Queue按照排队规则来确定对象产生的顺序（通常与他们被插入的顺序相同），一端插入对象，另一端移除对象.</p>
<h3><span id="a-list接口">a. List接口:</span></h3><p>特点：有序（存储顺序跟取出顺序一样），可重复。<br>方法如下：<br><img src="https://img-blog.csdnimg.cn/20200414214231861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>list集合的迭代器ListIterator接口是对Iterator迭代器的扩展，增加了多了几个方法，可以往前遍历、添加元素、设置元素等。<br><img src="https://img-blog.csdnimg.cn/20200414214302790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>list保证将元素维护在特定的序列中，list接口在collection接口的基础上添加了大量的方法，使得可以在list中间插入和移除元素，常用的list子类有：<br><code>1.1  ArrayList</code>：底层数据结构是数组，线程不安全。List接口实现类，擅长随机访问元素，但插入和删除元素比较慢,<br><code>1.2  LinkedList</code>：底层数据结构是链表，线程不安全。List接口实现类，提供了优化的顺序访问，插入和删除元素比较快，随机访问元素比较慢。<br>                List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。<br>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）<br><code>1.3 Vector：</code>底层数据结构是数组，线程安全。 </p>
<h3><span id="b-set接口">b. Set接口：</span></h3><p>特点：元素不可重复。<br><img src="https://img-blog.csdnimg.cn/20200414214420297.png" alt="在这里插入图片描述"><br>除了TreeSet之外（多了一些方法），具有与Collection完全一样的接口，没有任何额外的功能，实际上set就是Collection，只是行为不一样（这就是继承与多态思想的典型应用：表现不同的行为），set不保存重复的元素，查找是Set里面最重要的操作，Hashset专门对快速查找做了优化，有 HashSet类、TreeSet类、LinkedHashSet类<br><code>1.3  HashSet&lt;&gt;()：</code>Set类型，使用了散列函数，没有规律，查找速度快，底层数据结构使用了哈希表（一个元素为链表的数组）<br><code>1.4  TreeSet&lt;&gt;()：</code>底层数据结构是红黑树（一个自平衡的二叉树），Set类型，将元素存储在红-黑树数据结构中，保证元素的排序方式<br><code>1.5  linkedHashSet&lt;&gt;()：</code>Set类型，也使用了散列函数，但用双链表维护元素的插入数据。底层数据结构是哈希表和双链表。</p>
<h3><span id="c-queue接口">c. Queue接口：</span></h3><p>队列–先进先出(FIFO)容器，可以安全的将对象从一个任务传输给另一个任务，在并发编程中特别重要。LinkedList也提供了方法以支持队列的行为，其实现了Queue接口；PriorityQueue优先队列，使用offer()方法是会将对象在队列中会被排序，默认使用队列中的自然顺序，调用peek()、poll()、remove()方法时，获取到的元素将是队列中优先级最高的元素。</p>
]]></content>
      <categories>
        <category>Java容器</category>
      </categories>
      <tags>
        <tag>Conllection集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-对象锁（monitor）</title>
    <url>/2019/11/03/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88monitor%EF%BC%89/</url>
    <content><![CDATA[<h2><span id="一-简介">一、简介</span></h2><p>Java提供了一种内置的锁机制来支持原子性和可见性，就是使用Synchronized的同步块或同步方法。在使用synchronized同步的时候，包含两部分：</p>
<ul>
<li>a. 一个锁对象引用</li>
<li>b. 一块锁保护的代码块<a id="more"></a>     
例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//1.同步代码块</span></span><br><span class="line">	<span class="keyword">synchronized</span>（锁对象引用）&#123;</span><br><span class="line"><span class="comment">//锁保护的代码块</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//2.同步方法</span></span><br><span class="line">	<span class="comment">//2.1锁对象引用就是被修饰方法所在的实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br><span class="line">	<span class="comment">//2.2如果是静态方法</span></span><br><span class="line">	<span class="comment">//锁对象引用就是被修饰方法所在的Class对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>每个Java对象都可以用作一个实现同步的锁，因为每个Java对象都内置了一把锁，这种锁称之为内置锁或者监视器锁（monitor），俗称对象锁。</p>
<h2><span id="二-对象的内置锁特征">二、对象的内置锁特征</span></h2><ol>
<li>互斥性<br> 同一时间最多只能有一个线程持有这种锁。<br> 线程尝试获取一个被其他线程持有的内置锁，该线程必须等待（自旋）或者阻塞（自旋策略失效），并且请求内置锁被阻塞的线程不能被中断。</li>
<li>可重入性<br>如果某个线程试图获取一个已经由它持有的内置锁，那么这个请求就会成功。<br>实现原理为：为每个锁关联一个获取计数值和锁持有者线程，当计数值为0，表示这个锁没有被任何线程持有，当一个线程请求一个未被持有的锁时，JVM会将锁持有者线程（该线程）设置为请求线程，并且将计数值置为1，如果同一个线程再次请求这个锁，则计数值自增1，退出同步方法会同步块计数值将自减1，如果计数值减为0则这个锁会被释放。</li>
</ol>
<h2><span id="三-对象锁的原理实现">三、对象锁的原理实现</span></h2><p>Synchronized关键字其实就是实现对象内置锁的方式。<br>在线程进入同步代码块之前会获取对象的monitor，也就是获取到对象的锁；在退出同步代码块的时候（正常返回或者异常退出）都会自动释放对象的锁。<br>它是怎么识别这些同步代码块的呢？<br>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（例如 synchronized 关键字括号里的锁对象引用），作为所要加锁和解锁的锁对象。<br>它是怎么知道对象锁的位置（在哪加锁和解锁的呢）？<br>无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为：<br><img src="https://img-blog.csdnimg.cn/20200411202956609.png" alt="在这里插入图片描述"><br>如图在Mark Word会默认存放hasdcode，年龄值以及锁标志位等信息。<br>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：<br><img src="https://img-blog.csdnimg.cn/20200411203022822.png" alt="在这里插入图片描述"><br>如果互斥性造成被互斥的线程怎么处理<br>一般先通过自旋处理，如果自旋处理失败了就会阻塞线程。<br>自旋的实现原理就是，如果线程请求获取监视器锁失败，并不立刻阻塞线程，而是让线程执行一个忙循环（自旋）。自旋之后再次尝试获取锁。如果获取锁失败，这个过程会循环一定次数，超过某个阀值，如果还是获取不到锁，才阻塞线程。自旋可以通过-XX:+UserSpinning参数来开启，自旋的次数通过-XX:PreBlockSpin来更改（默认是10）。<br>自旋虽然避免了线程切换的损耗，但是需要占用处理器时间。自旋的效果取决于锁被占用的时间，如果锁被占用的时间很短，自旋等待的效果就会很好，反之，自旋只会白白消耗处理器资源，带来性能上的损耗。<br>JDK1.6引入了自适应的自旋锁。<br>对象头标记字段的锁状态的转化<br><img src="https://img-blog.csdnimg.cn/20200411203036721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="四-对象锁的分类">四、对象锁的分类</span></h2><h3><span id="偏向锁">偏向锁</span></h3><p>偏向锁的目的也是消除无竞争条件下的同步原语。偏向锁会偏向于第一个获取到它的线程，如果在获取到锁之后的过程中，没有发生锁竞争，那么持有偏向锁的线程将永远不需要再进行同步。相比轻量级锁，偏向锁能够消除轻量级锁多次加锁的CAS操作。<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li>a. 偏向锁的获取</li>
</ul>
<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 JVM会通过 CAS 操作，将当前线程的ID记录在锁对象的标记字段之中，并且将标记字段的锁标志位置为“01”，即偏向模式。<br>如果操作成功，在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101，是否包含当前线程的ID，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。<br>当有另外的线程尝试获取这个锁时，偏向模式宣告结束。如果当前对存于未锁定状态，撤销偏向恢复至未锁定（标记字段的锁标志位为“01”）。如果处于锁定状态，则升级为轻量级锁（标记字段的锁标志位为“00”），后续的同步操作便按照轻量级锁的规则来进行。</p>
<ul>
<li>b. 偏向锁的撤销</li>
</ul>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br><img src="https://img-blog.csdnimg.cn/2020041120320646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。<br><img src="https://img-blog.csdnimg.cn/20200411203219732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>c. 偏向锁的失效</li>
</ul>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。<br>如果某一类锁对象的总撤销数超过了一个阈值（对应JVM参数-XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 JVM会宣布这个类的偏向锁失效。<br>如果总撤销数超过另一个阈值（对应 JVM参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
<h3><span id="轻量级锁">轻量级锁</span></h3><p>轻量级锁的目标是在没有多线程的竞争下，减少重量级锁使用的操作系统互斥量产生的性能消耗。</p>
<ul>
<li>a. 加锁</li>
</ul>
<p>当进行加锁操作时，JVM会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录（Lock Record），并且将锁对象的标记字段复制到该锁记录中。<br>然后，JVM会尝试用 CAS（compare-and-swap）操作将锁对象的标记字段替换为锁记录的指针。如果操作成功，那么这个线程就获取了这个对象的锁，并且标记字段的锁标志位转变为“00”，表示该锁处于轻量级锁定状态。如果标记字段替换操作失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。JVM会先检查对象的标记字段是否指向当前线程的栈帧，如果是表明当前线程已经持有了该对象的锁。否则说明这个对象的锁已经被其它线程所持有了，这时，轻量级锁膨胀为重量级锁，锁的标记字段的锁标志位变为“10”，标记字段存储的就是指向重量级锁（互斥量）的指针，后面的线程要进入阻塞状态。</p>
<ul>
<li>b. 解锁</li>
</ul>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://img-blog.csdnimg.cn/20200411203341249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3><span id="重量级锁">重量级锁</span></h3><p>重量级锁是 JVM中传统的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>
<h2><span id="五-各种锁的比较">五、各种锁的比较</span></h2><p><img src="https://img-blog.csdnimg.cn/20200411203352349.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-JMM内存模型</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2><span id="一-什么是jmm内存模型">一、什么是JMM内存模型</span></h2><p>Java内存模型即 Java Menory Model，简称JMM。JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方法。JVM是整个计算机虚拟模型，所以JMM隶属于JVM的。<br>    Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此在Java1.5版本对其进行了重构，现在的Java8仍沿用了1.5的版本。 模型如下：<br><img src="https://img-blog.csdnimg.cn/20200411194726969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>     

<h2><span id="二-java内存模型与并发编程的关系">二、Java内存模型与并发编程的关系</span></h2><p>如果想要深入了解Java并发编程，就要先理解好Java内存模型。</p>
<h3><span id="并发编程的模型分类">并发编程的模型分类</span></h3><p>总共分成两类：</p>
<ul>
<li>共享内存并发模型</li>
<li>消息传递并发模型</li>
</ul>
<h3><span id="在并发编程中的关键问题">在并发编程中的关键问题</span></h3><ul>
<li>线程之间如何通信</li>
<li>线程之间如何同步</li>
</ul>
<p>通信是指线程之间以何种机制来交换信息，在命令式编程中（编程主要分类：允许有副作用的命令式编程，不允许有副作用的函数式编程和不描述操作执行顺序的声明式编程），线程之间的通信机制有两种：</p>
<ul>
<li>共享内存：在共享内存的并发模型里，线程之间共享程序的公共状态（共享变量），线程之间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递：在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信</li>
</ul>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制，有两种方式：</p>
<ul>
<li>共享内存：同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li>
<li>消息传递：由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</li>
</ul>
<p>Java里面的并发就是采用共享内存的并发模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员是完全透明的（即你是看不见就发生了并发过程）。</p>
<h3><span id="java的并发模型采用的是共享内存模型">Java的并发模型采用的是共享内存模型</span></h3><p>Java线程之前的通信总是隐式进行的，整个通信过程对程序员完全透明。如果编写多线程程序不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2><span id="三-java内存模型的抽象">三、Java内存模型的抽象</span></h2><p>在Java中的共享变量有：所有实例域和数组元素存储在堆内存中，堆内存在线程之间共享（方法区也是线程共享，方法区保存类信息【类名称，方法，字段属性】，常量和静态变量 ）。局部变量、方法定义参数和异常处理器参数不会再线程之间共享，他们不会有内存可见性的问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（JMM）控制。JMM决定了一个线程对共享变量的写入时对另一个线程可见。从抽象的角度来看，JMM定义了线程与主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不是真实存在。<br>JMM抽象模型图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195125640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从图上看，如果线程A要和线程B通信的话，所经历的步骤是：</p>
<ul>
<li>线程A需要将本地内存A中的共享变量副本刷新到主内存中去</li>
</ul>
<ul>
<li>线程B去主内存中读取线程A之前已经更新过的共享内存</li>
</ul>
<p>步骤图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195255403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整体看，这两个步骤实质上是线程A在向线程B发送消息，而这个通信过程必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为我们提供内存的可见性保证。</p>
<h3><span id="重排序带来的并发问题">重排序（带来的并发问题）</span></h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p>
<ul>
<li>编译器优化的重排序（编译器重排序）。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序（处理器重排序）。现代处理器<br>采用了指令级并行技术将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序。</li>
<li>内存系统的重排序（处理器重排序）。由于处理器使用缓存和读写缓存，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="https://img-blog.csdnimg.cn/20200411195837536.png" alt="在这里插入图片描述"><br>上面的重排序可能会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则则会禁止特定类型的编译器重排序（并不是所有的编译器重排序都要禁止），对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br> JMM属于语言级的内存模型，它确保在不同的编译器和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为我们提供一致的内存可见性保证。还有就是重排序（包括编译器和处理器重排序）必须遵守as-if-serial规则（解决编译器重排序问题），该语义也就是说不管怎么排序，单线程程序执行的结果都不能改变；让人感觉单线程程序是按程序的顺序执行的，如果多个线程操作之间没有数据的依赖性则是允许重排序的，但是如果存在数据的依赖，则不会重排序的，这一点的问题是有保证的，所以现在的主要问题是，处理器使用缓存来读写数据，会导致数据读取不一，带来一种代码指令被重排序的感觉，对于共享变量，很容易出现问题。</li>
</ul>
<h4><span id="编译器重排序">编译器重排序</span></h4><p>编译器重排序的定义为：如果两个操作它们之间没有任何的依赖关系，也就是说A操作的结果和B操作的结果相互间没有任何的影响，此时编译器就可以对这两个操作进行重排序，如果两个操作共同操作一个共享变量，其中有一个操作为写，那么它们两是有数据依赖性的，从重排序会对最终执行结果产生影响，所以编译器重排序（也包括处理器重排序）都会遵循数据依赖性，编译器和处理器不会改变存在依赖关系的两个操作的执行顺序</p>
<h4><span id="处理器重排序">处理器重排序</span></h4><p>现在的处理器使用写缓冲区来临时保存向内存写入的数据。写缓存区可有保证指令流水想般持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟，同时通过批处理方式刷新写缓存区，以及合并写缓存区中对同一内存地址的多次写，可以减少对内存总线的占用，。虽然写缓存区有这么多的好处，但是每个处理器上的写缓存区，仅仅对它所在的处理器可见，这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读写操作的执行顺序，不一定与内存实际发生的读写操作顺序是一致的。<br>举个例子：a，b变量为共享变量，两个处理器项目访问共享变量。<br><img src="https://img-blog.csdnimg.cn/20200411200004201.png" alt="在这里插入图片描述"><br> 初始状态：a=b=0;<br>处理器允许执行后可能得到的结果：x=y=0;<br>具体原因如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411200042338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
<p>出现的一个执行顺序：<br>处理器A和处理器B同时把共享变量写入在写缓冲区中（A1，B1步骤），然后再从主内存中读取另一个共享变量的值（A2,B2步骤），最后才把自己写缓冲区中保存的脏数据刷新到主内存中（A3,B3步骤）。但最后执行下来就会得到一个结果：x=y=0。<br>    从实际理想的发生的顺序来看，正常执行顺序是这样的：<br>    直到处理器A执行了A3步骤之后已经刷新自己的写内存，写操作A1才算真正被执行，然后接着读A2。即发生的顺序：A1-&gt;A2.<br>    但内存操作实际发生这种可能：A2–&gt;A1。此时处理器A的内存操作顺序被重排序了。由于写缓存区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一样。由于现在的处理器都会使用写缓存区，因此都会允许对读写操作指令进行重排序。</p>
<h3><span id="内存屏障指令解决处理器重排序问题">内存屏障指令（解决处理器重排序问题）</span></h3><p>为了解决上面说的重排序问题，需要保证内存的可见性，可以使用内存屏障来达到这个效果，通过在适当位置插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为以下四类：</p>
<ul>
<li>a. LoadLoad屏障<br> 适用场景：Load1;LoadLoad;Load2<br> Load1和Load2代表两条读指令。在Load2读取指令装载之前，确保Load1读指令已经装载完毕。</li>
<li>b. StoreStore屏障<br>适用场景：Store1;StoreStore;Store2<br>Store1和Store2代表两条写指令。在Store2写指令的存储之前（刷新到内存中），确保Store1写指令的数据对其他处理器可见（刷新到内存中）</li>
<li>c. LoadStore屏障<br> 适用场景：Load1；LoadStore；Store2<br> 在Store2写指令的存储之前（刷新到内存中），确保Load1读指令已经装载读取完毕。</li>
<li>d. StoreLoad屏障<br>使用场景：Store1;StoreLoad;Load2<br>在Load2读指令装载之前，确保Store1写指令的数据对其他处理器可见（刷新到内存中），开销最大；该屏障会使之前的所有内存访问指令（存储和状态指令）完成之后，才执行该屏障之后的内存访问指令。</li>
</ul>
<h3><span id="happens-before规则定义两个操作之间的执行顺序利用内存屏障指令提供内存可见性的保障">happens-before规则（定义两个操作之间的执行顺序，利用内存屏障指令提供内存可见性的保障）</span></h3><p>JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另外一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作可以是一个线程内的，也可以是不同线程之内的。<br>与程序员密切相关的happens-before规则（共有八大规则）如下：<br>(注意，两个操作之间具有happens-before关系，并不意味这一个操作必须在后一个操作之前执行，happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见。且前一个操作（执行的结果）按顺序排在第二个操作之前。)</p>
<ul>
<li>a.程序顺序规则：两个操作之间存在happens-before关系，那么第一个操作的结果对第二个操作可见并且第一个操作的执行顺序在第二个操作之前。</li>
<li>b. 监视器锁规则：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。</li>
<li>c. volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>d.  传递性规则：如果 A  happens-before B,且B happens-before C,则A<br>happens-before C.</li>
<li>e.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>f.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>g. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>h. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ul>
<h3><span id="总结一下">总结一下</span></h3><p>解决重排序问题主要两种规则：as-if-serial（解决编译器重排序）和happens-before（解决处理器重排序）</p>
<ul>
<li>a.As-if-serial规则保证单线程程序的执行结果不被改变，happens-before规则保证正确同步的多线程程序的执行结果不会被改变</li>
<li>b.as-if-serial规则给我们一种感觉：单线程程序是按照程序顺序来执行的，而happens-before规则是正确同步的多线程程序是按照happens-before指定的顺序来执行的，</li>
<li>c. as-if-serial和happens-before规则都是为了在不改变程序执行结果的前提下，尽可能的提高程序的执行并行度。            </li>
</ul>
<h2><span id="四-jmm在实际开发中遇到的问题及解决方法">四、JMM在实际开发中遇到的问题及解决方法</span></h2><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要有两个问题：</p>
<ul>
<li><p>a. 共享对象对各个线程的可见性（使用volatile关键字解决）</p>
</li>
<li><p>b. 共享对象的竞争现象（使用同步锁解决）</p>
</li>
</ul>
<p>我们在实际的多线程开发中需要从原子性、可见性、有序性这三方面进行考虑，有序性的话JMM已经帮我们基本优化了，重点看一下原子性和可见性</p>
<h3><span id="共享对象的可见性锁以synchronized为例">共享对象的可见性（锁以synchronized为例）</span></h3><p>当多个线程同时操作一个共享对象时，如果没有合理的使用volatile和synchronized关键字，一个线程对共享对象的更新有可能导致其他线程不可见。 我们的共享对象存储在主内存中，一个CPU的线程去读取主内存的数据到CPU缓存中，然后对共享内存做了更改，但CPU缓存中的更改后的对象还没有刷新到主内存中，此时其他线程对共享对象的更改是不可见的，最终每个线程都会拷贝共享变量位于不同的CPU缓存中。要解决这个可见性问题，我们可以使用Java volatile关键字，volatile关键字可以保证共享变量会直接从主内存中读取，而对共享变量也会直接写到主内存中去。volatile原理是基于CPU内存屏障实现的。</p>
<h3><span id="竞争现象锁以sybchronized为例">竞争现象（锁以sybchronized为例）</span></h3><p>如果多个线程共享一个对象，它们同时修改这个共享对象，这就产生了竞争关系。例如线程A和线程B共享一个对象，线程A从主内存中读取共享对象到CPU缓存中，同时，线程B也同时读取共享对象到它的CPU缓存中，线程A和B同时对该共享变量做相同的操作（如同时进行+1操作，对象初始值为1），不管线程A或B有没有刷新到主内存中，并行执行，结果都会出错（相加了两次，结果却为2）。要解决这种竞争关系问题，我们可以使用java中的synchronized代码块，synchronized代码块可以保证同一时刻只有一个线程进入到代码竞争区，synchronized代码块也能保证代码块中所有变量都是从主内存中读，当线程退出的时候，对所有变量的更新都将会flush到之内存中，不管这些变量是不是volatile类型的。</p>
<h3><span id="volatile和锁synchronizedlock">volatile和锁（synchronized，Lock）</span></h3><p>对于一个volatile变量的单个读/写操作，与对一个普通变量的读写操作使用同一个锁来同步，它们之间的执行效果时相同的（因为它们都是从主内存中读写变量的）。<br>相同点：</p>
<ul>
<li>a.可见性。锁的happens-before规则是保证释放锁和获取锁的两个线程之间的内存可见性，这跟volatile的可见性是一样的：对于一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>b.原子性。锁的语义（同步）就决定了临界区代码的执行具有原子性，跟volatile一样，对于volatile变量的读取也具有原子性，但是对于多个volatile操作（类似于volatile++这种复合操作）就不具备原子性。</li>
</ul>
<p>（原子性就是在执行的过程中不会被中断，一次执行的，不会被其他线程干扰）</p>
<p>不同点：</p>
<ul>
<li>c. volatile：读写内存定义<br> 当读一个volatile变量的时候，JMM会把线程对应的本地内存置为无效，线程将从主内存中读取共享变量。<br> 当写一个volatile变量的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</li>
</ul>
<p>volatile语义的实现：<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>a. 在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>b. 在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>c. 在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>d. 在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>因为确保写操作内存可见，所以前面的写和后面的读写都不能重排序（按照原来的顺序来执行）<br>因为确保别的线程读正确，所以后面的读写指令都不能重排序（必须确保volatile读完后才操作，为了可见性）<br>具体插入内存屏障后生成的指令示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411200926802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这种volatile读写操作的内存屏障是非常保守的，在实际执行过程中，只要不改变volatile读写的定义，编译器可以根据具体情况省略不必要的屏障。</p>
<ul>
<li>d. 锁：锁释放和锁获取的内存定义<br>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li>
</ul>
<p>锁内存定义的实现：<br>锁有很多，包括ReentrantLock，Synchronized，公平锁，非公平锁，AQS等等，现在借助ReentrantLock来说明一下锁内存定义的实现。<br>首先是concurrent包的实现：<br>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>a. 首先声明共享变量为volatile</li>
<li>b. 然后使用CAS的原子条件更新来实现线程之同步</li>
<li>c. 同时配合以volatile的读写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信</li>
<li>d. AQS</li>
<li>e. 非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类）</li>
</ul>
<p>这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411201135105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="五-总结">五、总结</span></h2><h3><span id="jmm的设计示意图">JMM的设计示意图</span></h3><p><img src="https://img-blog.csdnimg.cn/20200411201319944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>a.JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A<br>happens-before B）。</li>
<li>b.<br>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h3><span id="java程序的内存可见性保证">Java程序的内存可见性保证</span></h3><ul>
<li><p>a.单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同</p>
</li>
<li><p>b.正确同步多线程程序。正确的同步多线程与该程序在顺序一致性内存模型中执行的结果相同。JMM通过限制编译器和处理器的重排序来为我们提供内存可见性保证。</p>
</li>
<li><p>c.未同步/未正确同步的多线程程序。JMM为它们提供了最小的安全保证：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200411201341702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
</li>
</ul>
<h3><span id="最后">最后</span></h3><p>从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如i++不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。J.U.C包下的并发工具类和并发容器也是需要花时间去掌握的。</p>
<p>附录：<br>硬件内存架构<br>不管什么内存模型最终还是运行在硬件上，我们必须了解一个计算机的硬件内存。计算机架构图：<br><img src="https://img-blog.csdnimg.cn/2020041120135981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在计算机都有多个CPU,每个CPU又有多个核心，多线程就可以在各个不同的CPU核心中运行。<br>在CPU内部有一组CPU寄存器，也就是CPU的存储器，CPU操作寄存器的速度要比操作计算机的主内存快得多，所以为了提高效能，主内存和寄存器之间就存在一个CPU缓冲区，CPU操作缓冲区的速度快于主内存但慢于CPU寄存器，某些CPU可能有多个缓存区（一级缓存和二级缓存）。计算机的主内存也叫RAM，所有的CPU都能访问主内存，主内存比CPU缓存和CPU寄存器还要大得多。<br>当一个CPU需要访问主内存的时候，会先读取一部分主内存数据到CPU缓存，进而再读取CPU缓存到CPU寄存器。<br>当CPU需要写数据到主内存时，同样也会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主内存中。<br>Java内存模型和硬件内存架构之间的桥接<br>    <img src="https://img-blog.csdnimg.cn/20200411201410856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Java内存模型和硬件内存架构并不一样，硬件内存架构并没有区分栈和堆，从硬件上看，不管时栈还是堆，大部分数据都会存到主内存中，还可能一部分堆和栈数据存在CPU寄存器上。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-线程的基本状态和操作</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><p>线程拥有自己的生命周期，一条线程从创建到执行完毕的过程就是线程的生命周期，那么在线程的生命周期的每个过程中可能在不同的时候处于不同的状态，用状态来描述生命周期那是最好不过了。<br>那么线程的生命周期到底有多少种状态呢，它们不同的状态又是如何通过状态的转化操作来完成线程的生命周期呢，下面就按照线程的生命周期的状态和状态之间的转换操作来详细说明。</p>
<a id="more"></a>
<h2><span id="二-线程的基本状态">二、线程的基本状态</span></h2><p>线程的状态没有严格的定义，可以先简单划分以下几个基本状态：<br>    <img src="https://img-blog.csdnimg.cn/20200411192919905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图中的五种状态描述如下：<br>a. New（新建）状态：一个线程被创建了但未被启动就处于新建状态，即在程序中使用new Thread()创建的线程实例就处于新建状态。<br>b. Runnable(可运行)状态：创建的线程实例通过调用start（）方法之后该线程就处于可运行状态，处于此状态的线程不一定说处于运行状态，Java多线程使用的线程调度策略是抢占式调度，每个可运行线程轮着获取CPU时间片，可以想象成一个可运行线程池，start()方法就是把一个线程放进可运行线程池中，CPU按照一定规则一个个执行线程池里面的线程。<br>c. Running（运行）状态：当可运行线程获取到CPU执行时间片就立即进入运行状态。<br>d. Not Running（非运行）状态：运行中的线程因某种原因暂时放弃CPU的使用权，可能是因为只执行了挂起、睡眠或者等待操作；在执行IO操作时，由于外部设备速度远低于处理器速度也可能导致线程暂时方法CPU使用权；在获取对象的同步锁的过程中如果同步锁被其他线程获取了，这样也会导致线程暂时放弃CPU的使用权了。<br>e. Dead(死亡)状态：线程执行完run()方法的任务之后，或者因为异常而导致退出任务，线程就进入死亡状态，该状态下是不能转换成其他状态了。</p>
<h2><span id="三-线程的状态转换">三、线程的状态转换</span></h2><p>在上面的五个状态中，是通过这些基本操作来完成状态之间的转换，基本操作配合五种状态就完成了线程的交替运行，把Not Running状态分成：Blocked（阻塞）、Waiting（等待）和Timed_Waiting(超时等待)这三个状态（以Synchronized锁及相关方法为例），如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411193016770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Blocked(阻塞)状态：当线程出现资源竞争，等待获取同步锁时，线程就会进入阻塞状态，直到线程获取到了锁，线程才会进入可运行状态。</li>
<li>Waiting(等待)状态：运行中的线程执行了Object.wait(),Thread.join(),LockSupport.park()等方法或者被其他线程调用interrupt()中断方法的时候就会进入等待状态，便进入了等待线程队列，如果有锁会释放锁，当在其他线程中调用对象的notify(),notifyAll(),LockSupport.unpart()方法就会唤醒等待线程队列中的线程，notify是随机唤醒一个线程，notifyAll是唤醒所有线程，唤醒后的线程会对该对象的monitor占有权竞争，获得占有权的线程才能转化为可运行状态。</li>
<li>Timed_Waiting(超时等待)状态：在wait(long),sleep(long),join(long)和LockSupport.partNanos(long),LockSupport.partUntil(long)方法中都加入了超时，调用这些方法设置超时时间后线程会进入超时等待状态，同时会把占有的锁释放；如果调用了notify(),notifyAll(),LockSupport.unpart()方法或者超时时间到了，线程就会被唤醒，重新对该对象的monitor占有权竞争，获得占有权的线程才会转化为可运行状态</li>
</ul>
<h2><span id="四-线程的基本操作">四、线程的基本操作</span></h2><p>从上面的图可以看出，线程的基本操作就是为了完成线程状态之间的转化，同时还是线程间的通信方式。</p>
<h3><span id="新建线程">新建线程</span></h3><p>新建线程的方式有三种：</p>
<ul>
<li>重写Runnable接口的run()方法创建线程（Thread类实现了Runnable接口，两者启动线程都是通过Thread类，运行的目标线程是Runnable类型的，所以只要是Runnable的子类都可以通过Thread类来启动线程）:<br><strong>i.</strong> 创建Thread类型对象，同时重写run()方法，然后通过Thread类启动线程<br><strong>ii.</strong> 创建Runnable类型对象，同时实现run()方法，然后通过Thread类启动线程</li>
<li>重写Callable接口的call()方法实现创建线程，由于含有回调的方法，所以配合FutureTask类可以实现异步结果返回效果（FutureTask类实现了RunnableFuture接口【该接口又继承了Runnable接口和Future接口】）<br>i. 创建Callable类型对象，同时实现call()方法，然后创建FutureTask类对象并传入Callable类型对象同时指定返回值类型，然后通过Thread类启动线程。</li>
<li>利用线程池Excutor创建线程（推荐使用这种）。ExcutorService接口含有submit()方法，参数可以是Callable接口类型和Runnable接口类型；若<br>参数是Callable接口类型，返回的是Future接口类型，可以使用Executors工具类来创建ExcutorService类型对象，然后使用ExcutorService对象调用Callable接口实现类，最后使用Future接收返回的结果。若参数是Runnable接口，则直接调用即可。（后面会专门分析FutureTask类和Excutors工具类）</li>
</ul>
<p>代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020/2/26</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@desc</span> 创建线程的方式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * 方法一：通过创建Thread类型对象，同时重写run()方法</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span>  Thread()&#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Thread类型对象，同时重写run()方法。。。"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;.start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式二：通过创建Runnable类型对象,同时实现run()方法</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Runnable类型对象,同时实现run()方法"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;).start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式三：通过实现Callable接口并实现call()方法,并异步返回执行结果</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        FutureTask&lt;String&gt; result=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过实现Callable接口并实现call()方法,并异步返回执行结果"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程执行完成"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">	        System.out.println(<span class="string">"callable接口执行返回的结果："</span>+result.get());</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式四：通过线程池来创建（只列举实现Callable接口）</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">	        FutureTask&lt;String&gt; result1= (FutureTask&lt;String&gt;) service.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line">	</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过线程池方式创建线程"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程池执行Callable的call方法返回的结果"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        System.out.println(<span class="string">"线程池返回的结果："</span>+result1.get());</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="其他对于线程的操作方法">其他对于线程的操作方法</span></h3><p>可以参考：Java-并发理论-源码分析-Thread类:常用方法（主要是操作线程的方法）<br>列举一下join()方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        Thread previousThread = Thread.currentThread();</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	            Thread curThread = <span class="keyword">new</span> JoinThread(previousThread);</span><br><span class="line">	            curThread.start();</span><br><span class="line">	            previousThread = curThread;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">private</span> Thread thread;</span><br><span class="line">	</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                thread.join();</span><br><span class="line">	                System.out.println(thread.getName() + <span class="string">" terminated."</span>);</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                e.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程，直到for循环执行完了，main线程执行完了，就会从上往下一个个继续执行。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-首页</title>
    <url>/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<h2><span id="简介">简介：</span></h2><p>基本包含了Java并发编程的知识内容同时囊括并发Concurrent包的重点源码分析，如有问题欢迎评论指出，谢谢支持！<br>关注微信公众号获取更多知识：当代猿</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200409181814334.png#pic_center" alt="微信公共号二维码"></p>
<h2><span id="思维导图">思维导图：</span></h2><p><img src="https://img-blog.csdnimg.cn/20200409181910892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：思维导图链接，待完成后一起公布。</p>
<h2><span id="目录">目录：</span></h2><p>说明：目录会持续更新</p>
<ol>
<li>Java-并发编程-认识并发编程</li>
<li>Java-并发基础-线程的基本状态和操作</li>
<li>Java-并发理论-JMM内存模型</li>
<li>Java-并发理论-对象锁（monitor）</li>
<li>Java-并发理论-关键字-synchronized</li>
<li>Java-并发理论-关键字-volatile</li>
<li>Java-并发理论-关键字-final</li>
<li>Java-并发理论-三大特性</li>
<li>Java-并发理论-源码分析-Thread类</li>
<li>Java-并发concurrent包-简介</li>
<li>Java-并发concurrent包-atomic包</li>
<li>Java-并发concurrent包-locks包</li>
<li>Java-并发工具-并发容器-ConcurrentHashMap</li>
<li>Java-并发工具-并发容器-CopyOnWriteArrayList</li>
<li>Java-并发工具-并发容器-CopyOnWriteSet</li>
<li>Java-并发工具-并发容器-阻塞队列</li>
<li>Java-并发工具-线程池-原理&amp;ThreadPoolEcecutor</li>
<li>Java-并发工具-线程池-原理&amp;ScheduledThreadPoolExecutor</li>
<li>Java-并发工具-基本类FutureTask</li>
<li>Java-并发工具-工具类Excutors</li>
<li>Java-并发工具-工具类CountDownLatch</li>
<li>Java-并发工具-工具类CyclicBarrier</li>
<li>Java-并发工具-工具类Semaphore</li>
<li>Java-并发工具-工具类Exchanger</li>
<li>Java-并发实践-生产者与消费者</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发首页</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-认识并发编程</title>
    <url>/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><h3><span id="什么是并发">什么是并发</span></h3><p>在Java中并发就是指多线程的进程环境，进程是系统进行资源分配和调度的独立单位，每一个进程都有它的内存空间和系统资源，在同一个进程内执行的多个任务就可以看作是多个进程，线程存在于进程内，进程负责分配调度线程，线程负责执行程序，多个线程就执行多个程序。<br>实际上，Java程序天生就是一个多线程程序，包含了：</p>
<ul>
<li>分发处理发送给JVM信号的线程</li>
<li>调用对象的finalize清除方法的线程</li>
<li>清除相互引用reference的线程</li>
<li>main线程，也就是用户程序的入口，main线程里面还可以拥有很多的子线程<a id="more"></a>
<h3><span id="为什么需要多线程">为什么需要多线程</span></h3>如果没有多线程，若为了使程序并发执行，那么系统需要花费大量的时间在：创建进程–&gt;撤销进程–&gt;进程上下文切换调度,在这一过程中，需要的空间开销也非常大，执行效率也非常低（如下图）；若在一个进程中执行多个线程，则上面的空间开销和时间花费将会大大较少，何乐而不为呢，多线程提高了系统的执行效率，充分利用多核CPU的计算能力，提高应用性能。<br><img src="https://img-blog.csdnimg.cn/20200411183436680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2><span id="二-并发编程带来的问题">二、并发编程带来的问题</span></h2></li>
</ul>
<h3><span id="频繁的上下文切换问题">频繁的上下文切换问题</span></h3><p>正如上图中的时间片，时间片使CPU分配给各个线程的时间，因为时间非常短，所以CPU需要不断切换线程，让我们觉得多个线程是同时执行的，时间片一般是十几毫秒；每次切换都需要保存当前线程的状态，以便进行恢复先前的状态。这个切换是非常耗性能的，过于频繁就无法发挥出多线程编程的优势了。那么该怎么解决这频繁的上下文切换的问题的，目前有大概几种解决方法，后面会详细讨论：</p>
<ol>
<li>采用无锁并发编程：JDK8以前的concurrentHashMap采用的锁分段思想，不同线程处理不同段的数据，这样在多线程环境下可以减少上下文的切换时间。</li>
<li>采用CAS算法：JDK8以后的concurrentHashMap采用的是无锁CAS算法；利用Atomic和乐观锁，可以减少一部分不必要的锁竞争带来的上下文切换。</li>
<li>尽量减少线程的使用：避免创建不需要的线程，比如任务少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态。</li>
<li>采用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。<br>因此，并发累加未必会比串行累加的速度快，这上下文切换的问题在实际中是需要解决的。</li>
</ol>
<h3><span id="线程安全问题主要问题也是我们程序开发关心的问题">线程安全问题（主要问题，也是我们程序开发关心的问题）</span></h3><p>对线程编程中最难控制的就是临界区（共享内存的地方）的线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。那么怎么解决这种问题呢，解决方法如下：</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内部占用多个资源，尽量保证一个锁只占用一个资源</li>
<li>尝试使用定时锁，如使用lock.tryLock(timeOut),当超时等待时当前线程也不会阻塞</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里（同一个事务），否则会出现解锁失败的情况<br>后面还有JMM内存模型在原子性、有序性和可见性带来的问题，比如数据脏读，内存泄漏等等问题，这是又该如何保证线程安全呢，这一方面是非常重要的，后面会详细讨论。</li>
</ul>
<h2><span id="三-并发编程的相关概念">三、并发编程的相关概念</span></h2><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步通常用来形容方法的一次调用。<br>同步方法从被调用开始，调用者就必须等待被调用的方法结束后，调用者后面的代码才能继续执行。<br>异步方法指的是，调用者不管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。</p>
<h3><span id="并发和并行">并发和并行</span></h3><p>并发是指多个任务线程交替进行。<br>并行是指真正意义上的“同时进行”。<br>实际上，如果系统只有一个CPU，而使用多线程时，那么真实环境下时不能并行执行的，只能通过切换时间片的方式交替进行，完成并发执行任务，真正的并行只能出现在拥有多个CPU系统中。</p>
<h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。<br>阻塞是指如果一个线程占用了临界区的资源，那么其他线程需要这个资源的话就必须等待资源的释放，就会导致等待的线程挂起，这种情况就叫做阻塞。<br>非阻塞刚好跟阻塞相反，它强调的是没有一个线程可以阻塞其他线程，所有的线程都会尝试的向前运行。</p>
<h3><span id="临界区">临界区</span></h3><p>临界区用来表示一种公共资源会共享数据，可以被多个线程使用，出于线程安全问题，如果一个线程占用了临界区的资源，那么其他线程就必须等待，知道临界区的资源被释放。</p>
<h3><span id="守护线程">守护线程</span></h3><p>守护线程是一种特殊的线程，是系统的服务线程，是专门为其他线程服务的，像垃圾回收线程就是守护线程，与之对应的是用户线程，用户线程作为系统的工作线程，守护线程的服务对象就是用户线程，当全部的用户线程执行任务完成之后，这个系统就没有什么需要服务的了，那么守护线程就没有对象需要守护了，那么守护线程就会结束，也就是说当一个java程序只有守护线程的时候，虚拟机就会退出了。</p>
<h2><span id="四-java中的线程thread类">四、Java中的线程Thread类</span></h2><p>参考看一下Thread类的源码注释，了解Java中的线程，有专门对Thread类的源码做分析：Java-源码分析-Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1.一个Thread类对象代表程序中的一个线程，jvm是允许多线程的</span></span><br><span class="line"><span class="comment">	 * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment">	 * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment">	 * execution running concurrently.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.每一个线程都有优先级，具有高优先级的线程优先于底优先级的线程执行，每一个线程都可以设置成一个守护线程，创建线程的时候，通过线程设置setDaemon(true)就可以设置该线程为守护线程，设置守护线程需要先于start()方法</span></span><br><span class="line"><span class="comment">	 * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment">	 * executed in preference to threads with lower priority. Each thread</span></span><br><span class="line"><span class="comment">	 * may or may not also be marked as a daemon. When code running in</span></span><br><span class="line"><span class="comment">	 * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment">	 * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment">	 * creating thread, and is a daemon thread if and only if the</span></span><br><span class="line"><span class="comment">	 * creating thread is a daemon.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.只有当一个Java程序只存在守护线程的时候，虚拟机就会退出，让虚拟机不继续执行线程的方法有：</span></span><br><span class="line"><span class="comment">		2.1调用system.exit方法.</span></span><br><span class="line"><span class="comment">		2.2所有非守护线程都处于死亡状态（只有守护线程）或线程运行抛出了异常</span></span><br><span class="line"><span class="comment">	   注意：在线程启动前可以将该线程设置为守护线程，方法是setDaemon(boolean on)</span></span><br><span class="line"><span class="comment">		     使用守护线程最好不要在方法中使用共享资源，因为守护线程随时都可能挂掉</span></span><br><span class="line"><span class="comment">		     在守护线程中产生的线程也是守护线程</span></span><br><span class="line"><span class="comment">	 * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment">	 * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment">	 * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment">	 * occurs:</span></span><br><span class="line"><span class="comment">	 * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment">	 *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment">	 *     to take place.</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment">	 *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment">	 *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 *     method.</span></span><br><span class="line"><span class="comment">	 * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	3.创建线程的方式有两种（重写Runnable接口的run()方法）：</span></span><br><span class="line"><span class="comment">		3.1创建子类并继承Thread 类，同时重写run()方法（因为Thread类实现了Runnable接口）</span></span><br><span class="line"><span class="comment">		3.2创建子类并实现Runnable接口，同时重写run()方法</span></span><br><span class="line"><span class="comment">		下面有例子：</span></span><br><span class="line"><span class="comment">	 * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment">	 * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment">	 * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment">	 * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment">	 * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment">	 *     p.start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment">	 * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment">	 * style looks like the following:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment">	 *     new Thread(p).start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	4.每个线程都有一个名称，如果没有会在创建的时候自动生成一个，除非指定为null。</span></span><br><span class="line"><span class="comment">	 * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment">	 * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment">	 * a thread is created, a new name is generated for it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment">	 * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment">	 * thrown.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="五-总结">五、总结</span></h2><p>我们需要了解并发，为什么需要并发，还必须知道并发的优缺点，同时清楚使用并发编程之后所带来的问题：频繁上下文切换问题和线程安全问题等等，后面在并发编程的时候就朝着这些问题去编程，尝试解决这些问题，让并发编程发挥出真正的作用。<br>理解Java并发的关键点在于理解它的两大核心（JMM内存模型【工作内存和主内存】和happes-before规则【八大规则】）以及三大特性：原子性、可见性、有序性</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java并发基础</tag>
      </tags>
  </entry>
</search>
