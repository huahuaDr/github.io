<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-动态代理</title>
    <url>/2020/01/15/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-反射</title>
    <url>/2020/01/15/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-atomic包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-atomic%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title> Java-并发concurrent包-locks包</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-locks%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发concurrent包-简介</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-JMM内存模型</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2><span id="一-什么是jmm内存模型">一、什么是JMM内存模型</span></h2><p>Java内存模型即 Java Menory Model，简称JMM。JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方法。JVM是整个计算机虚拟模型，所以JMM隶属于JVM的。<br>    Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此在Java1.5版本对其进行了重构，现在的Java8仍沿用了1.5的版本。 模型如下：<br><img src="https://img-blog.csdnimg.cn/20200411194726969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>     

<h2><span id="二-java内存模型与并发编程的关系">二、Java内存模型与并发编程的关系</span></h2><p>如果想要深入了解Java并发编程，就要先理解好Java内存模型。</p>
<h3><span id="并发编程的模型分类">并发编程的模型分类</span></h3><p>总共分成两类：</p>
<ul>
<li>共享内存并发模型</li>
<li>消息传递并发模型</li>
</ul>
<h3><span id="在并发编程中的关键问题">在并发编程中的关键问题</span></h3><ul>
<li>线程之间如何通信</li>
<li>线程之间如何同步</li>
</ul>
<p>通信是指线程之间以何种机制来交换信息，在命令式编程中（编程主要分类：允许有副作用的命令式编程，不允许有副作用的函数式编程和不描述操作执行顺序的声明式编程），线程之间的通信机制有两种：</p>
<ul>
<li>共享内存：在共享内存的并发模型里，线程之间共享程序的公共状态（共享变量），线程之间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递：在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信</li>
</ul>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制，有两种方式：</p>
<ul>
<li>共享内存：同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li>
<li>消息传递：由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</li>
</ul>
<p>Java里面的并发就是采用共享内存的并发模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员是完全透明的（即你是看不见就发生了并发过程）。</p>
<h3><span id="java的并发模型采用的是共享内存模型">Java的并发模型采用的是共享内存模型</span></h3><p>Java线程之前的通信总是隐式进行的，整个通信过程对程序员完全透明。如果编写多线程程序不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2><span id="三-java内存模型的抽象">三、Java内存模型的抽象</span></h2><p>在Java中的共享变量有：所有实例域和数组元素存储在堆内存中，堆内存在线程之间共享（方法区也是线程共享，方法区保存类信息【类名称，方法，字段属性】，常量和静态变量 ）。局部变量、方法定义参数和异常处理器参数不会再线程之间共享，他们不会有内存可见性的问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（JMM）控制。JMM决定了一个线程对共享变量的写入时对另一个线程可见。从抽象的角度来看，JMM定义了线程与主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不是真实存在。<br>JMM抽象模型图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195125640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从图上看，如果线程A要和线程B通信的话，所经历的步骤是：</p>
<ul>
<li>线程A需要将本地内存A中的共享变量副本刷新到主内存中去</li>
</ul>
<ul>
<li>线程B去主内存中读取线程A之前已经更新过的共享内存</li>
</ul>
<p>步骤图：<br>        <img src="https://img-blog.csdnimg.cn/20200411195255403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>整体看，这两个步骤实质上是线程A在向线程B发送消息，而这个通信过程必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为我们提供内存的可见性保证。</p>
<h3><span id="重排序带来的并发问题">重排序（带来的并发问题）</span></h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p>
<ul>
<li>编译器优化的重排序（编译器重排序）。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序（处理器重排序）。现代处理器<br>采用了指令级并行技术将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序。</li>
<li>内存系统的重排序（处理器重排序）。由于处理器使用缓存和读写缓存，这使得加载和存储操作看上去可能是在乱序执行。<br><img src="https://img-blog.csdnimg.cn/20200411195837536.png" alt="在这里插入图片描述"><br>上面的重排序可能会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则则会禁止特定类型的编译器重排序（并不是所有的编译器重排序都要禁止），对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br> JMM属于语言级的内存模型，它确保在不同的编译器和不同处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为我们提供一致的内存可见性保证。还有就是重排序（包括编译器和处理器重排序）必须遵守as-if-serial规则（解决编译器重排序问题），该语义也就是说不管怎么排序，单线程程序执行的结果都不能改变；让人感觉单线程程序是按程序的顺序执行的，如果多个线程操作之间没有数据的依赖性则是允许重排序的，但是如果存在数据的依赖，则不会重排序的，这一点的问题是有保证的，所以现在的主要问题是，处理器使用缓存来读写数据，会导致数据读取不一，带来一种代码指令被重排序的感觉，对于共享变量，很容易出现问题。</li>
</ul>
<h4><span id="编译器重排序">编译器重排序</span></h4><p>编译器重排序的定义为：如果两个操作它们之间没有任何的依赖关系，也就是说A操作的结果和B操作的结果相互间没有任何的影响，此时编译器就可以对这两个操作进行重排序，如果两个操作共同操作一个共享变量，其中有一个操作为写，那么它们两是有数据依赖性的，从重排序会对最终执行结果产生影响，所以编译器重排序（也包括处理器重排序）都会遵循数据依赖性，编译器和处理器不会改变存在依赖关系的两个操作的执行顺序</p>
<h4><span id="处理器重排序">处理器重排序</span></h4><p>现在的处理器使用写缓冲区来临时保存向内存写入的数据。写缓存区可有保证指令流水想般持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟，同时通过批处理方式刷新写缓存区，以及合并写缓存区中对同一内存地址的多次写，可以减少对内存总线的占用，。虽然写缓存区有这么多的好处，但是每个处理器上的写缓存区，仅仅对它所在的处理器可见，这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读写操作的执行顺序，不一定与内存实际发生的读写操作顺序是一致的。<br>举个例子：a，b变量为共享变量，两个处理器项目访问共享变量。<br><img src="https://img-blog.csdnimg.cn/20200411200004201.png" alt="在这里插入图片描述"><br> 初始状态：a=b=0;<br>处理器允许执行后可能得到的结果：x=y=0;<br>具体原因如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411200042338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
<p>出现的一个执行顺序：<br>处理器A和处理器B同时把共享变量写入在写缓冲区中（A1，B1步骤），然后再从主内存中读取另一个共享变量的值（A2,B2步骤），最后才把自己写缓冲区中保存的脏数据刷新到主内存中（A3,B3步骤）。但最后执行下来就会得到一个结果：x=y=0。<br>    从实际理想的发生的顺序来看，正常执行顺序是这样的：<br>    直到处理器A执行了A3步骤之后已经刷新自己的写内存，写操作A1才算真正被执行，然后接着读A2。即发生的顺序：A1-&gt;A2.<br>    但内存操作实际发生这种可能：A2–&gt;A1。此时处理器A的内存操作顺序被重排序了。由于写缓存区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一样。由于现在的处理器都会使用写缓存区，因此都会允许对读写操作指令进行重排序。</p>
<h3><span id="内存屏障指令解决处理器重排序问题">内存屏障指令（解决处理器重排序问题）</span></h3><p>为了解决上面说的重排序问题，需要保证内存的可见性，可以使用内存屏障来达到这个效果，通过在适当位置插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为以下四类：</p>
<ul>
<li>a. LoadLoad屏障<br> 适用场景：Load1;LoadLoad;Load2<br> Load1和Load2代表两条读指令。在Load2读取指令装载之前，确保Load1读指令已经装载完毕。</li>
<li>b. StoreStore屏障<br>适用场景：Store1;StoreStore;Store2<br>Store1和Store2代表两条写指令。在Store2写指令的存储之前（刷新到内存中），确保Store1写指令的数据对其他处理器可见（刷新到内存中）</li>
<li>c. LoadStore屏障<br> 适用场景：Load1；LoadStore；Store2<br> 在Store2写指令的存储之前（刷新到内存中），确保Load1读指令已经装载读取完毕。</li>
<li>d. StoreLoad屏障<br>使用场景：Store1;StoreLoad;Load2<br>在Load2读指令装载之前，确保Store1写指令的数据对其他处理器可见（刷新到内存中），开销最大；该屏障会使之前的所有内存访问指令（存储和状态指令）完成之后，才执行该屏障之后的内存访问指令。</li>
</ul>
<h3><span id="happens-before规则定义两个操作之间的执行顺序利用内存屏障指令提供内存可见性的保障">happens-before规则（定义两个操作之间的执行顺序，利用内存屏障指令提供内存可见性的保障）</span></h3><p>JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另外一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作可以是一个线程内的，也可以是不同线程之内的。<br>与程序员密切相关的happens-before规则（共有八大规则）如下：<br>(注意，两个操作之间具有happens-before关系，并不意味这一个操作必须在后一个操作之前执行，happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见。且前一个操作（执行的结果）按顺序排在第二个操作之前。)</p>
<ul>
<li>a.程序顺序规则：两个操作之间存在happens-before关系，那么第一个操作的结果对第二个操作可见并且第一个操作的执行顺序在第二个操作之前。</li>
<li>b. 监视器锁规则：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。</li>
<li>c. volatile变量规则：对于一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>d.  传递性规则：如果 A  happens-before B,且B happens-before C,则A<br>happens-before C.</li>
<li>e.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>f.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>g. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>h. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ul>
<h3><span id="总结一下">总结一下</span></h3><p>解决重排序问题主要两种规则：as-if-serial（解决编译器重排序）和happens-before（解决处理器重排序）</p>
<ul>
<li>a.As-if-serial规则保证单线程程序的执行结果不被改变，happens-before规则保证正确同步的多线程程序的执行结果不会被改变</li>
<li>b.as-if-serial规则给我们一种感觉：单线程程序是按照程序顺序来执行的，而happens-before规则是正确同步的多线程程序是按照happens-before指定的顺序来执行的，</li>
<li>c. as-if-serial和happens-before规则都是为了在不改变程序执行结果的前提下，尽可能的提高程序的执行并行度。            </li>
</ul>
<h2><span id="四-jmm在实际开发中遇到的问题及解决方法">四、JMM在实际开发中遇到的问题及解决方法</span></h2><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要有两个问题：</p>
<ul>
<li><p>a. 共享对象对各个线程的可见性（使用volatile关键字解决）</p>
</li>
<li><p>b. 共享对象的竞争现象（使用同步锁解决）</p>
</li>
</ul>
<p>我们在实际的多线程开发中需要从原子性、可见性、有序性这三方面进行考虑，有序性的话JMM已经帮我们基本优化了，重点看一下原子性和可见性</p>
<h3><span id="共享对象的可见性锁以synchronized为例">共享对象的可见性（锁以synchronized为例）</span></h3><p>当多个线程同时操作一个共享对象时，如果没有合理的使用volatile和synchronized关键字，一个线程对共享对象的更新有可能导致其他线程不可见。 我们的共享对象存储在主内存中，一个CPU的线程去读取主内存的数据到CPU缓存中，然后对共享内存做了更改，但CPU缓存中的更改后的对象还没有刷新到主内存中，此时其他线程对共享对象的更改是不可见的，最终每个线程都会拷贝共享变量位于不同的CPU缓存中。要解决这个可见性问题，我们可以使用Java volatile关键字，volatile关键字可以保证共享变量会直接从主内存中读取，而对共享变量也会直接写到主内存中去。volatile原理是基于CPU内存屏障实现的。</p>
<h3><span id="竞争现象锁以sybchronized为例">竞争现象（锁以sybchronized为例）</span></h3><p>如果多个线程共享一个对象，它们同时修改这个共享对象，这就产生了竞争关系。例如线程A和线程B共享一个对象，线程A从主内存中读取共享对象到CPU缓存中，同时，线程B也同时读取共享对象到它的CPU缓存中，线程A和B同时对该共享变量做相同的操作（如同时进行+1操作，对象初始值为1），不管线程A或B有没有刷新到主内存中，并行执行，结果都会出错（相加了两次，结果却为2）。要解决这种竞争关系问题，我们可以使用java中的synchronized代码块，synchronized代码块可以保证同一时刻只有一个线程进入到代码竞争区，synchronized代码块也能保证代码块中所有变量都是从主内存中读，当线程退出的时候，对所有变量的更新都将会flush到之内存中，不管这些变量是不是volatile类型的。</p>
<h3><span id="volatile和锁synchronizedlock">volatile和锁（synchronized，Lock）</span></h3><p>对于一个volatile变量的单个读/写操作，与对一个普通变量的读写操作使用同一个锁来同步，它们之间的执行效果时相同的（因为它们都是从主内存中读写变量的）。<br>相同点：</p>
<ul>
<li>a.可见性。锁的happens-before规则是保证释放锁和获取锁的两个线程之间的内存可见性，这跟volatile的可见性是一样的：对于一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>b.原子性。锁的语义（同步）就决定了临界区代码的执行具有原子性，跟volatile一样，对于volatile变量的读取也具有原子性，但是对于多个volatile操作（类似于volatile++这种复合操作）就不具备原子性。</li>
</ul>
<p>（原子性就是在执行的过程中不会被中断，一次执行的，不会被其他线程干扰）</p>
<p>不同点：</p>
<ul>
<li>c. volatile：读写内存定义<br> 当读一个volatile变量的时候，JMM会把线程对应的本地内存置为无效，线程将从主内存中读取共享变量。<br> 当写一个volatile变量的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</li>
</ul>
<p>volatile语义的实现：<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>a. 在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>b. 在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>c. 在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>d. 在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>因为确保写操作内存可见，所以前面的写和后面的读写都不能重排序（按照原来的顺序来执行）<br>因为确保别的线程读正确，所以后面的读写指令都不能重排序（必须确保volatile读完后才操作，为了可见性）<br>具体插入内存屏障后生成的指令示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411200926802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这种volatile读写操作的内存屏障是非常保守的，在实际执行过程中，只要不改变volatile读写的定义，编译器可以根据具体情况省略不必要的屏障。</p>
<ul>
<li>d. 锁：锁释放和锁获取的内存定义<br>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li>
</ul>
<p>锁内存定义的实现：<br>锁有很多，包括ReentrantLock，Synchronized，公平锁，非公平锁，AQS等等，现在借助ReentrantLock来说明一下锁内存定义的实现。<br>首先是concurrent包的实现：<br>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ul>
<li>a. 首先声明共享变量为volatile</li>
<li>b. 然后使用CAS的原子条件更新来实现线程之同步</li>
<li>c. 同时配合以volatile的读写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信</li>
<li>d. AQS</li>
<li>e. 非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类）</li>
</ul>
<p>这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br>    <img src="https://img-blog.csdnimg.cn/20200411201135105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="五-总结">五、总结</span></h2><h3><span id="jmm的设计示意图">JMM的设计示意图</span></h3><p><img src="https://img-blog.csdnimg.cn/20200411201319944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>a.JMM向程序员提供的happens-before规则能满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A<br>happens-before B）。</li>
<li>b.<br>JMM对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h3><span id="java程序的内存可见性保证">Java程序的内存可见性保证</span></h3><ul>
<li><p>a.单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同</p>
</li>
<li><p>b.正确同步多线程程序。正确的同步多线程与该程序在顺序一致性内存模型中执行的结果相同。JMM通过限制编译器和处理器的重排序来为我们提供内存可见性保证。</p>
</li>
<li><p>c.未同步/未正确同步的多线程程序。JMM为它们提供了最小的安全保证：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200411201341702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">        </p>
</li>
</ul>
<h3><span id="最后">最后</span></h3><p>从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如i++不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。J.U.C包下的并发工具类和并发容器也是需要花时间去掌握的。</p>
<p>附录：<br>硬件内存架构<br>不管什么内存模型最终还是运行在硬件上，我们必须了解一个计算机的硬件内存。计算机架构图：<br><img src="https://img-blog.csdnimg.cn/2020041120135981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在计算机都有多个CPU,每个CPU又有多个核心，多线程就可以在各个不同的CPU核心中运行。<br>在CPU内部有一组CPU寄存器，也就是CPU的存储器，CPU操作寄存器的速度要比操作计算机的主内存快得多，所以为了提高效能，主内存和寄存器之间就存在一个CPU缓冲区，CPU操作缓冲区的速度快于主内存但慢于CPU寄存器，某些CPU可能有多个缓存区（一级缓存和二级缓存）。计算机的主内存也叫RAM，所有的CPU都能访问主内存，主内存比CPU缓存和CPU寄存器还要大得多。<br>当一个CPU需要访问主内存的时候，会先读取一部分主内存数据到CPU缓存，进而再读取CPU缓存到CPU寄存器。<br>当CPU需要写数据到主内存时，同样也会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主内存中。<br>Java内存模型和硬件内存架构之间的桥接<br>    <img src="https://img-blog.csdnimg.cn/20200411201410856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Java内存模型和硬件内存架构并不一样，硬件内存架构并没有区分栈和堆，从硬件上看，不管时栈还是堆，大部分数据都会存到主内存中，还可能一部分堆和栈数据存在CPU寄存器上。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-Thread%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-三大特性</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-final</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-final/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-volatile</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-volatile/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-认识并发编程</title>
    <url>/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><h3><span id="什么是并发">什么是并发</span></h3><p>在Java中并发就是指多线程的进程环境，进程是系统进行资源分配和调度的独立单位，每一个进程都有它的内存空间和系统资源，在同一个进程内执行的多个任务就可以看作是多个进程，线程存在于进程内，进程负责分配调度线程，线程负责执行程序，多个线程就执行多个程序。<br>实际上，Java程序天生就是一个多线程程序，包含了：</p>
<ul>
<li>分发处理发送给JVM信号的线程</li>
<li>调用对象的finalize清除方法的线程</li>
<li>清除相互引用reference的线程</li>
<li>main线程，也就是用户程序的入口，main线程里面还可以拥有很多的子线程<a id="more"></a>
<h3><span id="为什么需要多线程">为什么需要多线程</span></h3>如果没有多线程，若为了使程序并发执行，那么系统需要花费大量的时间在：创建进程–&gt;撤销进程–&gt;进程上下文切换调度,在这一过程中，需要的空间开销也非常大，执行效率也非常低（如下图）；若在一个进程中执行多个线程，则上面的空间开销和时间花费将会大大较少，何乐而不为呢，多线程提高了系统的执行效率，充分利用多核CPU的计算能力，提高应用性能。<br><img src="https://img-blog.csdnimg.cn/20200411183436680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2><span id="二-并发编程带来的问题">二、并发编程带来的问题</span></h2></li>
</ul>
<h3><span id="频繁的上下文切换问题">频繁的上下文切换问题</span></h3><p>正如上图中的时间片，时间片使CPU分配给各个线程的时间，因为时间非常短，所以CPU需要不断切换线程，让我们觉得多个线程是同时执行的，时间片一般是十几毫秒；每次切换都需要保存当前线程的状态，以便进行恢复先前的状态。这个切换是非常耗性能的，过于频繁就无法发挥出多线程编程的优势了。那么该怎么解决这频繁的上下文切换的问题的，目前有大概几种解决方法，后面会详细讨论：</p>
<ol>
<li>采用无锁并发编程：JDK8以前的concurrentHashMap采用的锁分段思想，不同线程处理不同段的数据，这样在多线程环境下可以减少上下文的切换时间。</li>
<li>采用CAS算法：JDK8以后的concurrentHashMap采用的是无锁CAS算法；利用Atomic和乐观锁，可以减少一部分不必要的锁竞争带来的上下文切换。</li>
<li>尽量减少线程的使用：避免创建不需要的线程，比如任务少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态。</li>
<li>采用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。<br>因此，并发累加未必会比串行累加的速度快，这上下文切换的问题在实际中是需要解决的。</li>
</ol>
<h3><span id="线程安全问题主要问题也是我们程序开发关心的问题">线程安全问题（主要问题，也是我们程序开发关心的问题）</span></h3><p>对线程编程中最难控制的就是临界区（共享内存的地方）的线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。那么怎么解决这种问题呢，解决方法如下：</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内部占用多个资源，尽量保证一个锁只占用一个资源</li>
<li>尝试使用定时锁，如使用lock.tryLock(timeOut),当超时等待时当前线程也不会阻塞</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里（同一个事务），否则会出现解锁失败的情况<br>后面还有JMM内存模型在原子性、有序性和可见性带来的问题，比如数据脏读，内存泄漏等等问题，这是又该如何保证线程安全呢，这一方面是非常重要的，后面会详细讨论。</li>
</ul>
<h2><span id="三-并发编程的相关概念">三、并发编程的相关概念</span></h2><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步通常用来形容方法的一次调用。<br>同步方法从被调用开始，调用者就必须等待被调用的方法结束后，调用者后面的代码才能继续执行。<br>异步方法指的是，调用者不管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。</p>
<h3><span id="并发和并行">并发和并行</span></h3><p>并发是指多个任务线程交替进行。<br>并行是指真正意义上的“同时进行”。<br>实际上，如果系统只有一个CPU，而使用多线程时，那么真实环境下时不能并行执行的，只能通过切换时间片的方式交替进行，完成并发执行任务，真正的并行只能出现在拥有多个CPU系统中。</p>
<h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。<br>阻塞是指如果一个线程占用了临界区的资源，那么其他线程需要这个资源的话就必须等待资源的释放，就会导致等待的线程挂起，这种情况就叫做阻塞。<br>非阻塞刚好跟阻塞相反，它强调的是没有一个线程可以阻塞其他线程，所有的线程都会尝试的向前运行。</p>
<h3><span id="临界区">临界区</span></h3><p>临界区用来表示一种公共资源会共享数据，可以被多个线程使用，出于线程安全问题，如果一个线程占用了临界区的资源，那么其他线程就必须等待，知道临界区的资源被释放。</p>
<h3><span id="守护线程">守护线程</span></h3><p>守护线程是一种特殊的线程，是系统的服务线程，是专门为其他线程服务的，像垃圾回收线程就是守护线程，与之对应的是用户线程，用户线程作为系统的工作线程，守护线程的服务对象就是用户线程，当全部的用户线程执行任务完成之后，这个系统就没有什么需要服务的了，那么守护线程就没有对象需要守护了，那么守护线程就会结束，也就是说当一个java程序只有守护线程的时候，虚拟机就会退出了。</p>
<h2><span id="四-java中的线程thread类">四、Java中的线程Thread类</span></h2><p>参考看一下Thread类的源码注释，了解Java中的线程，有专门对Thread类的源码做分析：Java-源码分析-Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1.一个Thread类对象代表程序中的一个线程，jvm是允许多线程的</span></span><br><span class="line"><span class="comment">	 * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment">	 * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment">	 * execution running concurrently.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.每一个线程都有优先级，具有高优先级的线程优先于底优先级的线程执行，每一个线程都可以设置成一个守护线程，创建线程的时候，通过线程设置setDaemon(true)就可以设置该线程为守护线程，设置守护线程需要先于start()方法</span></span><br><span class="line"><span class="comment">	 * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment">	 * executed in preference to threads with lower priority. Each thread</span></span><br><span class="line"><span class="comment">	 * may or may not also be marked as a daemon. When code running in</span></span><br><span class="line"><span class="comment">	 * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment">	 * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment">	 * creating thread, and is a daemon thread if and only if the</span></span><br><span class="line"><span class="comment">	 * creating thread is a daemon.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.只有当一个Java程序只存在守护线程的时候，虚拟机就会退出，让虚拟机不继续执行线程的方法有：</span></span><br><span class="line"><span class="comment">		2.1调用system.exit方法.</span></span><br><span class="line"><span class="comment">		2.2所有非守护线程都处于死亡状态（只有守护线程）或线程运行抛出了异常</span></span><br><span class="line"><span class="comment">	   注意：在线程启动前可以将该线程设置为守护线程，方法是setDaemon(boolean on)</span></span><br><span class="line"><span class="comment">		     使用守护线程最好不要在方法中使用共享资源，因为守护线程随时都可能挂掉</span></span><br><span class="line"><span class="comment">		     在守护线程中产生的线程也是守护线程</span></span><br><span class="line"><span class="comment">	 * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment">	 * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment">	 * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment">	 * occurs:</span></span><br><span class="line"><span class="comment">	 * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment">	 *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment">	 *     to take place.</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment">	 *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment">	 *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 *     method.</span></span><br><span class="line"><span class="comment">	 * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	3.创建线程的方式有两种（重写Runnable接口的run()方法）：</span></span><br><span class="line"><span class="comment">		3.1创建子类并继承Thread 类，同时重写run()方法（因为Thread类实现了Runnable接口）</span></span><br><span class="line"><span class="comment">		3.2创建子类并实现Runnable接口，同时重写run()方法</span></span><br><span class="line"><span class="comment">		下面有例子：</span></span><br><span class="line"><span class="comment">	 * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment">	 * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment">	 * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment">	 * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment">	 * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment">	 *     p.start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment">	 * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment">	 * style looks like the following:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment">	 *     new Thread(p).start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	4.每个线程都有一个名称，如果没有会在创建的时候自动生成一个，除非指定为null。</span></span><br><span class="line"><span class="comment">	 * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment">	 * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment">	 * a thread is created, a new name is generated for it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment">	 * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment">	 * thrown.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="五-总结">五、总结</span></h2><p>我们需要了解并发，为什么需要并发，还必须知道并发的优缺点，同时清楚使用并发编程之后所带来的问题：频繁上下文切换问题和线程安全问题等等，后面在并发编程的时候就朝着这些问题去编程，尝试解决这些问题，让并发编程发挥出真正的作用。<br>理解Java并发的关键点在于理解它的两大核心（JMM内存模型【工作内存和主内存】和happes-before规则【八大规则】）以及三大特性：原子性、可见性、有序性</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-线程的基本状态和操作</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><p>线程拥有自己的生命周期，一条线程从创建到执行完毕的过程就是线程的生命周期，那么在线程的生命周期的每个过程中可能在不同的时候处于不同的状态，用状态来描述生命周期那是最好不过了。<br>那么线程的生命周期到底有多少种状态呢，它们不同的状态又是如何通过状态的转化操作来完成线程的生命周期呢，下面就按照线程的生命周期的状态和状态之间的转换操作来详细说明。</p>
<a id="more"></a>
<h2><span id="二-线程的基本状态">二、线程的基本状态</span></h2><p>线程的状态没有严格的定义，可以先简单划分以下几个基本状态：<br>    <img src="https://img-blog.csdnimg.cn/20200411192919905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图中的五种状态描述如下：<br>a. New（新建）状态：一个线程被创建了但未被启动就处于新建状态，即在程序中使用new Thread()创建的线程实例就处于新建状态。<br>b. Runnable(可运行)状态：创建的线程实例通过调用start（）方法之后该线程就处于可运行状态，处于此状态的线程不一定说处于运行状态，Java多线程使用的线程调度策略是抢占式调度，每个可运行线程轮着获取CPU时间片，可以想象成一个可运行线程池，start()方法就是把一个线程放进可运行线程池中，CPU按照一定规则一个个执行线程池里面的线程。<br>c. Running（运行）状态：当可运行线程获取到CPU执行时间片就立即进入运行状态。<br>d. Not Running（非运行）状态：运行中的线程因某种原因暂时放弃CPU的使用权，可能是因为只执行了挂起、睡眠或者等待操作；在执行IO操作时，由于外部设备速度远低于处理器速度也可能导致线程暂时方法CPU使用权；在获取对象的同步锁的过程中如果同步锁被其他线程获取了，这样也会导致线程暂时放弃CPU的使用权了。<br>e. Dead(死亡)状态：线程执行完run()方法的任务之后，或者因为异常而导致退出任务，线程就进入死亡状态，该状态下是不能转换成其他状态了。</p>
<h2><span id="三-线程的状态转换">三、线程的状态转换</span></h2><p>在上面的五个状态中，是通过这些基本操作来完成状态之间的转换，基本操作配合五种状态就完成了线程的交替运行，把Not Running状态分成：Blocked（阻塞）、Waiting（等待）和Timed_Waiting(超时等待)这三个状态（以Synchronized锁及相关方法为例），如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411193016770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Blocked(阻塞)状态：当线程出现资源竞争，等待获取同步锁时，线程就会进入阻塞状态，直到线程获取到了锁，线程才会进入可运行状态。</li>
<li>Waiting(等待)状态：运行中的线程执行了Object.wait(),Thread.join(),LockSupport.park()等方法或者被其他线程调用interrupt()中断方法的时候就会进入等待状态，便进入了等待线程队列，如果有锁会释放锁，当在其他线程中调用对象的notify(),notifyAll(),LockSupport.unpart()方法就会唤醒等待线程队列中的线程，notify是随机唤醒一个线程，notifyAll是唤醒所有线程，唤醒后的线程会对该对象的monitor占有权竞争，获得占有权的线程才能转化为可运行状态。</li>
<li>Timed_Waiting(超时等待)状态：在wait(long),sleep(long),join(long)和LockSupport.partNanos(long),LockSupport.partUntil(long)方法中都加入了超时，调用这些方法设置超时时间后线程会进入超时等待状态，同时会把占有的锁释放；如果调用了notify(),notifyAll(),LockSupport.unpart()方法或者超时时间到了，线程就会被唤醒，重新对该对象的monitor占有权竞争，获得占有权的线程才会转化为可运行状态</li>
</ul>
<h2><span id="四-线程的基本操作">四、线程的基本操作</span></h2><p>从上面的图可以看出，线程的基本操作就是为了完成线程状态之间的转化，同时还是线程间的通信方式。</p>
<h3><span id="新建线程">新建线程</span></h3><p>新建线程的方式有三种：</p>
<ul>
<li>重写Runnable接口的run()方法创建线程（Thread类实现了Runnable接口，两者启动线程都是通过Thread类，运行的目标线程是Runnable类型的，所以只要是Runnable的子类都可以通过Thread类来启动线程）:<br><strong>i.</strong> 创建Thread类型对象，同时重写run()方法，然后通过Thread类启动线程<br><strong>ii.</strong> 创建Runnable类型对象，同时实现run()方法，然后通过Thread类启动线程</li>
<li>重写Callable接口的call()方法实现创建线程，由于含有回调的方法，所以配合FutureTask类可以实现异步结果返回效果（FutureTask类实现了RunnableFuture接口【该接口又继承了Runnable接口和Future接口】）<br>i. 创建Callable类型对象，同时实现call()方法，然后创建FutureTask类对象并传入Callable类型对象同时指定返回值类型，然后通过Thread类启动线程。</li>
<li>利用线程池Excutor创建线程（推荐使用这种）。ExcutorService接口含有submit()方法，参数可以是Callable接口类型和Runnable接口类型；若<br>参数是Callable接口类型，返回的是Future接口类型，可以使用Executors工具类来创建ExcutorService类型对象，然后使用ExcutorService对象调用Callable接口实现类，最后使用Future接收返回的结果。若参数是Runnable接口，则直接调用即可。（后面会专门分析FutureTask类和Excutors工具类）</li>
</ul>
<p>代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020/2/26</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@desc</span> 创建线程的方式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * 方法一：通过创建Thread类型对象，同时重写run()方法</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span>  Thread()&#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Thread类型对象，同时重写run()方法。。。"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;.start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式二：通过创建Runnable类型对象,同时实现run()方法</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Runnable类型对象,同时实现run()方法"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;).start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式三：通过实现Callable接口并实现call()方法,并异步返回执行结果</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        FutureTask&lt;String&gt; result=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过实现Callable接口并实现call()方法,并异步返回执行结果"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程执行完成"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">	        System.out.println(<span class="string">"callable接口执行返回的结果："</span>+result.get());</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式四：通过线程池来创建（只列举实现Callable接口）</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">	        FutureTask&lt;String&gt; result1= (FutureTask&lt;String&gt;) service.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line">	</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过线程池方式创建线程"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程池执行Callable的call方法返回的结果"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        System.out.println(<span class="string">"线程池返回的结果："</span>+result1.get());</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="其他对于线程的操作方法">其他对于线程的操作方法</span></h3><p>可以参考：Java-并发理论-源码分析-Thread类:常用方法（主要是操作线程的方法）<br>列举一下join()方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        Thread previousThread = Thread.currentThread();</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	            Thread curThread = <span class="keyword">new</span> JoinThread(previousThread);</span><br><span class="line">	            curThread.start();</span><br><span class="line">	            previousThread = curThread;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">private</span> Thread thread;</span><br><span class="line">	</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                thread.join();</span><br><span class="line">	                System.out.println(thread.getName() + <span class="string">" terminated."</span>);</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                e.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程，直到for循环执行完了，main线程执行完了，就会从上往下一个个继续执行。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-对象锁（monitor）</title>
    <url>/2019/11/03/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88monitor%EF%BC%89/</url>
    <content><![CDATA[<h2><span id="一-简介">一、简介</span></h2><p>Java提供了一种内置的锁机制来支持原子性和可见性，就是使用Synchronized的同步块或同步方法。在使用synchronized同步的时候，包含两部分：</p>
<ul>
<li>a. 一个锁对象引用</li>
<li>b. 一块锁保护的代码块<a id="more"></a>     
例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//1.同步代码块</span></span><br><span class="line">	<span class="keyword">synchronized</span>（锁对象引用）&#123;</span><br><span class="line"><span class="comment">//锁保护的代码块</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//2.同步方法</span></span><br><span class="line">	<span class="comment">//2.1锁对象引用就是被修饰方法所在的实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br><span class="line">	<span class="comment">//2.2如果是静态方法</span></span><br><span class="line">	<span class="comment">//锁对象引用就是被修饰方法所在的Class对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法体就是同步代码块</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>每个Java对象都可以用作一个实现同步的锁，因为每个Java对象都内置了一把锁，这种锁称之为内置锁或者监视器锁（monitor），俗称对象锁。</p>
<h2><span id="二-对象的内置锁特征">二、对象的内置锁特征</span></h2><ol>
<li>互斥性<br> 同一时间最多只能有一个线程持有这种锁。<br> 线程尝试获取一个被其他线程持有的内置锁，该线程必须等待（自旋）或者阻塞（自旋策略失效），并且请求内置锁被阻塞的线程不能被中断。</li>
<li>可重入性<br>如果某个线程试图获取一个已经由它持有的内置锁，那么这个请求就会成功。<br>实现原理为：为每个锁关联一个获取计数值和锁持有者线程，当计数值为0，表示这个锁没有被任何线程持有，当一个线程请求一个未被持有的锁时，JVM会将锁持有者线程（该线程）设置为请求线程，并且将计数值置为1，如果同一个线程再次请求这个锁，则计数值自增1，退出同步方法会同步块计数值将自减1，如果计数值减为0则这个锁会被释放。</li>
</ol>
<h2><span id="三-对象锁的原理实现">三、对象锁的原理实现</span></h2><p>Synchronized关键字其实就是实现对象内置锁的方式。<br>在线程进入同步代码块之前会获取对象的monitor，也就是获取到对象的锁；在退出同步代码块的时候（正常返回或者异常退出）都会自动释放对象的锁。<br>它是怎么识别这些同步代码块的呢？<br>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（例如 synchronized 关键字括号里的锁对象引用），作为所要加锁和解锁的锁对象。<br>它是怎么知道对象锁的位置（在哪加锁和解锁的呢）？<br>无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位。32为JVM Mark Word默认存储结构为：<br><img src="https://img-blog.csdnimg.cn/20200411202956609.png" alt="在这里插入图片描述"><br>如图在Mark Word会默认存放hasdcode，年龄值以及锁标志位等信息。<br>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：<br><img src="https://img-blog.csdnimg.cn/20200411203022822.png" alt="在这里插入图片描述"><br>如果互斥性造成被互斥的线程怎么处理<br>一般先通过自旋处理，如果自旋处理失败了就会阻塞线程。<br>自旋的实现原理就是，如果线程请求获取监视器锁失败，并不立刻阻塞线程，而是让线程执行一个忙循环（自旋）。自旋之后再次尝试获取锁。如果获取锁失败，这个过程会循环一定次数，超过某个阀值，如果还是获取不到锁，才阻塞线程。自旋可以通过-XX:+UserSpinning参数来开启，自旋的次数通过-XX:PreBlockSpin来更改（默认是10）。<br>自旋虽然避免了线程切换的损耗，但是需要占用处理器时间。自旋的效果取决于锁被占用的时间，如果锁被占用的时间很短，自旋等待的效果就会很好，反之，自旋只会白白消耗处理器资源，带来性能上的损耗。<br>JDK1.6引入了自适应的自旋锁。<br>对象头标记字段的锁状态的转化<br><img src="https://img-blog.csdnimg.cn/20200411203036721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="四-对象锁的分类">四、对象锁的分类</span></h2><h3><span id="偏向锁">偏向锁</span></h3><p>偏向锁的目的也是消除无竞争条件下的同步原语。偏向锁会偏向于第一个获取到它的线程，如果在获取到锁之后的过程中，没有发生锁竞争，那么持有偏向锁的线程将永远不需要再进行同步。相比轻量级锁，偏向锁能够消除轻量级锁多次加锁的CAS操作。<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li>a. 偏向锁的获取</li>
</ul>
<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 JVM会通过 CAS 操作，将当前线程的ID记录在锁对象的标记字段之中，并且将标记字段的锁标志位置为“01”，即偏向模式。<br>如果操作成功，在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101，是否包含当前线程的ID，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。<br>当有另外的线程尝试获取这个锁时，偏向模式宣告结束。如果当前对存于未锁定状态，撤销偏向恢复至未锁定（标记字段的锁标志位为“01”）。如果处于锁定状态，则升级为轻量级锁（标记字段的锁标志位为“00”），后续的同步操作便按照轻量级锁的规则来进行。</p>
<ul>
<li>b. 偏向锁的撤销</li>
</ul>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br><img src="https://img-blog.csdnimg.cn/2020041120320646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br>下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。<br><img src="https://img-blog.csdnimg.cn/20200411203219732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>c. 偏向锁的失效</li>
</ul>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。<br>如果某一类锁对象的总撤销数超过了一个阈值（对应JVM参数-XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 JVM会宣布这个类的偏向锁失效。<br>如果总撤销数超过另一个阈值（对应 JVM参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
<h3><span id="轻量级锁">轻量级锁</span></h3><p>轻量级锁的目标是在没有多线程的竞争下，减少重量级锁使用的操作系统互斥量产生的性能消耗。</p>
<ul>
<li>a. 加锁</li>
</ul>
<p>当进行加锁操作时，JVM会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录（Lock Record），并且将锁对象的标记字段复制到该锁记录中。<br>然后，JVM会尝试用 CAS（compare-and-swap）操作将锁对象的标记字段替换为锁记录的指针。如果操作成功，那么这个线程就获取了这个对象的锁，并且标记字段的锁标志位转变为“00”，表示该锁处于轻量级锁定状态。如果标记字段替换操作失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。JVM会先检查对象的标记字段是否指向当前线程的栈帧，如果是表明当前线程已经持有了该对象的锁。否则说明这个对象的锁已经被其它线程所持有了，这时，轻量级锁膨胀为重量级锁，锁的标记字段的锁标志位变为“10”，标记字段存储的就是指向重量级锁（互斥量）的指针，后面的线程要进入阻塞状态。</p>
<ul>
<li>b. 解锁</li>
</ul>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src="https://img-blog.csdnimg.cn/20200411203341249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3><span id="重量级锁">重量级锁</span></h3><p>重量级锁是 JVM中传统的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>
<h2><span id="五-各种锁的比较">五、各种锁的比较</span></h2><p><img src="https://img-blog.csdnimg.cn/20200411203352349.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-关键字-synchronized</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-synchronized/</url>
    <content><![CDATA[<h2><span id="一-什么是synchronized">一、什么是Synchronized</span></h2><p>这个可以参考一下介绍：Java-并发理论-JMM内存模型：volatile和锁（synchronized，ReentrantLock）。<br>Synchronized关键字主要是用来解决多线程的线程安全问题的。是一种同步机制。那么这些安全性问题主要是来源JMM内存模型中主内存和线程的工作内存带来共享变量的可见性问题，以及重排序带来的问题；Java中的关键字synchronized同步机制就具备解决这些共享数据的线程安全问题，但是这种同步机制的效率很低，但是synchronized是其他并发容器实现的基础，理解它会提高并发编程有很大帮助。</p>
<a id="more"></a>     
<h2><span id="二-synchronized的作用是什么">二、synchronized的作用是什么</span></h2><p>主要是在多线程环境下保证线程安全<br>    1. 保证了线程的原子性，即被保护的代码块或方法是一次被执行的，中间没有其他线程同时访问<br>    2. 保证了共享变量的可见性，即当执行完synchronized的代码块或方法之后，修改后的共享变量会更新到主内存中，其他线程是可见的。</p>
<h2><span id="三-synchronized的实现原理">三、Synchronized的实现原理</span></h2><h3><span id="synchronized基本用法">synchronized基本用法</span></h3><p>synchronized关键字在Java中使用很简单，可以使用在代码块中和方法上，具体的使用位置如下：<br><img src="https://img-blog.csdnimg.cn/20200411203809896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>synchronized是一种互斥锁，可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。</p>
<h3><span id="synchronized底层实现原理">synchronized底层实现原理</span></h3><ul>
<li>a. 监视器（monitor）机制<br>i. synchronized是一种内置锁/监视器锁，Java中每个对象都有一个内置锁（monitor监视器锁，就像一个标记一样），而synchronized就是使用对象的内置监视器锁来将代码块或方法锁定的。<br>ii. 在底层，synchronized关键字对代码块是通过monitorenter和moniterexit指令实现的；对方法是通过方法修饰符上的ACC_SYNCHRONIZED实现的。<br>iii. synchronized具有内置锁的可重入性，即它是重入锁，如果在一个线程中，方法A使用了synchronized锁，而在方法A中又存在方法a中也存在使用synchronized锁，那么从方法A调用方法a的过程中，即从外锁再进入内锁是不需要重新获取锁了，在外锁获取一次就可以了，到里面继续使用原来的锁，因为锁是线程持有的，在一个线程内不会重复获取锁，这就是重入锁<br>下面是在多线程中使用synchronized关键字的对象Object与监视器之间的关系：<br> <img src="https://img-blog.csdnimg.cn/20200411203857917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">上面可以看出，如果想要访问使用synchronized的对象Object，首先需要获取Object的监视器（使用monotorenter命令）,若获取失败则进入同步队列，线程状态变成Blocked状态，当Object的监视器占有者释放后，在同步队列中的线程就有机会重新获取该监视器了。</li>
<li>b. synchronized的happens-before规则<br> 监视器锁规则是：对于一个监视器的解锁，happens-before于随后这个监视器的加锁。<br> 看一下下面代码，若有两个线程A和B分别执行writer和reader方法（假设线程A先执行），是怎么执行上面这条规则的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDemo</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;     <span class="comment">// 1</span></span><br><span class="line">	        a++;                                <span class="comment">// 2</span></span><br><span class="line">	    &#125;                                       <span class="comment">// 3</span></span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;    <span class="comment">// 4</span></span><br><span class="line">	        <span class="keyword">int</span> i = a;                         <span class="comment">// 5</span></span><br><span class="line">	    &#125;                                      <span class="comment">// 6</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200411203955342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系。<br>    现在重点关注2 happens-before 5，通过这个关系我们可以得出什么？<br>    根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</p>
<ul>
<li>c. 锁获取和锁释放的内存定义<br> 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。<br> 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。<br>参考：Java-并发理论-JMM内存模型：2）锁：锁释放和锁获取的内存定义</li>
</ul>
<h2><span id="四-synchronized的优化">四、synchronized的优化</span></h2><p> 对于上面已经很详细说了synchronized关键字的底层原理了，简单来说，它最大的特点就是：<br>    在同一时刻只有一个线程能够对得对象得监视器（monitor），从而在进入同步代码块或方法中，如果其他线程进来需要等监视器释放锁，这种行为表现为互斥性（排他性）。<br>但是如果每次都只能有一个线程进入方法或代码块，这样执行的效率必然很低的，就像我们买东西后排队付钱一样，原来的方式是拿现金到收银台给收银员付款，还要找零钱等等，得一个一个来，效率很低，现在呢，出现了微信支付和支付宝支付，付款只需要拿出收集扫一下二维码就可以付款了，很方便，效率相对于提高了很多；同样对于synchronized效率低得情况下也出现了类似的优化。</p>
<h3><span id="优化之cas算法无锁算法">优化之CAS算法（无锁算法）</span></h3><ul>
<li>a. 什么是CAS<br>CAS的全称为compare and swap(比较并替换)，是一种乐观的思想，相对于Synchronized是一种悲观的思想，也就是说synchronized时时刻刻都想着肯定会有其他线程跟我竞争资源的，我就把这个共享资源一直占用着，别的线程只能在外面等着，处于阻塞状态，直到我释放了你才能用；而CAS是这样想的，并不是时时刻刻都有别的线程跟我竞争资源的，如果真的有人过来跟我竞争资源的，我才告诉他等我用完释放了你才能使用，这样别的线程就不会都处于阻塞状态了，不需要竞争的线程还可以继续工作下去，只有真正需要竞争的才需要阻塞等待。那么CAS是怎么做到的呢？</li>
<li>b. CAS的实现过程<br>实现CAS的过程需要三个操作数：内存中的原值V，旧的预期值A，需要修改的新值B，实现的过程只需要三步：<pre><code>i. 比较A值与V值是否相等
ii. 如果相等则说明旧值A还是最新的内存值，没有被其他线程更改过，将B值替换V值，返回更新成功
iii. 如果不相等，则说明内存值已经被其他线程修改过了，不是最新的值，所以不能将B值图换成V值，更新失败，返回内存原值V即可；并可以重新尝试。</code></pre>当多个线程同时使用CAS操作一个变量时，只有一个线程会操作成功，但并不会阻塞其他线程，只是其余的都会收到失败的信号，失败的线程可以选择重新尝试也可以选择挂起线程。</li>
<li>c. CAS基本的底层原理<br> java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。<br> unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg<br> Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>
<li>d. 在Java中的应用<br>在JUC包中利用CAS算法实现的类有很多，可以说是支持起整个concurrency包的实现，在locks包中的实现会有CAS改变state变量，在atomic包中的实现类几乎都是利用CAS算法实现的，一般的应用场景：<pre><code>自旋锁，会一直while()循环，直到CAS操作成功为止，如下执行lock()方法的时候</code></pre></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		  <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    <span class="keyword">while</span>(!sign .compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		    &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">		</span><br><span class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		    Thread current = Thread.currentThread();</span><br><span class="line">		    sign .compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e. CAS的缺点<br> i. ABA的问题，CAS会检查旧值有没有变化，如果出现这种情况，旧值A跟原值V比较，相等了才替换称B值，若在比较之前，A值变成了B值，然后有变成A值，比较的时候旧值依然为A值没有变化，但实际上已经发生了变化，解决的方法也很简单，像数据库中使用的乐观锁的方式，加一个版本号就可以解决了，原来的变化为A-B-A,解决后为1A-2B-3A；Java在1.5版本以后的atomic包中就提供了AtomicStampedReference来解决ABA的问题。<br> ii. 自旋时间过长的问题，使用CAS时是非阻塞同步（无锁），也就是说不会将线程挂起，会自旋（就是一个死循环）进行下一次尝试，如果自旋时间过长也会对性能有很大的影响。目前只是限制自旋次数。最终自旋失败了就进去阻塞状态。如果JVM能支持处理器提供的pause指令，那么效率上会有很大的提升。<br> iii. 只能保证一个共享变量的原子操作<br> iv. 如果只对一个共享变量进行cas操作时能保证原子性，但是如果对多个共享变量进行操作，cas就不能保证其原子性了，有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发理论-源码分析-Thread类</title>
    <url>/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Thread%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-数据结构-哈希表</title>
    <url>/2020/01/13/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-枚举</title>
    <url>/2020/01/14/Java-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-泛型</title>
    <url>/2020/01/14/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-注解</title>
    <url>/2020/01/13/Java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器-Map-总览</title>
    <url>/2020/01/12/Java%E5%AE%B9%E5%99%A8-Map-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java容器</category>
      </categories>
      <tags>
        <tag>Map集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器-Conllection-总览</title>
    <url>/2020/01/11/Java%E5%AE%B9%E5%99%A8-Conllection-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java容器</category>
      </categories>
      <tags>
        <tag>Conllection集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-属性配置类-PropertyPlaceholderConfigurer</title>
    <url>/2020/03/11/Spring-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%B1%BB-PropertyPlaceholderConfigurer/</url>
    <content><![CDATA[<h2><span id="是什么">是什么</span></h2><p>PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。在bean初始化前执行的后置处理器</p>
<a id="more"></a>
<h2><span id="作用">作用</span></h2><p>在Spring中，使用PropertyPlaceholderConfigurer可以在XML配置文件中加入外部属性文件，当然也可以指定外部文件的编码。PropertyPlaceholderConfigurer可以将上下文（配置文 件）中的属性值放在另一个单独的标准java Properties文件中去。在XML文件中用${key}替换指定的properties文件中的值。这样的话，只需要对properties文件进 行修改，而不用对xml配置文件进行修改</p>
<h2><span id="使用方法">使用方法</span></h2><h3><span id="编写properties文件">编写.properties文件</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdbc.properties 文件</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/ds?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;allowMultiQueries=true</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<h3><span id="在xml中引入外部文件即properties文件">在.xml中引入外部文件，即.properties文件</span></h3><ul>
<li>如果引单个文件：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		&lt;value&gt;jdbc.properties&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;property name=<span class="string">"fileEncoding"</span>&gt;</span><br><span class="line">	   &lt;value&gt;UTF-8&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果引多个文件（添加）：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		 &lt;list&gt;  </span><br><span class="line">			&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;classpath:inter.properties&lt;/value&gt;</span><br><span class="line">		 	&lt;value&gt;classpath:email.properties&lt;/value&gt;</span><br><span class="line">		 &lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="引入外部文件后就可以在xml中用key替换指定的properties文件中的值通常项目中都会将jdbc的配置放在properties文件中">引入外部文件后，就可以在xml中用${key}替换指定的properties文件中的值，通常项目中都会将jdbc的配置放在properties文件中</span></h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置dbcp数据源 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSourceDefault"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>在启动容器时，初始化bean时，${key}就会替换成properties文件中的值<br>为简化PropertyPlaceholderConfigurer的使用，Spring提供了<a href="context:property-placeholder/">context:property-placeholder/</a>元素,启用它后，开发者便不用配置PropertyPlaceholderConfigurer对象了</p>
<h4><span id="编写properties文件">编写.properties文件</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/jdbc.properties 文件</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//66.59.208.106:3306/ds?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;allowMultiQueries=true</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
<h4><span id="配置属性文件的位置">配置属性文件的位置</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据库配置文件位置 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>PropertyPlaceholderConfigurer内置的功能非常丰富，如果它未找到${xxx}中定义的xxx键，它还会去JVM系统属性（System.getProperty()）和环境变量（System.getenv()）中寻找。通过启用systemPropertiesMode和searchSystemEnvironment属性，开发者能够控制这一行为。context:property-placeholder大大的方便了我们数据库的配置。这样就可以为spring配置的bean的属性设置值了</p>
<h4><span id="配置bean的属性">配置bean的属性</span></h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置dbcp数据源 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSourceDefault"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<p>注：spring容器中最多只能定义一个context:property-placeholder，否则会报错：Could not resolve placeholder XXX,但如果想引入多个属性文件怎么办那，可以使用通配符：<code>&lt;context:property-placeholder location=&quot;classpath*:conf*.properties&quot;/&gt;</code></p>
<h2><span id="自定义-propertyplaceholderconfigurer">自定义 PropertyPlaceholderConfigurer</span></h2><p>继承PropertyPlaceholderConfigurer 类，重写processProperties（）方法，之所以自定义，很有可能是因为java代码中使用了属性值，那些经常变得值，但又是常量，但是这样配置的话，如果属性文件中的属性值改变了，必须重启容器，因为容器启动时，已经将属性值初始化进了代码中就不变了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholder</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; propertyMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.processProperties(beanFactoryToProcess, props);</span><br><span class="line">        propertyMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">            String keyStr = key.toString();</span><br><span class="line">            String value = props.getProperty(keyStr);</span><br><span class="line">            propertyMap.put(keyStr, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个方法，即根据key拿属性值,方便java代码中取属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyMap.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring在创建bean时就会调用processProperties（）方法，属性文件中设置的键值对都放在了Properties中<br>自定义了PropertyPlaceholderConfigurer类之后，在xml中配置时，配置bean中的class就必须设置为自定义的类（包路径+类名），不能再写为PropertyPlaceholderConfigurer类，否则自定义的方法不能使用，因为根本没有创建自定义类的bean。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyCondigDefine"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.huahua.springmvc.base.config.PropertyPlaceholder "</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"location"</span>&gt;</span><br><span class="line">        &lt;value&gt;classpath:config-test.properties&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"testmodel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.huahua.springmvc.model.TestModel"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring-属性配置类</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-教程-简介</title>
    <url>/2020/02/11/SpringMVC-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2><span id="一-spring-mvc运行原理">一、spring mvc运行原理</span></h2><p>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。<br><img src="https://img-blog.csdnimg.cn/2020041123510668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>(1) Http请求：客户端请求提交到DispatcherServlet。</li>
<li>(2)寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</li>
<li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。</li>
<li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。</li>
<li>(6)(7)处理视图映射并返回模型：DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。</li>
<li>(8) Http响应：视图负责将结果显示到客户端。</li>
</ul>
<h2><span id="二-主要注解">二、主要注解</span></h2><p><img src="https://img-blog.csdnimg.cn/20200411235319423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="三-springmvc的启动过程">三、SpringMVC的启动过程</span></h2><p>spring mvc启动过程主要有两个过程：</p>
<ul>
<li>ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。</li>
<li>DispatcherServlet初始化。</li>
</ul>
<h3><span id="contextloaderlistener">ContextLoaderListener</span></h3><p>在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。</p>
<ul>
<li>一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。</li>
<li>当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param&gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet​。（同类多个节点以出现顺序依次加载）<br><img src="https://img-blog.csdnimg.cn/20200412161931698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们来看一下SpringMVC中的web.xml配置<br><img src="https://img-blog.csdnimg.cn/20200412161944853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p>其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。</p>
<h3><span id="contextloaderlistener在webxml中的配置">ContextLoaderListener在web.xml中的配置</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 配置contextConfigLocation初始化参数 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">	&lt;!-- 配置ContextLoaderListerner --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">        &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ServletContextListener 接口有两个方法:contextInitialized,contextDestroyed</p>
<h3><span id="dispatcherservlet">DispatcherServlet</span></h3><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。<br>下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。</p>
<ul>
<li>流程图<br><img src="https://img-blog.csdnimg.cn/20200411235550692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>在web.xml中的配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- servlet定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">	</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">dispatcher</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>load-on-startup：表示启动容器时初始化该Servlet；</li>
<li>url-pattern：表示哪些请求交给Spring Web MVC处理， “/”<br>是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。</li>
</ul>
<p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。<br>WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）<br><img src="https://img-blog.csdnimg.cn/2020041123563619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。<br><img src="https://img-blog.csdnimg.cn/2020041123564796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中，常用的ViewResolver的配置。以jsp作为视图为例</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 对模型视图名称的解析,即在模型视图名称添加前后缀 --&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span><br><span class="line">	&lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">配置上传文件限制MultipartResolver</span><br><span class="line">	&lt;!-- 上传限制 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">     &lt;!-- 上传文件大小限制为<span class="number">31</span>M，<span class="number">31</span>*<span class="number">1024</span>*<span class="number">1024</span> --&gt;</span><br><span class="line">     &lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"32505856"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="applicationcontextxml中的标签">applicationContext.xml中的标签</span></h3><p><img src="https://img-blog.csdnimg.cn/20200411235735116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3><span id="文件上传">文件上传</span></h3><p>前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。</p>
<ul>
<li>表单</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">	&lt;form method=<span class="string">"post"</span> action=<span class="string">"/form"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">     &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@RequestMapping</span>(path = <span class="string">"/form"</span>, method = RequestMethod.POST)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, </span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">          <span class="comment">// store the bytes somewhere</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="异常处理">异常处理</span></h3><p>先来说下常见的异常处理有几种方式，如下图：<br><img src="https://img-blog.csdnimg.cn/20200411235847237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。<br>某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。</p>
<ul>
<li>HandlerExceptionResolver 提供resolveException接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;  </span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在BaseController中使用 @ExceptionHandler注解处理异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Object</span> <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">ex</span>, <span class="title">HttpServletResponse</span> <span class="title">response</span>, </span></span><br><span class="line"><span class="class">              <span class="title">HttpServletRequest</span> <span class="title">request</span>) <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">		String url = <span class="string">""</span>;</span><br><span class="line">		String msg = ex.getMessage();</span><br><span class="line">		Object resultModel = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex.getClass() == HttpRequestMethodNotSupportedException<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				url = <span class="string">"admin/common/500"</span>;</span><br><span class="line">				System.out.println(<span class="string">"--------毛有找到对应方法---------"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex.getClass() == ParameterException<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//自定义的异常</span></span><br><span class="line">                                </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex.getClass() == UnauthorizedException<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				url = <span class="string">"admin/common/unauth"</span>;</span><br><span class="line">				System.out.println(<span class="string">"--------毛有权限---------"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">String header = req.getHeader(<span class="string">"X-Requested-With"</span>);</span><br><span class="line">			<span class="keyword">boolean</span> isAjax = <span class="string">"XMLHttpRequest"</span>.equalsIgnoreCase(header);</span><br><span class="line">			String method = req.getMethod();</span><br><span class="line">			<span class="keyword">boolean</span> isPost = <span class="string">"POST"</span>.equalsIgnoreCase(method);</span><br><span class="line"><span class="keyword">if</span> (isAjax || isPost) &#123;</span><br><span class="line">				<span class="keyword">return</span> Message.error(msg);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ModelAndView view = <span class="keyword">new</span> ModelAndView(url);</span><br><span class="line">				view.addObject(<span class="string">"error"</span>, msg);</span><br><span class="line">				view.addObject(<span class="string">"class"</span>, ex.getClass());</span><br><span class="line">				view.addObject(<span class="string">"method"</span>, request.getRequestURI());</span><br><span class="line">				<span class="keyword">return</span> view;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">			logger.error(exception.getMessage(), exception);</span><br><span class="line">			<span class="keyword">return</span> resultModel;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			logger.error(msg, ex);</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在web.xml中处理异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	&lt;!-- 默认的错误处理页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">	&lt;error-code&gt;403&lt;/error-code&gt;</span><br><span class="line">	&lt;location&gt;/403.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">	&lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">	&lt;location&gt;/404.html&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">&lt;!-- 仅仅在调试的时候注视掉,在正式部署的时候不能注释 --&gt;</span><br><span class="line">&lt;!-- 这样配置也是可以的，表示发生<span class="number">500</span>错误的时候，转到<span class="number">500</span>.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">	&lt;error-code&gt;500&lt;/error-code&gt; </span><br><span class="line">	&lt;location&gt;/500.html&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line">	&lt;!-- 这样的配置表示如果jsp页面或者servlet发生java.lang.Exception类型（当然包含子类）的异常就会转到<span class="number">500</span>.jsp页面处理。 --&gt;</span><br><span class="line">&lt;error-page&gt; </span><br><span class="line">	&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; </span><br><span class="line">	&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt; </span><br><span class="line">	&lt;error-page&gt; </span><br><span class="line">	&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; </span><br><span class="line">	&lt;location&gt;/500.jsp&lt;/location&gt; </span><br><span class="line">&lt;/error-page&gt;</span><br><span class="line">	&lt;!-- 当error-code和exception-type都配置时，exception-type配置的页面优先级高及出现<span class="number">500</span>错误，发生异常Exception时会跳转到<span class="number">500</span>.jsp--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题<br>HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？</li>
<li>解答：<br>如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： return a corresponding ModelAndView to forward to, or null for default processing.</li>
</ul>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC-简介</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-首页</title>
    <url>/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<h2><span id="简介">简介：</span></h2><p>基本包含了Java并发编程的知识内容同时囊括并发Concurrent包的重点源码分析，如有问题欢迎评论指出，谢谢支持！<br>关注微信公众号获取更多知识：当代猿</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200409181814334.png#pic_center" alt="微信公共号二维码"></p>
<h2><span id="思维导图">思维导图：</span></h2><p><img src="https://img-blog.csdnimg.cn/20200409181910892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：思维导图链接，待完成后一起公布。</p>
<h2><span id="目录">目录：</span></h2><p>说明：目录会持续更新</p>
<ol>
<li>Java-并发编程-认识并发编程</li>
<li>Java-并发基础-线程的基本状态和操作</li>
<li>Java-并发理论-JMM内存模型</li>
<li>Java-并发理论-对象锁（monitor）</li>
<li>Java-并发理论-关键字-synchronized</li>
<li>Java-并发理论-关键字-volatile</li>
<li>Java-并发理论-关键字-final</li>
<li>Java-并发理论-三大特性</li>
<li>Java-并发理论-源码分析-Thread类</li>
<li>Java-并发concurrent包-简介</li>
<li>Java-并发concurrent包-atomic包</li>
<li>Java-并发concurrent包-locks包</li>
<li>Java-并发工具-并发容器-ConcurrentHashMap</li>
<li>Java-并发工具-并发容器-CopyOnWriteArrayList</li>
<li>Java-并发工具-并发容器-CopyOnWriteSet</li>
<li>Java-并发工具-并发容器-阻塞队列</li>
<li>Java-并发工具-线程池-原理&amp;ThreadPoolEcecutor</li>
<li>Java-并发工具-线程池-原理&amp;ScheduledThreadPoolExecutor</li>
<li>Java-并发工具-基本类FutureTask</li>
<li>Java-并发工具-工具类Excutors</li>
<li>Java-并发工具-工具类CountDownLatch</li>
<li>Java-并发工具-工具类CyclicBarrier</li>
<li>Java-并发工具-工具类Semaphore</li>
<li>Java-并发工具-工具类Exchanger</li>
<li>Java-并发实践-生产者与消费者</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-教程-简介</title>
    <url>/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1><span id="spring是什么">spring是什么</span></h1><p>spring是一个企业级应用的开源框架，它也是轻量级的、一站式的、面向切面编程的、依赖注入DI和容器IOC的、模块化的框架。<br>总的来说，Spring就是用来替代更加重量级的企业级的Java技术。</p>
<a id="more"></a>
<h1><span id="spring能做什么">spring能做什么</span></h1><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性的角度而言，绝大部分Java应用都可以从Spring中受益。<br>spring实现了使用简单的组件将Java对象配置组合成 了一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象。Spring对JavaEE中非常难开发的一些API（JDBC、JavaMail、远程调用等），都提供了封装，大大降低了这些API的应用难度。</p>
<ul>
<li>轻量级：立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>非侵入式：也就是自己开发的类不依赖Spring的API接口，对现有的类结构没有影响，也能够增强JavaBean的功能  </li>
<li>IOC容器：spring是一个容器，因为它包含并且管理应用对象的生命周期。<br>降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>一站式：在AOP和IOC的基础上可以整合出各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的JDBC）;<br>spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。<br>总的来说Spring可以简化Java的开发：</li>
</ul>
<ol>
<li>基于POJO（也叫Java bean）轻量级和最小侵入式开发</li>
<li>通过IOC、依赖注入和面向接口实现松耦合</li>
<li>基于切面进行声明式编程</li>
<li>通过切面和模板来减少样板式代码</li>
</ol>
<h1><span id="spring为什么出现">spring为什么出现</span></h1><p><img src="/images/Spring-1-1.png" alt="B/S结构"><br>这张图上展示了一个基于SSH,B/S结构的单体Java应用的搭建过程，首先通过浏览器进入到Filter拦截器，进入到Structs2，通过Service层进入到Hibernate，从而进行操作数据库，若整个过程都是由SpringIOC容器控制就显得那么简单了。说白了就是为了简化复杂的操作过程，减少问题的出现。这张图向我们展示了一个比较基础的JavaWeb的搭建过程。万变不离其宗，后来使用的SSM框架，现在比较火的微服务架构，都离不开这张图上展示的内容所提供给大家的思想。每个框架的实现宗旨都是一样的，只不过实现的方式不一样。其实在这个框架最初的时候应该是以JSP+Servlet比较常用，后来为了解决前后端分离的问题，降低耦合度。将这些功能结构按照MVC分层实现。<br>个人的理解MVC为一种程序设计思想，可以很多场合使用到，从Web、后端、移动端在很多的场合下将MVC作为一种程序设计思想应该是比较恰当的。</p>
<h1><span id="spring结构体系模块化">spring结构体系（模块化）</span></h1><p><img src="/images/Spring-1-2.png" alt="Spring结构"></p>
<h2><span id="核心容器">核心容器</span></h2><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：<br>-** spring-core模块**提供了框架的基本组成部分，包括 IoC容器 和依赖注入功能。</p>
<p>-** spring-beans 模块**提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
<p>-** context模块**建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
<p>-<strong>spring-expression模块</strong>提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
<p>它们的完整依赖关系如下图所示：<br><img src="/images/Spring-1-3.png" alt="Spring依赖关系图"><br><img src="/images/Spring-1-4.png" alt="Spring关系"></p>
<h2><span id="数据访问集成">数据访问/集成</span></h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：<br>注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）<br>• JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。<br>• ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。<br>• OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。<br>• JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。<br>• 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h2><span id="web">Web</span></h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：<br>• Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。<br>• Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。<br>• Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。<br>• Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
<h2><span id="其他">其他</span></h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：<br>• AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。<br>• Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。<br>• Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。<br>• Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。<br>• 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-教程-自定义全局异常处理</title>
    <url>/2020/04/13/SpringMVC-%E6%95%99%E7%A8%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2><span id="一-说明">一、说明</span></h2><p>SpringMVC中的异常处理总览：<br><img src="https://img-blog.csdnimg.cn/20200412235824891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>     
<h2><span id="二-实现自定义全局异常处理">二、实现自定义全局异常处理</span></h2><p>在Web应用中，有时候我们在对客户端请求进行处理的时候，在响应的过程中往往会出现各种各样的异常，比如在业务层捕获到的异常等等，有些异常对应web应用来说不能单纯的往上抛或者随便处理一下，如果这样做都会影响客户端的体验效果的，我们需要做的是就是正确的捕获并处理这些异常信息，用正确的方式响应给客户端，让客户端知道哪里出问题了，这样我们就不能单单做局部异常管理了，需要做统一的异常处理，在SpringMVC中就提供了一个接口：HandlerExceptionResolver，让我们去实现自定义全局异常处理。<br>基本步骤：</p>
<ol>
<li><p>实现HandlerExceptionResolver接口</p>
</li>
<li><p>重写resolverException抽象方法<br> resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)<br> 参数说明：<br>  2.1 httpServletRequest： 当前的http请求 current HTTP request<br>  2.2 httpServletResponse： 当前的http响应 current HTTP response<br>  2.3 handler： 表示已经执行过的处理操作 the executed handler, or if none chosen at the<br>   time of the exception (for example, if multipart resolution failed)<br>  2.4 ex：表示当前发生的异常 the exception that got thrown during handler execution<br>  2.5 返回一个模型视图对象来表示一个异常错误的视图页面 return a corresponding ModelAndView to forward to,</p>
</li>
<li><p>实现Ordered接口并实现其抽象方法，设置优先级<br> 3.1重写getOrder方法，返回设置的优先级数值，数值越小优先级就越高</p>
</li>
<li><p>自定义异常类（自定义一个异常基类，同时可以让不同的子类去继承该基类，相当于做个异常类型的分类）</p>
</li>
<li><p>自定义结果响应码</p>
</li>
<li><p>自定义结果响应格式</p>
</li>
</ol>
<h2><span id="三-代码实现">三、代码实现</span></h2><ol>
<li>实现了HandlerExceptionResolver和Ordered接口的具体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * springMVC自定义统一异常处理；</span></span><br><span class="line"><span class="comment">	 * 1.实现HandlerExceptionResolver接口</span></span><br><span class="line"><span class="comment">	 * 2.重写resolverException抽象方法,参数说明：</span></span><br><span class="line"><span class="comment">	 * 2.1 httpServletRequest： 当前的http请求 current HTTP request</span></span><br><span class="line"><span class="comment">	 * 2.2 httpServletResponse： 当前的http响应 current HTTP response</span></span><br><span class="line"><span class="comment">	 * 2.3 handler： 表示已经执行过的处理操作 the executed handler, or if none chosen at the</span></span><br><span class="line"><span class="comment">	 *          time of the exception (for example, if multipart resolution failed)</span></span><br><span class="line"><span class="comment">	 * 2.4 ex：表示当前发生的异常 the exception that got thrown during handler execution</span></span><br><span class="line"><span class="comment">	 * 2.5 返回一个模型视图对象来表示一个异常错误的视图页面 return a corresponding ModelAndView to forward to,</span></span><br><span class="line"><span class="comment">	 * 3.实现Ordered接口并实现其抽象方法，设置优先级，</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * 所有的非主依赖项目统一使用日志桥接，主项目使用具体日志收集日志交接的日志信息做统一处理。</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">	</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	        Result result=<span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ApplicationException)&#123;</span><br><span class="line">	            <span class="comment">//自定义异常类</span></span><br><span class="line">	            ApplicationException applicationException= (ApplicationException) ex;</span><br><span class="line">	            result =Result.creat(applicationException.getCode()).setMessage(applicationException.getMessage());</span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	            result=Result.creat(ResultCode.ERROR).setMessage(<span class="string">"出现未知异常"</span>);</span><br><span class="line">	            logger.error(ex.getMessage(),ex);</span><br><span class="line">	        &#125;</span><br><span class="line">	        httpServletResponse.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">	        httpServletResponse.setStatus(HttpStatus.OK.value());<span class="comment">//记得debug一下</span></span><br><span class="line">	        PrintWriter writer= <span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            writer = httpServletResponse.getWriter();</span><br><span class="line">	            writer.write(JSON.toJSONString(result));</span><br><span class="line">	            writer.flush();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	            logger.error(<span class="string">" resolver json result exception "</span>, e);</span><br><span class="line">	        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	            writer.close();</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//这里可以自定义返回错误的视图页面。</span></span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义异常类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 18:09</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 统一的自定义应用基类异常：</span></span><br><span class="line"><span class="comment">	 * 需要继承已有的异常类如RuntimeException、Exception类等，这里继承了RuntimeException类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4895794930959697784L</span>;</span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE = <span class="string">"应用异常"</span>;</span><br><span class="line">	<span class="comment">//自定义统一响应结果码</span></span><br><span class="line">	    <span class="keyword">protected</span> <span class="keyword">int</span> code = ResultCode.APPLICATION_ERROR;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(MESSAGE);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message);</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message, cause);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(<span class="keyword">int</span> code, String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(message, cause);</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>(cause);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>自定义响应结果格式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 17:16</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * SpringMVC统一响应请求的返回结果格式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//返回的结果体</span></span><br><span class="line">	    <span class="keyword">protected</span>  Object data;</span><br><span class="line">	    <span class="comment">//返回的结果状态码</span></span><br><span class="line">	    <span class="keyword">protected</span> Integer code;</span><br><span class="line">	    <span class="comment">//返回的结果信息</span></span><br><span class="line">	    <span class="keyword">protected</span> String message;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * setting/getting方法</span></span><br><span class="line"><span class="comment">	    * set方法返回当前对象，可用于伸缩</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> data;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.data = data;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> code;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code = code;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> message;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Result <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.message = message;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	    * 构造器私有化，推荐使用静态工厂方法代替构造方法，</span></span><br><span class="line"><span class="comment">	    * 但没有公共或受保护的构造方法不能被子类化即不能被继承，推荐使用组合</span></span><br><span class="line"><span class="comment">	    * */</span></span><br><span class="line">	    <span class="function"><span class="keyword">private</span>  <span class="title">Result</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">private</span> <span class="title">Result</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.code=code;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//提供静态工厂方法获取实体类对象实例,可按参数伸缩</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creat(ResultCode.SUCCESS);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Result <span class="title">creat</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> Result(code);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">(Object data,String message)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creatSuccessResult().setData(data).setMessage(message);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">creatSuccessResult</span><span class="params">(Object data,String message,Integer code)</span></span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> creat(code).creatSuccessResult(data,message);</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>自定义响应结果的状态码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@data</span> 2020/1/6 17:32</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 自定义响应返回结果状态码，具体业务返回码可以继承ResultCode</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultCode</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//成功状态码1</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">static</span> <span class="keyword">int</span> SUCCESS=<span class="number">1</span>;</span><br><span class="line">	    <span class="comment">//错误状态码以4开头</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">5555</span>;<span class="comment">// 未知错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> APPLICATION_ERROR = <span class="number">5000</span>;<span class="comment">// 应用级错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VALIDATE_ERROR = <span class="number">5001</span>;<span class="comment">// 参数验证错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SERVICE_ERROR = <span class="number">5002</span>;<span class="comment">// 业务逻辑验证错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CACHE_ERROR = <span class="number">5003</span>;<span class="comment">// 缓存访问错误</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DAO_ERROR = <span class="number">5004</span>;<span class="comment">// 数据访问错误</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC-异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-web.xml配置文件</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-web-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-web.xml.png" alt="思维导图"></p>
<a id="more"></a>
<h2><span id="一-基本配置">一、基本配置</span></h2><pre><code>Web.xml主要是用来加载servlet实例的。默认的servlet实例：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">servlets</span>.<span class="title">DefaultServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">debug</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;0&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">listings</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应servlet实例处理的url请求映射，servlet&gt;和servlet-mapping&gt;标签是成对出现的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>标签元素说明：<br>    1. servlet-name&gt;:设置servlet实例的名字。<br>    2. servlet-class&gt;:servlet实例对应的类。<br>    3. init-param&gt;:表示初始化该servlet实例时的一些初始化参数，里面含有param-name&gt;标签标识参数名，<param-value>标签标识参数值。<br>        a. debug：表示调试等级，0表示提供最少的信息，9表示提供最多的信息<br>        b. listings：表示是否列出web路径下的所有页面，false表示不显示目录结构<br>    4. load-on-startup&gt;：表示在servlet容器标记启动时是否加载这个servlet实例并调用其init()方法，它的值必须是一个整数，表示servlet实例被载入的顺序，当值为0或者大于0时表示在容器启动的时候就加载并初始化这个servlet，当值小于0或者没有指定时，表示该servlet被选择时，容器才会去加载；正值的数越小，该servlet的优先级越高，容器启动时就先加载，当值相同时，容器会自己选择顺序加载。<br>二、init-param&gt;元素详解<br>    再看一个专门处理jsp的servlet配置：</param-value></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">servlet</span>.<span class="title">JspServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">fork</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">xpoweredBy</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">false</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;3&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对用的url映射路径：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>其中主要说一下init-param&gt;元素里面的参数：</p>
<p><img src="https://img-blog.csdnimg.cn/20200413222911821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="三-其他配置标签">三、其他配置标签</span></h2><ol>
<li>设置session会话超时时间</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Mime-mapping标签</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;mime-mapping&gt;</span><br><span class="line">	        &lt;extension&gt;zip&lt;/extension&gt;</span><br><span class="line">	        &lt;mime-type&gt;application/zip&lt;/mime-type&gt;</span><br><span class="line">	    &lt;/mime-mapping&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;mime-mapping&gt;</span><br><span class="line">	     &lt;extension&gt;htm&lt;/extension&gt; </span><br><span class="line">	      &lt;mime-type&gt;text/html;charset=gb2312&lt;/mime-type&gt;</span><br><span class="line">	 &lt;/mime-mapping&gt;</span><br><span class="line">	</span><br><span class="line">	 &lt;mime-mapping&gt;</span><br><span class="line">	      &lt;extension&gt;html&lt;/extension&gt; </span><br><span class="line">	      &lt;mime-type&gt;text/html;charset=gb2312&lt;/mime-type&gt; </span><br><span class="line">	 &lt;/mime-mapping&gt;</span><br></pre></td></tr></table></figure>


<p>mime-mapping是web.xml中的一个节点，用来指定对应的格式的浏览器处理方式，另外也可以用来配置静态页面的打开编码。</p>
<p>常见的MIME类型:<br>    超文本标记语言文本 .htm,.html text/html<br>    普通文本 .txt text/plain<br>    RTF文本 .rtf application/rtf<br>    GIF图形 .gif image/gif<br>    JPEG图形 .ipeg,.jpg image/jpeg<br>    au声音文件 .au audio/basic<br>    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>    MPEG文件 .mpg,.mpeg video/mpeg<br>    AVI文件 .avi video/x-msvideo<br>    GZIP文件 .gz application/x-gzip<br>    TAR文件 .tar application/x-tar</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-server.xml配置文件</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-server-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-server.xml.png" alt="思维导图"></p>
<h2><span id="一-目前tomcat8的serverxml配置">一、目前tomcat8的server.xml配置：</span></h2><p>该配置文件描述了如何启动Tomcat 服务以及怎么处理请求服务。</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> SSLEngine=<span class="string">"on"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><br><span class="line">  &lt;Listener className=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;Resource name=<span class="string">"UserDatabase"</span> auth=<span class="string">"Container"</span></span><br><span class="line">              type=<span class="string">"org.apache.catalina.UserDatabase"</span></span><br><span class="line">              description=<span class="string">"User database that can be updated and saved"</span></span><br><span class="line">              factory=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="line">              pathname=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span><br><span class="line">  &lt;/GlobalNamingResources&gt;</span><br><span class="line">  &lt;Service name=<span class="string">"Catalina"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;Connector port=<span class="string">"8009"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;Realm className=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span><br><span class="line">        &lt;Realm className=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span><br><span class="line">               resourceName=<span class="string">"UserDatabase"</span>/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span></span><br><span class="line">            unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">	&lt;Logger&gt;</span><br><span class="line">	&lt;Context&gt;</span><br><span class="line">        &lt;Valve className=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> directory=<span class="string">"logs"</span></span><br><span class="line">               prefix=<span class="string">"localhost_access_log"</span> suffix=<span class="string">".txt"</span></span><br><span class="line">               pattern=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="二-根据上面的配置文件tomcat-server的结构图">二、根据上面的配置文件，tomcat server的结构图</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413215547844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id><img src="https://img-blog.csdnimg.cn/20200413215640150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="三、配置文件的各个标签及属性说明"></span></h2><h2><span id="四-serverxml标签元素详解">四、server.xml标签元素详解</span></h2><h3><span id="server标签元素">Server标签元素</span></h3><p>server标签代表着这个容器，但自身并不是一个”container”容器，不能在里面定义其他像Loggers等组件，它是tomcat实例的顶层元素，由org.apache.catalina.Server接口定义，其使用的默认className是：org.apache.catalina.core.StandarServer类。它包含<service>元素，并且它不能作为任何元素的子元素。<br>    一个server是一个提供完整的JVM的独立组件，它可以包含一个或者多个Service实例。server服务器再指定的端口上监听shutdown命令。</service></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面表示：启动server,在端口8005处等待关闭命令，如果接收到“SHUTDOWN”字符串则关闭服务器。<br>测试一下：<br>我们先启动tomcat服务器：<br>    <img src="https://img-blog.csdnimg.cn/20200413222005468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在cmd命令控制台上连接8005端口：telnet localhost 8005<br>然后输入：SHUTDOWN 按回车就会发现启动的tomcat被关闭了。</p>
<h3><span id="service标签元素">Service标签元素</span></h3><p>该元素由org.apache.catalina.Service接口定义，默认实现类是org.apache.catalina.StandardService类；它包含一个<engine>元素以及多个connector元素，这些connector元素共享同一个Engine元素。<br>        Service name=”Catalina”:表示处理所有直接由tomcat服务器接收到的web客户请求。<br>        Service name=”Apache”:表示处理所有由Apache服务器转发过来的web客户请求。</engine></p>
<h3><span id="connector标签元素">Connector标签元素</span></h3><p>由connector接口定义，该元素代表与客户端实际交互的组件，它负责接受客户端请求，以及向客户端返回响应结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 一个“Connector”（连接器）代表一个请求被接收和应答所需要的端点。每个连</span><br><span class="line">	        接器通过相关的“Container”（容器）处理请求。</span><br><span class="line">	         </span><br><span class="line">	         默认情况下，一个非SSL的HTTP/<span class="number">1.1</span>的连接器被绑定在端口<span class="number">8080</span>。你也可以通过</span><br><span class="line">	         根据后面的使用说明并取消第二个连接器入口的注释，在端口<span class="number">8443</span>上建立一个</span><br><span class="line">	         SSL HTTP/<span class="number">1.1</span>的连接器。开放SSL支持需要下面几步（参见Tomcat <span class="number">5</span>文档中怎样</span><br><span class="line">	         配置SSL的说明以取得更多的详细信息）：</span><br><span class="line">	         * 如果你的JDK是<span class="number">1.3</span>或<span class="number">1.3</span>以前的版本，下载安装JSSE <span class="number">1.0</span><span class="number">.2</span>或以后版本，并放</span><br><span class="line">	           置JAR文件到“$JAVA_HOME/jre/lib/ext”目录下。</span><br><span class="line">	         * 带一个“changeit”的口令值执行：</span><br><span class="line">	             %JAVA_HOME%\bin\keytool -genkey -alias tomcat -<span class="function">keyalg <span class="title">RSA</span> <span class="params">(Windows)</span></span></span><br><span class="line"><span class="function">	             $JAVA_HOME/bin/keytool -genkey -alias tomcat -keyalg <span class="title">RSA</span> <span class="params">(UNIX)</span></span></span><br><span class="line"><span class="function">	           来生成它自己的证书私钥。</span></span><br><span class="line"><span class="function">	           </span></span><br><span class="line"><span class="function">	         默认情况下，当一个web应用程序调用请求时，DNS查询是可行的。这将对性能造</span></span><br><span class="line"><span class="function">	         成一些不利的影响，因此，你可以将“enableLookups”设置为“<span class="keyword">false</span>”来关闭DNS</span></span><br><span class="line"><span class="function">	         查询。当DNS查询被关闭时，request.<span class="title">getRemoteHost</span><span class="params">()</span>将返回包含远程客户IP地</span></span><br><span class="line"><span class="function">	         址的字符串。</span></span><br><span class="line"><span class="function">	  --&gt;</span></span><br><span class="line"><span class="function">	&lt;!-- Coyote HTTP/1.1 Connector</span></span><br></pre></td></tr></table></figure>
<p>className : 该Connector的实现类是org.apache.coyote.tomcat4.CoyoteConnector<br>port : 在端口号8080处侦听来自客户browser的HTTP1.1请求.如果把8080改成80,则只要输入<a href="http://localhost/即可" target="_blank" rel="noopener">http://localhost/即可</a><br> protocol:设定Http协议,默认值为HTTP/1.1<br>    minSpareThreads: 该Connector先创建5个线程等待客户请求，每个请求由一个线程负责</p>
<p>maxSpareThread:设定在监听端口的线程的最大数目,这个值也决定了服务器可以同时响应客户请求的最大数目.默认值为200</p>
<p> acceptCount : 当现有线程已经达到最大数75时，为客户请求排队.当队列中请求数超过100时，后来的请求返回Connection refused错误</p>
<p>redirectport : 当客户请求是https时，把该请求转发到端口8443去<br> enableLookups:如果设为true,表示支持域名解析,可以把IP地址解析为主机名.WEB应用中调用request.getRemoteHost方法返回客户机主机名.默认值为true<br>connectionTimeout:定义建立客户连接超时的时间.如果为-1,表示不限制建立客户连接的时间<br>    allowTrace：是否允许HTTP的TRACE方法，默认为false<br>emptySessionPath：如果设置为true，用户的所有路径都将设置为/，默认为false。<br>    enableLookups：调用request、getRemoteHost()执行DNS查询，以返回远程主机的主机名，如果设置为false，则直接返回IP地址。<br>    maxPostSize：指定POST方式请求的最大量，没有指定默认为2097152。<br>    protocol：值必须为HTTP1.1，如果使用AJP处理器，该值必须为AJP/1.3<br>    proxyName：如这个连接器正在一个代理配置中被使用，指定这个属性，在request.getServerName()时返回<br>    redirectPort：如连接器不支持SSL请求，如收到SSL请求，Catalina容器将会自动重定向指定的端口号，让其进行处理。<br>    scheme：设置协议的名字，在request.getScheme()时返回，SSL连接器设为”https”，默认为”http”<br>    secure：在SSL连接器可将其设置为true，默认为false<br>    URIEncoding：用于解码URL的字符编码，没有指定默认值为ISO-8859-1<br>    useBodyEncodingForURI：主要用于Tomcat4.1.x中，指示是否使用在contentType中指定的编码来取代URIEncoding，用于解码URI查询参数，默认为false<br>    xpoweredBy：为true时，Tomcat使用规范建议的报头表明支持Servlet的规范版本，默认为false<br>    acceptCount：当所有的可能处理的线程都正在使用时，在队列中排队请求的最大数目。当队列已满，任何接收到的请求都会被拒绝，默认值为10<br>    bufferSize：设由连接器创建输入流缓冲区的大小，以字节为单位。默认情况下，缓存区大的大小为2048字节<br>    compressableMimeType：MIME的列表，默认以逗号分隔。默认值是text/html，text/xml，text/plain<br>    compression：指定是否对响应的数据进行压缩。off：表示禁止压缩、on：表示允许压缩（文本将被压缩）、force：表示所有情况下都进行压缩，默认值为off<br>    connectionTimeout：设置连接的超时值，以毫秒为单位。默认值为60000=60秒<br>    disableUploadTimeOut：允许Servlet容器，正在执行使用一个较长的连接超时值，以使Servlet有较长的时间来完成它的执行，默认值为false<br>    maxHttpHeaderSize：HTTP请求和响应头的最大量，以字节为单位，默认值为4096字节<br>    maxKeepAliveRequest：服务器关闭之前，客户端发送的流水线最大数目。默认值为100<br>    maxSpareThreads：允许存在空闲线程的最大数目，默认值为50<br>    minSpareThreads：设当连接器第一次启协创建线程的数目，确保至少有这么多的空闲线程可用。默认值为4<br>    port：服务端套接字监听的TCP端口号，默认值为8080（必须）<br>    socketBuffer：设Socket输出缓冲区的大小（以字节为单位），-1表示禁止缓冲，默认值为9000字节<br>    toNoDelay：为true时，可以提高性能。默认值为true<br>    threadPriority：设JVM中请求处理线程优先级。默认值为NORMAL-PRIORITY<br>    例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Connector </span><br><span class="line">port=<span class="string">"8080"</span> maxHttpHeaderSize=<span class="string">"8192"</span> maxThreads=<span class="string">"150"</span> minSpareThreads=<span class="string">"25"</span> maxSpareThreads=<span class="string">"75"</span> enableLookups=<span class="string">"false"</span></span><br><span class="line">redirectPort=<span class="string">"8443"</span> acceptCount=<span class="string">"100"</span> connectionTimeout=<span class="string">"20000"</span> disableUploadTimeout=<span class="string">"true"</span> /&gt; </span><br><span class="line">AJP连接器：</span><br><span class="line">用于将Apache与Tomcat集成在一起，当Apache接收到动态内容请求时，通过在配置中指定的端口号将请求发送给在此端口号上监听的AJP连接器组件。</span><br><span class="line">属性：</span><br><span class="line">backlog：当所有可能的请求处理线程都在使用时，队列中排队的请求最大数目。默认为<span class="number">10</span>，当队列已满，任何请求都将被拒绝</span><br><span class="line">maxSpareThread：允许存在空闲线程的最大数目，默认值为<span class="number">50</span></span><br><span class="line">maxThread：最大线程数，默认值为<span class="number">200</span></span><br><span class="line">minSpareThreads：设当连接器第一次启动时创建线程的数目，确保至少有这么多的空闲线程可用，默认值为<span class="number">4</span></span><br><span class="line">port：服务端套接字的TCP端口号，默认值为<span class="number">8089</span>（必须）</span><br><span class="line">topNoDelay：为<span class="keyword">true</span>时，可以提高性能，默认值为<span class="keyword">true</span></span><br><span class="line">soTimeout：超时值</span><br><span class="line">例：</span><br><span class="line">&lt;!—Define an AJP1<span class="number">.3</span> Connector on port <span class="number">8089</span>--&gt;</span><br><span class="line">&lt;Connector port=”<span class="number">8089</span>” enableLookups=”<span class="keyword">false</span>” redirectPort=”<span class="number">8443</span>” protocol=”AJP/<span class="number">1.3</span>” /&gt;</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;Connector port=<span class="string">"8080"</span> maxThread=<span class="string">"50"</span> minSpareThreads=<span class="string">"25"</span> maxSpareThread=<span class="string">"75"</span> enableLookups=<span class="string">"false"</span> redirectPort=<span class="string">"8443"</span> acceptCount=<span class="string">"100"</span> debug=<span class="string">"0"</span> connectionTimeout=<span class="string">"20000"</span> disableUploadTimeout=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;Connection port=<span class="string">"8009"</span> enableLookups=<span class="string">"false"</span> redirectPort=<span class="string">"8443"</span> debug=<span class="string">"0"</span> protocol=<span class="string">"AJP/1.3"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>第一个Connector元素定义了一个HTTP Connector,它通过8080端口接收HTTP请求;第二个Connector元素定义了一个JD Connector,它通过8009端口接收由其它服务器转发过来的请求.</p>
<h3><span id="engine标签元素">Engine标签元素</span></h3><p>每个service元素只能有一个Engine元素，处理同一个Service中所有Connector元素接收到的客户请求，由Engine接口定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Engine用来处理Connector收到的Http请求</span><br><span class="line"></span><br><span class="line">         它将匹配请求和自己的虚拟主机，并把请求转交给对应的Host来处理</span><br><span class="line"></span><br><span class="line">         默认虚拟主机是localhost</span><br><span class="line"></span><br><span class="line">         --&gt;</span><br><span class="line"></span><br><span class="line">&lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span> debug=<span class="string">"0"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>1&gt;className指定实现Engine接口的类,默认值为StandardEngine<br>2&gt;defaultHost指定处理客户的默认主机名,在Engine中的Host子元素中必须定义这一主机<br>3&gt;name定义Engine的名字<br>    在Engine可以包含如下元素Logger, Realm, Value, Host</p>
<h3><span id="host标签元素">Host标签元素</span></h3><p>它由Host接口定义，一个Engine元素可以包含多个Host元素，每个Host元素定义了一个虚拟机主机，它包含一个或多个web应用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">	 appBase : 指 定虚拟主机的目录,可以指定绝对目录,也可以指定相对于&lt;CATALINA_HOME&gt;的相对目录.如果没有此项,默认 为&lt;CATALINA_HOME&gt;/webapps. 它将匹配请求和自己的Context的路径，并把请求转交给对应的Context来处 理</span><br><span class="line">	              autoDeploy:如果此项设为<span class="keyword">true</span>,表示Tomcat服务处于运行状态时,能够监测appBase下的文件,如果有新有web应用加入进来,会自运发布这个WEB应用</span><br><span class="line">	              unpackWARs:如果此项设置为<span class="keyword">true</span>,表示把WEB应用的WAR文件先展开为开放目录结构后再运行.如果设为<span class="keyword">false</span>将直接运行为WAR文件</span><br><span class="line">	              alias:指定主机别名,可以指定多个别名</span><br><span class="line">	              deployOnStartup:如果此项设为<span class="keyword">true</span>,表示Tomcat服务器启动时会自动发布appBase目录下所有的Web应用.如果Web应用 中的server.xml没有相应的&lt;Context&gt;元素,将采用Tomcat默认的Context</span><br><span class="line">	</span><br><span class="line">	           --&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;Host name=<span class="string">"localhost"</span> debug=<span class="string">"0"</span> appBase=<span class="string">"webapps"</span> unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在Host元素中可以包含如下子元素<br>    Logger, Realm, Value, Context</p>
<h3><span id="context标签元素">Context标签元素</span></h3><p>它是由Context接口定义，是使用最频繁的元素，每个Context元素代表了运行在虚拟主机上的单个web应用，一个Host可以包含多个Context元素，每一个web应用都有唯一一个相对应的context元素，servlet容器就是作为第一个web应用被创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- Context，对应于一个Web App</span><br><span class="line">	 path : 该Context的路径名是<span class="string">""</span>，故该Context是该Host的默认Context</span><br><span class="line">	 docBase : 该Context的根目录是webapps/mycontext/</span><br><span class="line">	 reloadable:如果这个属性设为<span class="keyword">true</span>, Tomcat服务器在运行状态下会监视在WEB-INF/classes和Web-INF/lib目录CLASS文件的改运.如果监视到有<span class="class"><span class="keyword">class</span>文件 被更新,服务器自重新加载<span class="title">Web</span>应用</span></span><br><span class="line">	 useNaming:指定是否支持JNDI,默认值为了true </span><br><span class="line">	 cookies指定是否通过Cookies来支持Session,默认值为<span class="keyword">true</span></span><br><span class="line">	 -&gt;</span><br><span class="line">	&lt;Context path=<span class="string">""</span> docBase=<span class="string">"mycontext"</span> debug=<span class="string">"0"</span>/&gt;</span><br></pre></td></tr></table></figure>


<h2><span id="五-tomcat处理一个http请求的过程">五、tomcat处理一个http请求的过程</span></h2><p>假设来自客户端的请求：<a href="http://localhost:8080/index/index.html.jsp" target="_blank" rel="noopener">http://localhost:8080/index/index.html.jsp</a><br>        1. 请求被发送到本机端口8080上，并被监听8080端口、HTTP/1.1协议的Connector获取到。<br>        2. Connector把该请求交给它所在Service的Engine来处理，并等待来自Engine的响应<br>        3. Engine获得该请求后，匹配它所拥有的所有虚拟主机Host.<br>        4. Engine匹配到名为localhost的主机Host(即使匹配不到也会交给localhost主机来处理，因为Engine的默认主机就是localhost)<br>        5. localhost的主机解析获取到请求/index/index.jsp,匹配它所拥有的所有Context。<br>        6. Host匹配到路径为/index的Context。<br>        7. Path=”/index”的Context获取到请求index.jsp,在它的mapping table中寻找对应的servlet<br>        8. Context匹配到URL为.jsp的servlet类(其实就是JspServlet类做处理)<br>        9. 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用servlet类的doGet或doPost方法<br>        10. Context把执行完的HttpServletResponse对象返回给Host<br>        11. Host把HttpServletResponse对象返回给Engine<br>        12. Engine把HttpServletRespongse对象返回给Connector<br>        13. Connector把HttpServletResponse对象返回给客户端。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-思维导图</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/Tomcat%E6%95%99%E7%A8%8B.png" alt="思维导图"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-教程-基本使用</title>
    <url>/2020/04/13/Tomcat-%E6%95%99%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="思维导图-总览">思维导图-总览</span></h2><p><img src="/images/tomcat-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8.png" alt="思维导图"></p>
<a id="more"></a>
<h2><span id="一-什么是tomcat">一、什么是Tomcat</span></h2><p> tomcat是一个Web服务器，是一个运行java程序的网络服务器，底层是Socket的一个程序，它也是jsp和Servlet的一个容器。<br><img src="https://img-blog.csdnimg.cn/20200413213630443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="二-配置tomcat">二、配置tomcat</span></h2><p> 运行Tomcat需要JDK的支持，tomcat会通过JAVA_HOME找到所需要的JDK，所以只需要配置JDK的环境变量就可以了。注意tomcat的版本与JDK的版本有一定的关系，例如JDK8不能匹配tomcat7，需要降低jdk的版本。<br>启动tomcat的时候一般出现的问题：</p>
<ul>
<li>JAVA_HOME没有配置正确</li>
<li>端口被占用了，解决办法：<pre><code>a. 查看端口被谁占用了，将该进程杀死
b. 主动修改tomcat启动使用的端口，修改的位置在tomcat主目录下的conf/server.xml配置文件中修改成其他端口：</code></pre><img src="https://img-blog.csdnimg.cn/20200413213710893.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200413213732843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2><span id="三-tomcat目录结构tomcat8">三、tomcat目录结构（tomcat8）</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413213819316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>bin目录：存放启动和关闭tomcat的bat文件</li>
<li>conf目录：存放配置文件，主要有的配置文件：<pre><code>a. Server.xml：该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机（Host），该文件描述了如何启动tomcat。详细看Tomcat-server.xml配置文件里面包含了tomcat处理一个Http请求的详细过程
b. Web.xml:Web应用的配置文件
Tomcat-web.xml配置文件和Web应用-web.xml配置文件
c. Tomcat-user.xml:配置用户名密码和相关权限</code></pre></li>
<li>lib目录：存放tomcat运行所需要的jar包</li>
<li>logs:存放日志文件，可以查看tomcat运行web程序的相关日志信息</li>
<li>webapps：放置我们的web应用</li>
<li>work：该目录用于存放jsp被访问后生成对应的server文件和.class文件</li>
</ol>
<h2><span id="四-webapps目录">四、webapps目录</span></h2><p>我们使用tomcat部署项目，接触最多的就是webapps目录，所以有必要单独拿出来说明一下。webapps目录结构如下：<br>    <img src="https://img-blog.csdnimg.cn/20200413213904708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么这样设计这样的webapps目录结构呢，因为webapps下的web应用目录是可以直接存放html等文件，是直接允许访问的资源，如果有多个html文件呢，tomcat启动的时候该访问哪个html文件呢，这就很难决定了；于是就存在WEB-INF目录下的web.xml文件，有了web.xml的支持，就可以给web应用指定规范了，当然上面的问题也能够得到解决。<br>    web.xml配置详解：Tomcat-web.xml配置文件和Web应用-web.xml配置文件<br>    指定访问首页可以添加一下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;welcome-file-list&gt;</span><br><span class="line">       &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line"> &lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="五-配置虚拟目录">五、配置虚拟目录</span></h2><h3><span id="为什么需要配置虚拟目录">为什么需要配置虚拟目录</span></h3><p>当存在很多web应用项目的目录的时候，空间很多，可能导致该磁盘所在的空间不够用，不利于对web项目目录的管理，可以把wen应用的目录分散到其他磁盘，这样就需要配置虚拟目录，然后创建映射，即可管理不同磁盘位置的目录了。</p>
<h3><span id="怎么配置虚拟目录">怎么配置虚拟目录</span></h3><p>两种方法：<br>a. 第一种<br>        在tomcat目录下/conf/server.xml文件中配置，在<host>元素下添加<context>元素并设置path和docBase属性值，其中path标识url中的项目名称，如：<a href="http://localhost:8080/path/index.html；docBase表示web项目的绝对路径，例如：" target="_blank" rel="noopener">http://localhost:8080/path/index.html；docBase表示web项目的绝对路径，例如：</a></context></host></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Context path=<span class="string">"/demo"</span> docBase=<span class="string">"D:\demo"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>设置好了之后，在浏览器输入<a href="http://localhost:8080/demo/index.html，就会在D盘的demo目录下访问index.html资源了。" target="_blank" rel="noopener">http://localhost:8080/demo/index.html，就会在D盘的demo目录下访问index.html资源了。</a><br>b. 第二种<br>在conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是web项目名称，例如创建了一个叫demo1.xml,同时设置web项目路径</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt; </span><br><span class="line">&lt;Context </span><br><span class="line">    docBase=<span class="string">"D:\demo"</span> </span><br><span class="line">    reloadable=<span class="string">"true"</span>&gt; </span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器直接访问:<a href="http://localhost:8080/demo1/index.html；就会去D盘下的demo目录访问index.xml资源了。" target="_blank" rel="noopener">http://localhost:8080/demo1/index.html；就会去D盘下的demo目录访问index.xml资源了。</a></p>
<h2><span id="六-配置临时域名">六、配置临时域名</span></h2><ol>
<li>访问tomcat服务器的方式：<pre><code>a. 使用localhost域名访问（localhost表示本机）
b. 使用127.0.0.1访问
c. 使用本机的具体ip地址访问
d. 使用本机的机器电脑名称访问
e. 还可以使用给服务器配置的临时域名进行访问</code></pre></li>
<li>怎么配置临时域名<br> 自定义本机的域名：（在C:\Windows\System32\drivers\etc\hosts文件）<pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413214314465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70)</code></pre> 然后在tomcat目录下conf\server.xml配置文件的<host>元素上添加上面自定义的域名：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;Host name=<span class="string">"huahua"</span> appBase=<span class="string">"D:\demo"</span>&gt;</span><br><span class="line">	&lt;Context path=<span class="string">"/demo"</span> docBase=<span class="string">"D:\demo"</span>&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>



</host></li>
</ol>
<h2><span id="七-tomcat的体系结构">七、tomcat的体系结构</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413214350867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="八-tomcat在浏览器访问web资源的流程图">八、tomcat在浏览器访问web资源的流程图</span></h2><p><img src="https://img-blog.csdnimg.cn/20200413214409735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat-教程</tag>
      </tags>
  </entry>
</search>
