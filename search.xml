<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring-教程-简介</title>
    <url>/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1><span id="spring是什么">spring是什么</span></h1><p>spring是一个企业级应用的开源框架，它也是轻量级的、一站式的、面向切面编程的、依赖注入DI和容器IOC的、模块化的框架。<br>总的来说，Spring就是用来替代更加重量级的企业级的Java技术。</p>
<h1><span id="spring能做什么">spring能做什么</span></h1><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性的角度而言，绝大部分Java应用都可以从Spring中受益。<br>spring实现了使用简单的组件将Java对象配置组合成 了一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象。Spring对JavaEE中非常难开发的一些API（JDBC、JavaMail、远程调用等），都提供了封装，大大降低了这些API的应用难度。</p>
<ul>
<li>轻量级：立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>非侵入式：也就是自己开发的类不依赖Spring的API接口，对现有的类结构没有影响，也能够增强JavaBean的功能  </li>
<li>IOC容器：spring是一个容器，因为它包含并且管理应用对象的生命周期。<br>降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>一站式：在AOP和IOC的基础上可以整合出各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的JDBC）;<br>spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。<br>总的来说Spring可以简化Java的开发：</li>
</ul>
<ol>
<li>基于POJO（也叫Java bean）轻量级和最小侵入式开发</li>
<li>通过IOC、依赖注入和面向接口实现松耦合</li>
<li>基于切面进行声明式编程</li>
<li>通过切面和模板来减少样板式代码</li>
</ol>
<a id="more"></a>
<h1><span id="spring为什么出现">spring为什么出现</span></h1><p><img src="/images/Spring-1-1.png" alt="B/S结构"><br>这张图上展示了一个基于SSH,B/S结构的单体Java应用的搭建过程，首先通过浏览器进入到Filter拦截器，进入到Structs2，通过Service层进入到Hibernate，从而进行操作数据库，若整个过程都是由SpringIOC容器控制就显得那么简单了。说白了就是为了简化复杂的操作过程，减少问题的出现。这张图向我们展示了一个比较基础的JavaWeb的搭建过程。万变不离其宗，后来使用的SSM框架，现在比较火的微服务架构，都离不开这张图上展示的内容所提供给大家的思想。每个框架的实现宗旨都是一样的，只不过实现的方式不一样。其实在这个框架最初的时候应该是以JSP+Servlet比较常用，后来为了解决前后端分离的问题，降低耦合度。将这些功能结构按照MVC分层实现。<br>个人的理解MVC为一种程序设计思想，可以很多场合使用到，从Web、后端、移动端在很多的场合下将MVC作为一种程序设计思想应该是比较恰当的。</p>
<h1><span id="spring结构体系模块化">spring结构体系（模块化）</span></h1><p><img src="/images/Spring-1-2.png" alt="Spring结构"></p>
<h2><span id="核心容器">核心容器</span></h2><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：<br>-** spring-core模块**提供了框架的基本组成部分，包括 IoC容器 和依赖注入功能。</p>
<p>-** spring-beans 模块**提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
<p>-** context模块**建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
<p>-<strong>spring-expression模块</strong>提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
<p>它们的完整依赖关系如下图所示：<br><img src="/images/Spring-1-3.png" alt="Spring依赖关系图"><br><img src="/images/Spring-1-4.png" alt="Spring关系"></p>
<h2><span id="数据访问集成">数据访问/集成</span></h2><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：<br>注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）<br>• JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。<br>• ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。<br>• OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。<br>• JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。<br>• 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h2><span id="web">Web</span></h2><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：<br>• Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。<br>• Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。<br>• Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。<br>• Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
<h2><span id="其他">其他</span></h2><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：<br>• AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。<br>• Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。<br>• Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。<br>• Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。<br>• 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring,教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-线程的基本状态和操作</title>
    <url>/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><p>线程拥有自己的生命周期，一条线程从创建到执行完毕的过程就是线程的生命周期，那么在线程的生命周期的每个过程中可能在不同的时候处于不同的状态，用状态来描述生命周期那是最好不过了。<br>那么线程的生命周期到底有多少种状态呢，它们不同的状态又是如何通过状态的转化操作来完成线程的生命周期呢，下面就按照线程的生命周期的状态和状态之间的转换操作来详细说明。</p>
<h2><span id="二-线程的基本状态">二、线程的基本状态</span></h2><p>线程的状态没有严格的定义，可以先简单划分以下几个基本状态：<br>    <img src="https://img-blog.csdnimg.cn/20200411192919905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图中的五种状态描述如下：<br>a. New（新建）状态：一个线程被创建了但未被启动就处于新建状态，即在程序中使用new Thread()创建的线程实例就处于新建状态。<br>b. Runnable(可运行)状态：创建的线程实例通过调用start（）方法之后该线程就处于可运行状态，处于此状态的线程不一定说处于运行状态，Java多线程使用的线程调度策略是抢占式调度，每个可运行线程轮着获取CPU时间片，可以想象成一个可运行线程池，start()方法就是把一个线程放进可运行线程池中，CPU按照一定规则一个个执行线程池里面的线程。<br>c. Running（运行）状态：当可运行线程获取到CPU执行时间片就立即进入运行状态。<br>d. Not Running（非运行）状态：运行中的线程因某种原因暂时放弃CPU的使用权，可能是因为只执行了挂起、睡眠或者等待操作；在执行IO操作时，由于外部设备速度远低于处理器速度也可能导致线程暂时方法CPU使用权；在获取对象的同步锁的过程中如果同步锁被其他线程获取了，这样也会导致线程暂时放弃CPU的使用权了。<br>e. Dead(死亡)状态：线程执行完run()方法的任务之后，或者因为异常而导致退出任务，线程就进入死亡状态，该状态下是不能转换成其他状态了。</p>
<h2><span id="三-线程的状态转换">三、线程的状态转换</span></h2><p>在上面的五个状态中，是通过这些基本操作来完成状态之间的转换，基本操作配合五种状态就完成了线程的交替运行，把Not Running状态分成：Blocked（阻塞）、Waiting（等待）和Timed_Waiting(超时等待)这三个状态（以Synchronized锁及相关方法为例），如下图：<br>    <img src="https://img-blog.csdnimg.cn/20200411193016770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Blocked(阻塞)状态：当线程出现资源竞争，等待获取同步锁时，线程就会进入阻塞状态，直到线程获取到了锁，线程才会进入可运行状态。</li>
<li>Waiting(等待)状态：运行中的线程执行了Object.wait(),Thread.join(),LockSupport.park()等方法或者被其他线程调用interrupt()中断方法的时候就会进入等待状态，便进入了等待线程队列，如果有锁会释放锁，当在其他线程中调用对象的notify(),notifyAll(),LockSupport.unpart()方法就会唤醒等待线程队列中的线程，notify是随机唤醒一个线程，notifyAll是唤醒所有线程，唤醒后的线程会对该对象的monitor占有权竞争，获得占有权的线程才能转化为可运行状态。</li>
<li>Timed_Waiting(超时等待)状态：在wait(long),sleep(long),join(long)和LockSupport.partNanos(long),LockSupport.partUntil(long)方法中都加入了超时，调用这些方法设置超时时间后线程会进入超时等待状态，同时会把占有的锁释放；如果调用了notify(),notifyAll(),LockSupport.unpart()方法或者超时时间到了，线程就会被唤醒，重新对该对象的monitor占有权竞争，获得占有权的线程才会转化为可运行状态</li>
</ul>
<h2><span id="四-线程的基本操作">四、线程的基本操作</span></h2><p>从上面的图可以看出，线程的基本操作就是为了完成线程状态之间的转化，同时还是线程间的通信方式。</p>
<h3><span id="新建线程">新建线程</span></h3><p>新建线程的方式有三种：</p>
<ul>
<li>重写Runnable接口的run()方法创建线程（Thread类实现了Runnable接口，两者启动线程都是通过Thread类，运行的目标线程是Runnable类型的，所以只要是Runnable的子类都可以通过Thread类来启动线程）:<br><strong>i.</strong> 创建Thread类型对象，同时重写run()方法，然后通过Thread类启动线程<br><strong>ii.</strong> 创建Runnable类型对象，同时实现run()方法，然后通过Thread类启动线程</li>
<li>重写Callable接口的call()方法实现创建线程，由于含有回调的方法，所以配合FutureTask类可以实现异步结果返回效果（FutureTask类实现了RunnableFuture接口【该接口又继承了Runnable接口和Future接口】）<br>i. 创建Callable类型对象，同时实现call()方法，然后创建FutureTask类对象并传入Callable类型对象同时指定返回值类型，然后通过Thread类启动线程。</li>
<li>利用线程池Excutor创建线程（推荐使用这种）。ExcutorService接口含有submit()方法，参数可以是Callable接口类型和Runnable接口类型；若<br>参数是Callable接口类型，返回的是Future接口类型，可以使用Executors工具类来创建ExcutorService类型对象，然后使用ExcutorService对象调用Callable接口实现类，最后使用Future接收返回的结果。若参数是Runnable接口，则直接调用即可。（后面会专门分析FutureTask类和Excutors工具类）</li>
</ul>
<p>代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> huahua</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020/2/26</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@desc</span> 创建线程的方式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * 方法一：通过创建Thread类型对象，同时重写run()方法</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span>  Thread()&#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Thread类型对象，同时重写run()方法。。。"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;.start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式二：通过创建Runnable类型对象,同时实现run()方法</span></span><br><span class="line"><span class="comment">	         *</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过创建Runnable类型对象,同时实现run()方法"</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;).start();</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式三：通过实现Callable接口并实现call()方法,并异步返回执行结果</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        FutureTask&lt;String&gt; result=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过实现Callable接口并实现call()方法,并异步返回执行结果"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程执行完成"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">	        System.out.println(<span class="string">"callable接口执行返回的结果："</span>+result.get());</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	         * 方式四：通过线程池来创建（只列举实现Callable接口）</span></span><br><span class="line"><span class="comment">	         * */</span></span><br><span class="line">	        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">	        FutureTask&lt;String&gt; result1= (FutureTask&lt;String&gt;) service.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line">	</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                System.out.println(<span class="string">"通过线程池方式创建线程"</span>);</span><br><span class="line">	                <span class="keyword">return</span> <span class="string">"线程池执行Callable的call方法返回的结果"</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	        System.out.println(<span class="string">"线程池返回的结果："</span>+result1.get());</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="其他对于线程的操作方法">其他对于线程的操作方法</span></h3><p>可以参考：Java-并发理论-源码分析-Thread类:常用方法（主要是操作线程的方法）<br>列举一下join()方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	        Thread previousThread = Thread.currentThread();</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	            Thread curThread = <span class="keyword">new</span> JoinThread(previousThread);</span><br><span class="line">	            curThread.start();</span><br><span class="line">	            previousThread = curThread;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">private</span> Thread thread;</span><br><span class="line">	</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                thread.join();</span><br><span class="line">	                System.out.println(thread.getName() + <span class="string">" terminated."</span>);</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                e.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程，直到for循环执行完了，main线程执行完了，就会从上往下一个个继续执行。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-首页</title>
    <url>/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<h2><span id="简介">简介：</span></h2><p>基本包含了Java并发编程的知识内容同时囊括并发Concurrent包的重点源码分析，如有问题欢迎评论指出，谢谢支持！<br>关注微信公众号获取更多知识：当代猿<br><img src="https://img-blog.csdnimg.cn/20200409181814334.png#pic_center" alt="微信公共号二维码"></p>
<h2><span id="思维导图">思维导图：</span></h2><p><img src="https://img-blog.csdnimg.cn/20200409181910892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：思维导图链接，待完成后一起公布。</p>
<h2><span id="目录">目录：</span></h2><p>说明：目录会持续更新</p>
<ol>
<li>Java-并发编程-认识并发编程</li>
<li>Java-并发基础-线程的基本状态和操作</li>
<li>Java-并发理论-JMM内存模型</li>
<li>Java-并发理论-对象锁（monitor）</li>
<li>Java-并发理论-关键字-synchronized</li>
<li>Java-并发理论-关键字-volatile</li>
<li>Java-并发理论-关键字-final</li>
<li>Java-并发理论-三大特性</li>
<li>Java-并发理论-源码分析-Thread类</li>
<li>Java-并发concurrent包-简介</li>
<li>Java-并发concurrent包-atomic包</li>
<li>Java-并发concurrent包-locks包</li>
<li>Java-并发工具-并发容器-ConcurrentHashMap</li>
<li>Java-并发工具-并发容器-CopyOnWriteArrayList</li>
<li>Java-并发工具-并发容器-CopyOnWriteSet</li>
<li>Java-并发工具-并发容器-阻塞队列</li>
<li>Java-并发工具-线程池-原理&amp;ThreadPoolEcecutor</li>
<li>Java-并发工具-线程池-原理&amp;ScheduledThreadPoolExecutor</li>
<li>Java-并发工具-基本类FutureTask</li>
<li>Java-并发工具-工具类Excutors</li>
<li>Java-并发工具-工具类CountDownLatch</li>
<li>Java-并发工具-工具类CyclicBarrier</li>
<li>Java-并发工具-工具类Semaphore</li>
<li>Java-并发工具-工具类Exchanger</li>
<li>Java-并发实践-生产者与消费者</li>
</ol>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发基础-认识并发编程</title>
    <url>/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2><span id="一-基本简介">一、基本简介</span></h2><h3><span id="什么是并发">什么是并发</span></h3><p>在Java中并发就是指多线程的进程环境，进程是系统进行资源分配和调度的独立单位，每一个进程都有它的内存空间和系统资源，在同一个进程内执行的多个任务就可以看作是多个进程，线程存在于进程内，进程负责分配调度线程，线程负责执行程序，多个线程就执行多个程序。<br>实际上，Java程序天生就是一个多线程程序，包含了：</p>
<ul>
<li>分发处理发送给JVM信号的线程</li>
<li>调用对象的finalize清除方法的线程</li>
<li>清除相互引用reference的线程</li>
<li>main线程，也就是用户程序的入口，main线程里面还可以拥有很多的子线程</li>
</ul>
<h3><span id="为什么需要多线程">为什么需要多线程</span></h3><p>如果没有多线程，若为了使程序并发执行，那么系统需要花费大量的时间在：创建进程–&gt;撤销进程–&gt;进程上下文切换调度,在这一过程中，需要的空间开销也非常大，执行效率也非常低（如下图）；若在一个进程中执行多个线程，则上面的空间开销和时间花费将会大大较少，何乐而不为呢，多线程提高了系统的执行效率，充分利用多核CPU的计算能力，提高应用性能。<br><img src="https://img-blog.csdnimg.cn/20200411183436680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="二-并发编程带来的问题">二、并发编程带来的问题</span></h2><h3><span id="频繁的上下文切换问题">频繁的上下文切换问题</span></h3><p>正如上图中的时间片，时间片使CPU分配给各个线程的时间，因为时间非常短，所以CPU需要不断切换线程，让我们觉得多个线程是同时执行的，时间片一般是十几毫秒；每次切换都需要保存当前线程的状态，以便进行恢复先前的状态。这个切换是非常耗性能的，过于频繁就无法发挥出多线程编程的优势了。那么该怎么解决这频繁的上下文切换的问题的，目前有大概几种解决方法，后面会详细讨论：</p>
<ol>
<li>采用无锁并发编程：JDK8以前的concurrentHashMap采用的锁分段思想，不同线程处理不同段的数据，这样在多线程环境下可以减少上下文的切换时间。</li>
<li>采用CAS算法：JDK8以后的concurrentHashMap采用的是无锁CAS算法；利用Atomic和乐观锁，可以减少一部分不必要的锁竞争带来的上下文切换。</li>
<li>尽量减少线程的使用：避免创建不需要的线程，比如任务少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态。</li>
<li>采用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。<br>因此，并发累加未必会比串行累加的速度快，这上下文切换的问题在实际中是需要解决的。</li>
</ol>
<h3><span id="线程安全问题主要问题也是我们程序开发关心的问题">线程安全问题（主要问题，也是我们程序开发关心的问题）</span></h3><p>对线程编程中最难控制的就是临界区（共享内存的地方）的线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。那么怎么解决这种问题呢，解决方法如下：</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内部占用多个资源，尽量保证一个锁只占用一个资源</li>
<li>尝试使用定时锁，如使用lock.tryLock(timeOut),当超时等待时当前线程也不会阻塞</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里（同一个事务），否则会出现解锁失败的情况<br>后面还有JMM内存模型在原子性、有序性和可见性带来的问题，比如数据脏读，内存泄漏等等问题，这是又该如何保证线程安全呢，这一方面是非常重要的，后面会详细讨论。</li>
</ul>
<h2><span id="三-并发编程的相关概念">三、并发编程的相关概念</span></h2><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步通常用来形容方法的一次调用。<br>同步方法从被调用开始，调用者就必须等待被调用的方法结束后，调用者后面的代码才能继续执行。<br>异步方法指的是，调用者不管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。</p>
<h3><span id="并发和并行">并发和并行</span></h3><p>并发是指多个任务线程交替进行。<br>并行是指真正意义上的“同时进行”。<br>实际上，如果系统只有一个CPU，而使用多线程时，那么真实环境下时不能并行执行的，只能通过切换时间片的方式交替进行，完成并发执行任务，真正的并行只能出现在拥有多个CPU系统中。</p>
<h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。<br>阻塞是指如果一个线程占用了临界区的资源，那么其他线程需要这个资源的话就必须等待资源的释放，就会导致等待的线程挂起，这种情况就叫做阻塞。<br>非阻塞刚好跟阻塞相反，它强调的是没有一个线程可以阻塞其他线程，所有的线程都会尝试的向前运行。</p>
<h3><span id="临界区">临界区</span></h3><p>临界区用来表示一种公共资源会共享数据，可以被多个线程使用，出于线程安全问题，如果一个线程占用了临界区的资源，那么其他线程就必须等待，知道临界区的资源被释放。</p>
<h3><span id="守护线程">守护线程</span></h3><p>守护线程是一种特殊的线程，是系统的服务线程，是专门为其他线程服务的，像垃圾回收线程就是守护线程，与之对应的是用户线程，用户线程作为系统的工作线程，守护线程的服务对象就是用户线程，当全部的用户线程执行任务完成之后，这个系统就没有什么需要服务的了，那么守护线程就没有对象需要守护了，那么守护线程就会结束，也就是说当一个java程序只有守护线程的时候，虚拟机就会退出了。</p>
<h2><span id="四-java中的线程thread类">四、Java中的线程Thread类</span></h2><p>参考看一下Thread类的源码注释，了解Java中的线程，有专门对Thread类的源码做分析：Java-源码分析-Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	1.一个Thread类对象代表程序中的一个线程，jvm是允许多线程的</span></span><br><span class="line"><span class="comment">	 * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java</span></span><br><span class="line"><span class="comment">	 * Virtual Machine allows an application to have multiple threads of</span></span><br><span class="line"><span class="comment">	 * execution running concurrently.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.每一个线程都有优先级，具有高优先级的线程优先于底优先级的线程执行，每一个线程都可以设置成一个守护线程，创建线程的时候，通过线程设置setDaemon(true)就可以设置该线程为守护线程，设置守护线程需要先于start()方法</span></span><br><span class="line"><span class="comment">	 * Every thread has a priority. Threads with higher priority are</span></span><br><span class="line"><span class="comment">	 * executed in preference to threads with lower priority. Each thread</span></span><br><span class="line"><span class="comment">	 * may or may not also be marked as a daemon. When code running in</span></span><br><span class="line"><span class="comment">	 * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new</span></span><br><span class="line"><span class="comment">	 * thread has its priority initially set equal to the priority of the</span></span><br><span class="line"><span class="comment">	 * creating thread, and is a daemon thread if and only if the</span></span><br><span class="line"><span class="comment">	 * creating thread is a daemon.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	2.只有当一个Java程序只存在守护线程的时候，虚拟机就会退出，让虚拟机不继续执行线程的方法有：</span></span><br><span class="line"><span class="comment">		2.1调用system.exit方法.</span></span><br><span class="line"><span class="comment">		2.2所有非守护线程都处于死亡状态（只有守护线程）或线程运行抛出了异常</span></span><br><span class="line"><span class="comment">	   注意：在线程启动前可以将该线程设置为守护线程，方法是setDaemon(boolean on)</span></span><br><span class="line"><span class="comment">		     使用守护线程最好不要在方法中使用共享资源，因为守护线程随时都可能挂掉</span></span><br><span class="line"><span class="comment">		     在守护线程中产生的线程也是守护线程</span></span><br><span class="line"><span class="comment">	 * When a Java Virtual Machine starts up, there is usually a single</span></span><br><span class="line"><span class="comment">	 * non-daemon thread (which typically calls the method named</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual</span></span><br><span class="line"><span class="comment">	 * Machine continues to execute threads until either of the following</span></span><br><span class="line"><span class="comment">	 * occurs:</span></span><br><span class="line"><span class="comment">	 * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been</span></span><br><span class="line"><span class="comment">	 *     called and the security manager has permitted the exit operation</span></span><br><span class="line"><span class="comment">	 *     to take place.</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;All threads that are not daemon threads have died, either by</span></span><br><span class="line"><span class="comment">	 *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by</span></span><br><span class="line"><span class="comment">	 *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 *     method.</span></span><br><span class="line"><span class="comment">	 * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	3.创建线程的方式有两种（重写Runnable接口的run()方法）：</span></span><br><span class="line"><span class="comment">		3.1创建子类并继承Thread 类，同时重写run()方法（因为Thread类实现了Runnable接口）</span></span><br><span class="line"><span class="comment">		3.2创建子类并实现Runnable接口，同时重写run()方法</span></span><br><span class="line"><span class="comment">		下面有例子：</span></span><br><span class="line"><span class="comment">	 * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment">	 * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This</span></span><br><span class="line"><span class="comment">	 * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be</span></span><br><span class="line"><span class="comment">	 * allocated and started. For example, a thread that computes primes</span></span><br><span class="line"><span class="comment">	 * larger than a stated value could be written as follows:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeThread(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeThread p = new PrimeThread(143);</span></span><br><span class="line"><span class="comment">	 *     p.start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then</span></span><br><span class="line"><span class="comment">	 * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can</span></span><br><span class="line"><span class="comment">	 * then be allocated, passed as an argument when creating</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other</span></span><br><span class="line"><span class="comment">	 * style looks like the following:</span></span><br><span class="line"><span class="comment">	 * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     class PrimeRun implements Runnable &#123;</span></span><br><span class="line"><span class="comment">	 *         long minPrime;</span></span><br><span class="line"><span class="comment">	 *         PrimeRun(long minPrime) &#123;</span></span><br><span class="line"><span class="comment">	 *             this.minPrime = minPrime;</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *         public void run() &#123;</span></span><br><span class="line"><span class="comment">	 *             // compute primes larger than minPrime</span></span><br><span class="line"><span class="comment">	 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.</span></span><br><span class="line"><span class="comment">	 *         &#125;</span></span><br><span class="line"><span class="comment">	 *     &#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * The following code would then create a thread and start it running:</span></span><br><span class="line"><span class="comment">	 * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 *     PrimeRun p = new PrimeRun(143);</span></span><br><span class="line"><span class="comment">	 *     new Thread(p).start();</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	4.每个线程都有一个名称，如果没有会在创建的时候自动生成一个，除非指定为null。</span></span><br><span class="line"><span class="comment">	 * Every thread has a name for identification purposes. More than</span></span><br><span class="line"><span class="comment">	 * one thread may have the same name. If a name is not specified when</span></span><br><span class="line"><span class="comment">	 * a thread is created, a new name is generated for it.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * Unless otherwise noted, passing a &#123;<span class="doctag">@code</span> null&#125; argument to a constructor</span></span><br><span class="line"><span class="comment">	 * or method in this class will cause a &#123;<span class="doctag">@link</span> NullPointerException&#125; to be</span></span><br><span class="line"><span class="comment">	 * thrown.</span></span><br><span class="line"><span class="comment">	 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="五-总结">五、总结</span></h2><p>我们需要了解并发，为什么需要并发，还必须知道并发的优缺点，同时清楚使用并发编程之后所带来的问题：频繁上下文切换问题和线程安全问题等等，后面在并发编程的时候就朝着这些问题去编程，尝试解决这些问题，让并发编程发挥出真正的作用。<br>理解Java并发的关键点在于理解它的两大核心（JMM内存模型【工作内存和主内存】和happes-before规则【八大规则】）以及三大特性：原子性、可见性、有序性</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>java,并发</tag>
      </tags>
  </entry>
</search>
