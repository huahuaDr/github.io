<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当代猿</title>
  
  <subtitle>huahua</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/huahuablog/"/>
  <updated>2020-04-11T12:34:50.480Z</updated>
  <id>https://github.com/huahuablog/</id>
  
  <author>
    <name>huahua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-并发理论-对象锁（monitor）</title>
    <link href="https://github.com/huahuablog/2020/11/03/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88monitor%EF%BC%89/"/>
    <id>https://github.com/huahuablog/2020/11/03/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%88monitor%EF%BC%89/</id>
    <published>2020-11-03T12:20:37.000Z</published>
    <updated>2020-04-11T12:34:50.480Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;Java提供了一种内置的锁机制来支持原子性和可见性，就是使用Synchronized的同步块或同步方法。在使用synchronized同步的时候，包含两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a. 一个锁对象引用&lt;/li&gt;
&lt;li&gt;b. 一块锁保护的代码块
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title> Java-并发concurrent包-locks包</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-locks%E5%8C%85/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-locks%E5%8C%85/</id>
    <published>2020-04-11T12:25:14.000Z</published>
    <updated>2020-04-11T12:45:04.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发concurrent包-atomic包</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-atomic%E5%8C%85/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-atomic%E5%8C%85/</id>
    <published>2020-04-11T12:24:08.000Z</published>
    <updated>2020-04-11T12:45:02.529Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发concurrent包-简介</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-%E7%AE%80%E4%BB%8B/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91concurrent%E5%8C%85-%E7%AE%80%E4%BB%8B/</id>
    <published>2020-04-11T12:23:51.000Z</published>
    <updated>2020-04-11T12:45:06.127Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-源码分析-Thread类</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Thread%E7%B1%BB/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Thread%E7%B1%BB/</id>
    <published>2020-04-11T12:23:13.000Z</published>
    <updated>2020-04-11T12:45:01.265Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-Thread类</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-Thread%E7%B1%BB/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-Thread%E7%B1%BB/</id>
    <published>2020-04-11T12:22:47.000Z</published>
    <updated>2020-04-11T12:44:54.340Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-三大特性</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2020-04-11T12:22:25.000Z</published>
    <updated>2020-04-11T12:45:00.059Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-关键字-final</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-final/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-final/</id>
    <published>2020-04-11T12:21:52.000Z</published>
    <updated>2020-04-11T12:44:57.722Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-关键字-volatile</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-volatile/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-volatile/</id>
    <published>2020-04-11T12:21:26.000Z</published>
    <updated>2020-04-11T12:44:58.861Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-关键字-synchronized</title>
    <link href="https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-synchronized/"/>
    <id>https://github.com/huahuablog/2020/04/11/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-%E5%85%B3%E9%94%AE%E5%AD%97-synchronized/</id>
    <published>2020-04-11T12:21:00.000Z</published>
    <updated>2020-04-11T12:43:24.764Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Synchronized&quot;&gt;&lt;a href=&quot;#一、什么是Synchronized&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Synchronized&quot;&gt;&lt;/a&gt;一、什么是Synchronized&lt;/h2&gt;&lt;p&gt;这个可以参考一下介绍：Java-并发理论-JMM内存模型：volatile和锁（synchronized，ReentrantLock）。&lt;br&gt;Synchronized关键字主要是用来解决多线程的线程安全问题的。是一种同步机制。那么这些安全性问题主要是来源JMM内存模型中主内存和线程的工作内存带来共享变量的可见性问题，以及重排序带来的问题；Java中的关键字synchronized同步机制就具备解决这些共享数据的线程安全问题，但是这种同步机制的效率很低，但是synchronized是其他并发容器实现的基础，理解它会提高并发编程有很大帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring-教程-简介</title>
    <link href="https://github.com/huahuablog/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/"/>
    <id>https://github.com/huahuablog/2020/04/06/Spring-%E6%95%99%E7%A8%8B-%E7%AE%80%E4%BB%8B/</id>
    <published>2020-04-06T11:33:04.000Z</published>
    <updated>2020-04-11T11:42:53.864Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring是什么&quot;&gt;&lt;a href=&quot;#spring是什么&quot; class=&quot;headerlink&quot; title=&quot;spring是什么&quot;&gt;&lt;/a&gt;spring是什么&lt;/h1&gt;&lt;p&gt;spring是一个企业级应用的开源框架，它也是轻量级的、一站式的、面向切面编程的、依赖注入DI和容器IOC的、模块化的框架。&lt;br&gt;总的来说，Spring就是用来替代更加重量级的企业级的Java技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://github.com/huahuablog/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://github.com/huahuablog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发理论-JMM内存模型</title>
    <link href="https://github.com/huahuablog/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/huahuablog/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-11-02T11:46:20.000Z</published>
    <updated>2020-04-11T12:44:55.985Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是JMM内存模型&quot;&gt;&lt;a href=&quot;#一、什么是JMM内存模型&quot; class=&quot;headerlink&quot; title=&quot;一、什么是JMM内存模型&quot;&gt;&lt;/a&gt;一、什么是JMM内存模型&lt;/h2&gt;&lt;p&gt;Java内存模型即 Java Menory Model，简称JMM。JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方法。JVM是整个计算机虚拟模型，所以JMM隶属于JVM的。&lt;br&gt;    Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此在Java1.5版本对其进行了重构，现在的Java8仍沿用了1.5的版本。 模型如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411194726969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VzZV9hZG1pbg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发基础-线程的基本状态和操作</title>
    <link href="https://github.com/huahuablog/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/huahuablog/2019/11/02/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%92%8C%E6%93%8D%E4%BD%9C/</id>
    <published>2019-11-01T22:47:45.000Z</published>
    <updated>2020-04-11T11:42:59.106Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、基本简介&quot;&gt;&lt;a href=&quot;#一、基本简介&quot; class=&quot;headerlink&quot; title=&quot;一、基本简介&quot;&gt;&lt;/a&gt;一、基本简介&lt;/h2&gt;&lt;p&gt;线程拥有自己的生命周期，一条线程从创建到执行完毕的过程就是线程的生命周期，那么在线程的生命周期的每个过程中可能在不同的时候处于不同的状态，用状态来描述生命周期那是最好不过了。&lt;br&gt;那么线程的生命周期到底有多少种状态呢，它们不同的状态又是如何通过状态的转化操作来完成线程的生命周期呢，下面就按照线程的生命周期的状态和状态之间的转换操作来详细说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发-首页</title>
    <link href="https://github.com/huahuablog/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/"/>
    <id>https://github.com/huahuablog/2019/11/01/Java%E5%B9%B6%E5%8F%91-%E9%A6%96%E9%A1%B5/</id>
    <published>2019-11-01T10:32:01.000Z</published>
    <updated>2020-04-11T11:43:06.145Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h2&gt;&lt;p&gt;基本包含了Java并发编程的知识内容同时囊括并发Concurrent包的重点源码分析，如有问题欢迎评论指出，谢谢支持！&lt;br&gt;关注微信公众号获取更多知识：当代猿&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发基础-认识并发编程</title>
    <link href="https://github.com/huahuablog/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://github.com/huahuablog/2019/11/01/Java-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2019-11-01T08:57:48.000Z</published>
    <updated>2020-04-11T11:44:50.313Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、基本简介&quot;&gt;&lt;a href=&quot;#一、基本简介&quot; class=&quot;headerlink&quot; title=&quot;一、基本简介&quot;&gt;&lt;/a&gt;一、基本简介&lt;/h2&gt;&lt;h3 id=&quot;什么是并发&quot;&gt;&lt;a href=&quot;#什么是并发&quot; class=&quot;headerlink&quot; title=&quot;什么是并发&quot;&gt;&lt;/a&gt;什么是并发&lt;/h3&gt;&lt;p&gt;在Java中并发就是指多线程的进程环境，进程是系统进行资源分配和调度的独立单位，每一个进程都有它的内存空间和系统资源，在同一个进程内执行的多个任务就可以看作是多个进程，线程存在于进程内，进程负责分配调度线程，线程负责执行程序，多个线程就执行多个程序。&lt;br&gt;实际上，Java程序天生就是一个多线程程序，包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分发处理发送给JVM信号的线程&lt;/li&gt;
&lt;li&gt;调用对象的finalize清除方法的线程&lt;/li&gt;
&lt;li&gt;清除相互引用reference的线程&lt;/li&gt;
&lt;li&gt;main线程，也就是用户程序的入口，main线程里面还可以拥有很多的子线程
    
    </summary>
    
    
      <category term="Java并发" scheme="https://github.com/huahuablog/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java,并发" scheme="https://github.com/huahuablog/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
